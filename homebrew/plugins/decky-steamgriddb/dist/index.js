(function (React) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

    let webpackCache = {};
    let hasWebpack5 = false;
    if (window.webpackJsonp && !window.webpackJsonp.deckyShimmed) {
        // Webpack 4, currently on stable
        const wpRequire = window.webpackJsonp.push([
            [],
            { get_require: (mod, _exports, wpRequire) => (mod.exports = wpRequire) },
            [['get_require']],
        ]);
        delete wpRequire.m.get_require;
        delete wpRequire.c.get_require;
        webpackCache = wpRequire.c;
    }
    else {
        // Webpack 5, currently on beta
        hasWebpack5 = true;
        const id = Math.random();
        let initReq;
        window.webpackChunksteamui.push([
            [id],
            {},
            (r) => {
                initReq = r;
            },
        ]);
        for (let i of Object.keys(initReq.m)) {
            webpackCache[i] = initReq(i);
        }
    }
    const allModules = hasWebpack5
        ? Object.values(webpackCache).filter((x) => x)
        : Object.keys(webpackCache)
            .map((x) => webpackCache[x].exports)
            .filter((x) => x);
    const findModule = (filter) => {
        for (const m of allModules) {
            if (m.default && filter(m.default))
                return m.default;
            if (filter(m))
                return m;
        }
    };
    const findModuleChild = (filter) => {
        for (const m of allModules) {
            for (const mod of [m.default, m]) {
                const filterRes = filter(mod);
                if (filterRes) {
                    return filterRes;
                }
                else {
                    continue;
                }
            }
        }
    };
    const CommonUIModule = allModules.find((m) => {
        if (typeof m !== 'object')
            return false;
        for (let prop in m) {
            if (m[prop]?.contextType?._currentValue && Object.keys(m).length > 60)
                return true;
        }
        return false;
    });
    const IconsModule = findModule((m) => {
        if (typeof m !== 'object')
            return false;
        for (let prop in m) {
            if (m[prop]?.toString && /Spinner\)}\),.\.createElement\(\"path\",{d:\"M18 /.test(m[prop].toString()))
                return true;
        }
        return false;
    });
    const ReactRouter = allModules.find((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.computeRootMatch)
                return true;
        }
        return false;
    });

    const CommonDialogDivs = Object.values(CommonUIModule).filter((m) => typeof m === 'object' && m?.render?.toString().includes('"div",Object.assign({},'));
    const MappedDialogDivs = new Map(Object.values(CommonDialogDivs).map((m) => {
        const renderedDiv = m.render({});
        // Take only the first class name segment as it identifies the element we want
        return [renderedDiv.props.className.split(' ')[0], m];
    }));
    const DialogHeader = MappedDialogDivs.get('DialogHeader');
    MappedDialogDivs.get('DialogSubHeader');
    const DialogFooter = MappedDialogDivs.get('DialogFooter');
    MappedDialogDivs.get('DialogLabel');
    const DialogBodyText = MappedDialogDivs.get('DialogBodyText');
    const DialogBody = MappedDialogDivs.get('DialogBody');
    const DialogControlsSection = MappedDialogDivs.get('DialogControlsSection');
    const DialogControlsSectionHeader = MappedDialogDivs.get('DialogControlsSectionHeader');
    const DialogButtonPrimary = Object.values(CommonUIModule).find((mod) => mod?.render?.toString()?.includes('DialogButton') && mod?.render?.toString()?.includes('Primary'));
    const DialogButtonSecondary = Object.values(CommonUIModule).find((mod) => mod?.render?.toString()?.includes('Object.assign({type:"button"') &&
        mod?.render?.toString()?.includes('DialogButton') &&
        mod?.render?.toString()?.includes('Secondary'));
    // This is the "main" button. The Primary can act as a submit button,
    // therefore secondary is chosen (also for backwards comp. reasons)
    const DialogButton = DialogButtonSecondary;

    const ControlsList = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (m[prop]?.toString && m[prop].toString().includes('().ControlsListChild') && m[prop].toString().includes('().ControlsListOuterPanel')) {
                return m[prop];
            }
        }
        return;
    });

    const DialogCheckbox = Object.values(findModule((m) => {
        if (typeof m !== 'object')
            return false;
        for (const prop in m) {
            if (m[prop]?.prototype?.GetPanelElementProps)
                return true;
        }
        return false;
    })).find((m) => m.contextType &&
        m.prototype?.render.toString().includes('fallback:') &&
        m?.prototype?.SetChecked &&
        m?.prototype?.Toggle &&
        m?.prototype?.GetPanelElementProps);

    const Dropdown = Object.values(CommonUIModule).find((mod) => mod?.prototype?.SetSelectedOption && mod?.prototype?.BuildMenu);
    Object.values(CommonUIModule).find((mod) => mod?.toString()?.includes('"dropDownControlRef","description"'));

    const Field = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.render?.toString().includes('"shift-children-below"'))
                return m[prop];
        }
    });

    const Focusable = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.render?.toString()?.includes('["flow-children","onActivate","onCancel","focusClassName",'))
                return m[prop];
        }
    });

    var GamepadButton;
    (function (GamepadButton) {
        GamepadButton[GamepadButton["INVALID"] = 0] = "INVALID";
        GamepadButton[GamepadButton["OK"] = 1] = "OK";
        GamepadButton[GamepadButton["CANCEL"] = 2] = "CANCEL";
        GamepadButton[GamepadButton["SECONDARY"] = 3] = "SECONDARY";
        GamepadButton[GamepadButton["OPTIONS"] = 4] = "OPTIONS";
        GamepadButton[GamepadButton["BUMPER_LEFT"] = 5] = "BUMPER_LEFT";
        GamepadButton[GamepadButton["BUMPER_RIGHT"] = 6] = "BUMPER_RIGHT";
        GamepadButton[GamepadButton["TRIGGER_LEFT"] = 7] = "TRIGGER_LEFT";
        GamepadButton[GamepadButton["TRIGGER_RIGHT"] = 8] = "TRIGGER_RIGHT";
        GamepadButton[GamepadButton["DIR_UP"] = 9] = "DIR_UP";
        GamepadButton[GamepadButton["DIR_DOWN"] = 10] = "DIR_DOWN";
        GamepadButton[GamepadButton["DIR_LEFT"] = 11] = "DIR_LEFT";
        GamepadButton[GamepadButton["DIR_RIGHT"] = 12] = "DIR_RIGHT";
        GamepadButton[GamepadButton["SELECT"] = 13] = "SELECT";
        GamepadButton[GamepadButton["START"] = 14] = "START";
        GamepadButton[GamepadButton["LSTICK_CLICK"] = 15] = "LSTICK_CLICK";
        GamepadButton[GamepadButton["RSTICK_CLICK"] = 16] = "RSTICK_CLICK";
        GamepadButton[GamepadButton["LSTICK_TOUCH"] = 17] = "LSTICK_TOUCH";
        GamepadButton[GamepadButton["RSTICK_TOUCH"] = 18] = "RSTICK_TOUCH";
        GamepadButton[GamepadButton["LPAD_TOUCH"] = 19] = "LPAD_TOUCH";
        GamepadButton[GamepadButton["LPAD_CLICK"] = 20] = "LPAD_CLICK";
        GamepadButton[GamepadButton["RPAD_TOUCH"] = 21] = "RPAD_TOUCH";
        GamepadButton[GamepadButton["RPAD_CLICK"] = 22] = "RPAD_CLICK";
        GamepadButton[GamepadButton["REAR_LEFT_UPPER"] = 23] = "REAR_LEFT_UPPER";
        GamepadButton[GamepadButton["REAR_LEFT_LOWER"] = 24] = "REAR_LEFT_LOWER";
        GamepadButton[GamepadButton["REAR_RIGHT_UPPER"] = 25] = "REAR_RIGHT_UPPER";
        GamepadButton[GamepadButton["REAR_RIGHT_LOWER"] = 26] = "REAR_RIGHT_LOWER";
        GamepadButton[GamepadButton["STEAM_GUIDE"] = 27] = "STEAM_GUIDE";
        GamepadButton[GamepadButton["STEAM_QUICK_MENU"] = 28] = "STEAM_QUICK_MENU";
    })(GamepadButton || (GamepadButton = {}));

    const Marquee = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (m[prop]?.toString && m[prop].toString().includes('.Marquee') && m[prop].toString().includes('--fade-length')) {
                return m[prop];
            }
        }
        return;
    });

    // TODO: implement storing patches as an option so we can offer unpatchAll selectively
    // Return this in a replacePatch to call the original method (can still modify args).
    let callOriginal = Symbol('DECKY_CALL_ORIGINAL');
    function afterPatch(object, property, handler, options = {}) {
        const orig = object[property];
        object[property] = function (...args) {
            let ret = patch.original.call(this, ...args);
            ret = handler.call(this, args, ret);
            if (options.singleShot) {
                patch.unpatch();
            }
            return ret;
        };
        const patch = processPatch(object, property, handler, object[property], orig);
        return patch;
    }
    function replacePatch(object, property, handler, options = {}) {
        const orig = object[property];
        object[property] = function (...args) {
            const ret = handler.call(this, args);
            if (ret == callOriginal)
                return patch.original.call(this, ...args);
            if (options.singleShot) {
                patch.unpatch();
            }
            return ret;
        };
        const patch = processPatch(object, property, handler, object[property], orig);
        return patch;
    }
    function processPatch(object, property, handler, patchedFunction, original) {
        // Assign all props of original function to new one
        Object.assign(object[property], original);
        // Allow toString webpack filters to continue to work
        object[property].toString = () => original.toString();
        // HACK: for compatibility, remove when all plugins are using new patcher
        Object.defineProperty(object[property], '__deckyOrig', {
            get: () => patch.original,
            set: (val) => (patch.original = val),
        });
        // Build a Patch object of this patch
        const patch = {
            object,
            property,
            handler,
            patchedFunction,
            original,
            hasUnpatched: false,
            unpatch: () => unpatch(patch),
        };
        object[property].__deckyPatch = patch;
        return patch;
    }
    function unpatch(patch) {
        const { object, property, handler, patchedFunction, original } = patch;
        if (patch.hasUnpatched)
            throw new Error('Function is already unpatched.');
        let realProp = property;
        let realObject = object;
        console.debug('[Patcher] unpatching', {
            realObject,
            realProp,
            object,
            property,
            handler,
            patchedFunction,
            original,
            isEqual: realObject[realProp] === patchedFunction,
        });
        // If another patch has been applied to this function after this one, move down until we find the correct patch
        while (realObject[realProp] && realObject[realProp] !== patchedFunction) {
            realObject = realObject[realProp].__deckyPatch;
            realProp = 'original';
            console.debug('[Patcher] moved to next', {
                realObject,
                realProp,
                object,
                property,
                handler,
                patchedFunction,
                original,
                isEqual: realObject[realProp] === patchedFunction,
            });
        }
        realObject[realProp] = realObject[realProp].__deckyPatch.original;
        patch.hasUnpatched = true;
        console.debug('[Patcher] unpatched', {
            realObject,
            realProp,
            object,
            property,
            handler,
            patchedFunction,
            original,
            isEqual: realObject[realProp] === patchedFunction,
        });
    }

    function fakeRenderComponent(fun, customHooks = {}) {
        const hooks = window.SP_REACT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher
            .current;
        // TODO: add more hooks
        let oldHooks = {
            useContext: hooks.useContext,
            useCallback: hooks.useCallback,
            useLayoutEffect: hooks.useLayoutEffect,
            useEffect: hooks.useEffect,
            useMemo: hooks.useMemo,
            useRef: hooks.useRef,
            useState: hooks.useState,
        };
        hooks.useCallback = (cb) => cb;
        hooks.useContext = (cb) => cb._currentValue;
        hooks.useLayoutEffect = (_) => { }; //cb();
        hooks.useMemo = (cb, _) => cb;
        hooks.useEffect = (_) => { }; //cb();
        hooks.useRef = (val) => ({ current: val || {} });
        hooks.useState = (v) => {
            let val = v;
            return [val, (n) => (val = n)];
        };
        Object.assign(hooks, customHooks);
        const res = fun(hooks);
        Object.assign(hooks, oldHooks);
        return res;
    }
    function wrapReactType(node, prop = 'type') {
        return (node[prop] = { ...node[prop] });
    }
    const findInTree = (parent, filter, opts) => {
        const { walkable = null, ignore = [] } = opts ?? {};
        if (!parent || typeof parent !== 'object') {
            // Parent is invalid to search through
            return null;
        }
        if (filter(parent))
            return parent; // Parent matches, just return
        if (Array.isArray(parent)) {
            // Parent is an array, go through values
            return parent.map((x) => findInTree(x, filter, opts)).find((x) => x);
        }
        // Parent is an object, go through values (or option to only use certain keys)
        return (walkable || Object.keys(parent))
            .map((x) => !ignore.includes(x) && findInTree(parent[x], filter, opts))
            .find((x) => x);
    };
    const findInReactTree = (node, filter) => findInTree(node, filter, {
        // Specialised findInTree for React nodes
        walkable: ['props', 'children', 'child', 'sibling'],
    });

    function joinClassNames(...classes) {
        return classes.join(' ');
    }
    function sleep(ms) {
        return new Promise((res) => setTimeout(res, ms));
    }
    /**
     * Finds the SP window, since it is a render target as of 10-19-2022's beta
     */
    function findSP() {
        // old (SP as host)
        if (document.title == 'SP')
            return window;
        // new (SP as popup)
        const focusNav = getFocusNavController();
        const context = focusNav.m_ActiveContext || focusNav.m_LastActiveContext;
        return context.m_rgGamepadNavigationTrees.find((x) => x.m_ID == 'root_1_').Root.Element.ownerDocument
            .defaultView;
    }
    /**
     * Gets the correct FocusNavController, as the Feb 22 2023 beta has two for some reason.
     */
    function getFocusNavController() {
        return window.GamepadNavTree?.m_context?.m_controller || window.FocusNavController;
    }

    const showContextMenu = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (typeof m[prop] === 'function' && m[prop].toString().includes('stopPropagation))')) {
                return m[prop];
            }
        }
    });
    const Menu = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.prototype?.HideIfSubmenu && m[prop]?.prototype?.HideMenu) {
                return m[prop];
            }
        }
    });
    findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if ((m[prop]?.toString()?.includes('bInGamepadUI:') &&
                fakeRenderComponent(() => m[prop]())?.type?.prototype?.RenderSubMenu) ||
                (m[prop]?.prototype?.RenderSubMenu && m[prop]?.prototype?.ShowSubMenu)) {
                return m[prop];
            }
        }
    });
    const MenuItem = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.render?.toString()?.includes('bPlayAudio:') ||
                (m[prop]?.prototype?.OnOKButton && m[prop]?.prototype?.OnMouseEnter)) {
                return m[prop];
            }
        }
    });
    /*
    all().map(m => {
    if (typeof m !== "object") return undefined;
    for (let prop in m) { if (m[prop]?.prototype?.OK && m[prop]?.prototype?.Cancel && m[prop]?.prototype?.render) return m[prop]}
    }).find(x => x)
    */

    const showModalRaw = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (typeof m[prop] === 'function' &&
                m[prop].toString().includes('props.bDisableBackgroundDismiss') &&
                !m[prop]?.prototype?.Cancel) {
                return m[prop];
            }
        }
    });
    const oldShowModalRaw = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (typeof m[prop] === 'function' && m[prop].toString().includes('bHideMainWindowForPopouts:!0')) {
                return m[prop];
            }
        }
    });
    const showModal = (modal, parent, props = {
        strTitle: 'Decky Dialog',
        bHideMainWindowForPopouts: false,
    }) => {
        if (showModalRaw) {
            return showModalRaw(modal, parent || findSP(), props.strTitle, props, undefined, {
                bHideActions: props.bHideActionIcons,
            });
        }
        else if (oldShowModalRaw) {
            return oldShowModalRaw(modal, parent || findSP(), props);
        }
        else {
            throw new Error('[DFL:Modals]: Cannot find showModal function');
        }
    };
    const ConfirmModal = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (!m[prop]?.prototype?.OK && m[prop]?.prototype?.Cancel && m[prop]?.prototype?.render) {
                return m[prop];
            }
        }
    });
    // new as of december 2022 on beta
    const ModalRoot = (Object.values(findModule((m) => {
        if (typeof m !== 'object')
            return false;
        for (let prop in m) {
            if (m[prop]?.m_mapModalManager && Object.values(m)?.find((x) => x?.type)) {
                return true;
            }
        }
        return false;
    }) || {})?.find((x) => x?.type?.toString()?.includes('((function(){')) ||
        // before december 2022 beta
        Object.values(findModule((m) => {
            if (typeof m !== 'object')
                return false;
            for (let prop in m) {
                if (m[prop]?.toString()?.includes('"ModalManager","DialogWrapper"')) {
                    return true;
                }
            }
            return false;
        }) || {})?.find((x) => x?.type?.toString()?.includes('((function(){')) ||
        // old
        findModuleChild((m) => {
            if (typeof m !== 'object')
                return undefined;
            for (let prop in m) {
                if (m[prop]?.prototype?.OK && m[prop]?.prototype?.Cancel && m[prop]?.prototype?.render) {
                    return m[prop];
                }
            }
        }));

    const [panelSection, mod] = findModuleChild((mod) => {
        for (let prop in mod) {
            if (mod[prop]?.toString()?.includes('.PanelSection')) {
                return [mod[prop], mod];
            }
        }
        return null;
    });
    const PanelSection = panelSection;
    // New as of Feb 22 2023 Beta || Old
    const PanelSectionRow = mod.PanelSectionRow ||
        Object.values(mod).filter((exp) => !exp?.toString()?.includes('.PanelSection'))[0];

    const ProgressBar = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.toString()?.includes('.ProgressBar,"standard"=='))
                return m[prop];
        }
    });
    findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.toString()?.includes('.ProgressBarFieldStatus},'))
                return m[prop];
        }
    });
    findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.toString()?.includes('"indeterminate","nTransitionSec"'))
                return m[prop];
        }
    });

    var SideMenu;
    (function (SideMenu) {
        SideMenu[SideMenu["None"] = 0] = "None";
        SideMenu[SideMenu["Main"] = 1] = "Main";
        SideMenu[SideMenu["QuickAccess"] = 2] = "QuickAccess";
    })(SideMenu || (SideMenu = {}));
    var QuickAccessTab;
    (function (QuickAccessTab) {
        QuickAccessTab[QuickAccessTab["Notifications"] = 0] = "Notifications";
        QuickAccessTab[QuickAccessTab["RemotePlayTogetherControls"] = 1] = "RemotePlayTogetherControls";
        QuickAccessTab[QuickAccessTab["VoiceChat"] = 2] = "VoiceChat";
        QuickAccessTab[QuickAccessTab["Friends"] = 3] = "Friends";
        QuickAccessTab[QuickAccessTab["Settings"] = 4] = "Settings";
        QuickAccessTab[QuickAccessTab["Perf"] = 5] = "Perf";
        QuickAccessTab[QuickAccessTab["Help"] = 6] = "Help";
        QuickAccessTab[QuickAccessTab["Decky"] = 7] = "Decky";
    })(QuickAccessTab || (QuickAccessTab = {}));
    var DisplayStatus;
    (function (DisplayStatus) {
        DisplayStatus[DisplayStatus["Invalid"] = 0] = "Invalid";
        DisplayStatus[DisplayStatus["Launching"] = 1] = "Launching";
        DisplayStatus[DisplayStatus["Uninstalling"] = 2] = "Uninstalling";
        DisplayStatus[DisplayStatus["Installing"] = 3] = "Installing";
        DisplayStatus[DisplayStatus["Running"] = 4] = "Running";
        DisplayStatus[DisplayStatus["Validating"] = 5] = "Validating";
        DisplayStatus[DisplayStatus["Updating"] = 6] = "Updating";
        DisplayStatus[DisplayStatus["Downloading"] = 7] = "Downloading";
        DisplayStatus[DisplayStatus["Synchronizing"] = 8] = "Synchronizing";
        DisplayStatus[DisplayStatus["ReadyToInstall"] = 9] = "ReadyToInstall";
        DisplayStatus[DisplayStatus["ReadyToPreload"] = 10] = "ReadyToPreload";
        DisplayStatus[DisplayStatus["ReadyToLaunch"] = 11] = "ReadyToLaunch";
        DisplayStatus[DisplayStatus["RegionRestricted"] = 12] = "RegionRestricted";
        DisplayStatus[DisplayStatus["PresaleOnly"] = 13] = "PresaleOnly";
        DisplayStatus[DisplayStatus["InvalidPlatform"] = 14] = "InvalidPlatform";
        DisplayStatus[DisplayStatus["PreloadComplete"] = 16] = "PreloadComplete";
        DisplayStatus[DisplayStatus["BorrowerLocked"] = 17] = "BorrowerLocked";
        DisplayStatus[DisplayStatus["UpdatePaused"] = 18] = "UpdatePaused";
        DisplayStatus[DisplayStatus["UpdateQueued"] = 19] = "UpdateQueued";
        DisplayStatus[DisplayStatus["UpdateRequired"] = 20] = "UpdateRequired";
        DisplayStatus[DisplayStatus["UpdateDisabled"] = 21] = "UpdateDisabled";
        DisplayStatus[DisplayStatus["DownloadPaused"] = 22] = "DownloadPaused";
        DisplayStatus[DisplayStatus["DownloadQueued"] = 23] = "DownloadQueued";
        DisplayStatus[DisplayStatus["DownloadRequired"] = 24] = "DownloadRequired";
        DisplayStatus[DisplayStatus["DownloadDisabled"] = 25] = "DownloadDisabled";
        DisplayStatus[DisplayStatus["LicensePending"] = 26] = "LicensePending";
        DisplayStatus[DisplayStatus["LicenseExpired"] = 27] = "LicenseExpired";
        DisplayStatus[DisplayStatus["AvailForFree"] = 28] = "AvailForFree";
        DisplayStatus[DisplayStatus["AvailToBorrow"] = 29] = "AvailToBorrow";
        DisplayStatus[DisplayStatus["AvailGuestPass"] = 30] = "AvailGuestPass";
        DisplayStatus[DisplayStatus["Purchase"] = 31] = "Purchase";
        DisplayStatus[DisplayStatus["Unavailable"] = 32] = "Unavailable";
        DisplayStatus[DisplayStatus["NotLaunchable"] = 33] = "NotLaunchable";
        DisplayStatus[DisplayStatus["CloudError"] = 34] = "CloudError";
        DisplayStatus[DisplayStatus["CloudOutOfDate"] = 35] = "CloudOutOfDate";
        DisplayStatus[DisplayStatus["Terminating"] = 36] = "Terminating";
    })(DisplayStatus || (DisplayStatus = {}));
    const Router = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.Navigate && m[prop]?.NavigationManager)
                return m[prop];
        }
    });
    let Navigation = {};
    try {
        (async () => {
            let InternalNavigators = {};
            if (!Router.NavigateToAppProperties || Router.deckyShim) {
                function initInternalNavigators() {
                    try {
                        InternalNavigators = findModuleChild((m) => {
                            if (typeof m !== 'object')
                                return undefined;
                            for (let prop in m) {
                                if (m[prop]?.GetNavigator) {
                                    return m[prop];
                                }
                            }
                        })?.GetNavigator();
                    }
                    catch (e) {
                        console.error('[DFL:Router]: Failed to init internal navigators, trying again');
                    }
                }
                initInternalNavigators();
                while (!InternalNavigators?.AppProperties) {
                    console.log('[DFL:Router]: Trying to init internal navigators again');
                    await sleep(100);
                    initInternalNavigators();
                }
            }
            const newNavigation = {
                Navigate: Router.Navigate?.bind(Router),
                NavigateBack: Router.WindowStore?.GamepadUIMainWindowInstance?.NavigateBack?.bind(Router.WindowStore.GamepadUIMainWindowInstance),
                NavigateToAppProperties: InternalNavigators?.AppProperties || Router.NavigateToAppProperties?.bind(Router),
                NavigateToExternalWeb: InternalNavigators?.ExternalWeb || Router.NavigateToExternalWeb?.bind(Router),
                NavigateToInvites: InternalNavigators?.Invites || Router.NavigateToInvites?.bind(Router),
                NavigateToChat: Router.NavigateToChat?.bind(Router),
                NavigateToLibraryTab: InternalNavigators?.LibraryTab || Router.NavigateToLibraryTab?.bind(Router),
                NavigateToLayoutPreview: Router.NavigateToLayoutPreview?.bind(Router),
                NavigateToSteamWeb: Router.WindowStore?.GamepadUIMainWindowInstance?.NavigateToSteamWeb?.bind(Router.WindowStore.GamepadUIMainWindowInstance),
                OpenSideMenu: Router.WindowStore?.GamepadUIMainWindowInstance?.MenuStore.OpenSideMenu?.bind(Router.WindowStore.GamepadUIMainWindowInstance.MenuStore),
                OpenQuickAccessMenu: Router.WindowStore?.GamepadUIMainWindowInstance?.MenuStore.OpenQuickAccessMenu?.bind(Router.WindowStore.GamepadUIMainWindowInstance.MenuStore),
                OpenMainMenu: Router.WindowStore?.GamepadUIMainWindowInstance?.MenuStore.OpenMainMenu?.bind(Router.WindowStore.GamepadUIMainWindowInstance.MenuStore),
                CloseSideMenus: Router.CloseSideMenus?.bind(Router),
                OpenPowerMenu: Router.OpenPowerMenu?.bind(Router),
            };
            Object.assign(Navigation, newNavigation);
        })();
    }
    catch (e) {
        console.error('[DFL:Router]: Error initializing Navigation interface', e);
    }

    const SliderField = Object.values(CommonUIModule).find((mod) => mod?.toString()?.includes('SliderField,fallback'));

    // TODO type this and other icons?
    const Spinner$1 = Object.values(IconsModule).find((mod) => mod?.toString && /Spinner\)}\),.\.createElement\(\"path\",{d:\"M18 /.test(mod.toString()));

    const quickAccessMenuClasses = findModule((mod) => typeof mod === 'object' && mod?.Title?.includes('quickaccessmenu'));
    findModule((mod) => typeof mod === 'object' && mod?.ScrollPanel?.includes('scrollpanel'));
    findModule((mod) => typeof mod === 'object' && mod?.GamepadDialogContent?.includes('gamepaddialog'));
    findModule((mod) => typeof mod === 'object' && mod?.PanelSection?.includes('quickaccesscontrols'));
    findModule((mod) => typeof mod === 'object' && mod?.OOBEUpdateStatusContainer?.includes('updaterfield'));
    findModule((mod) => typeof mod === 'object' && mod?.Container?.includes('appdetailsplaysection'));
    findModule((mod) => typeof mod === 'object' && mod?.SliderControlPanelGroup?.includes('gamepadslider'));
    const appDetailsHeaderClasses = findModule((mod) => typeof mod === 'object' && mod?.TopCapsule?.includes('sharedappdetailsheader'));
    findModule((mod) => typeof mod === 'object' && mod?.HeaderLoaded?.includes('appdetails_'));

    const SteamSpinner = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (let prop in m) {
            if (m[prop]?.toString()?.includes('Steam Spinner') && m[prop].toString().includes('PreloadThrobber'))
                return m[prop];
        }
    });

    let tabsComponent;
    const getTabs = async () => {
        if (tabsComponent)
            return tabsComponent;
        // @ts-ignore
        while (!window?.DeckyPluginLoader?.routerHook?.routes) {
            console.debug('[DFL:Tabs]: Waiting for Decky router...');
            await sleep(500);
        }
        return (tabsComponent = fakeRenderComponent(() => {
            return findInReactTree(findInReactTree(
            // @ts-ignore
            window.DeckyPluginLoader.routerHook.routes
                .find((x) => x.props.path == '/library/app/:appid/achievements')
                .props.children.type(), (x) => x?.props?.scrollTabsTop).type({ appid: 1 }), (x) => x?.props?.tabs).type;
        }, {
            useRef: () => ({ current: { reaction: { track: () => { } } } }),
            useContext: () => ({ match: { params: { appid: 1 } } }),
            useMemo: () => ({ data: {} }),
        }));
    };
    let oldTabs;
    try {
        const oldTabsModule = findModule((m) => {
            if (typeof m !== 'object')
                return false;
            for (let prop in m) {
                if (m[prop]?.Unbleed)
                    return true;
            }
            return false;
        });
        if (oldTabsModule)
            oldTabs = Object.values(oldTabsModule).find((x) => x?.type?.toString()?.includes('((function(){'));
    }
    catch (e) {
        console.error('Error finding oldTabs:', e);
    }
    /**
     * Tabs component as used in the library and media tabs. See {@link TabsProps}
     * Unlike other components in `decky-frontend-lib`, this requires Decky Loader to be running.
     */
    const Tabs = oldTabs ||
        ((props) => {
            const found = tabsComponent;
            const [tc, setTC] = React.useState(found);
            React.useEffect(() => {
                if (found)
                    return;
                (async () => {
                    console.debug('[DFL:Tabs]: Finding component...');
                    const t = await getTabs();
                    console.debug('[DFL:Tabs]: Found!');
                    setTC(t);
                })();
            }, []);
            console.log('tc', tc);
            return tc ? React.createElement(tc, props) : window.SP_REACT.createElement(SteamSpinner, null);
        });

    const TextField = Object.values(CommonUIModule).find((mod) => mod?.validateUrl && mod?.validateEmail);

    const ToggleField = Object.values(CommonUIModule).find((mod) => mod?.render?.toString()?.includes('ToggleField,fallback'));

    /**
     * A component for creating reorderable lists.
     *
     * See an example implementation {@linkplain https://github.com/Tormak9970/Component-Testing-Plugin/blob/main/src/testing-window/ReorderableListTest.tsx here}.
     */
    function ReorderableList(props) {
        if (props.animate === undefined)
            props.animate = true;
        const [entryList, setEntryList] = React.useState(props.entries.sort((a, b) => a.position - b.position));
        const [reorderEnabled, setReorderEnabled] = React.useState(false);
        React.useEffect(() => {
            setEntryList(props.entries.sort((a, b) => a.position - b.position));
        }, [props.entries]);
        function toggleReorderEnabled() {
            let newReorderValue = !reorderEnabled;
            setReorderEnabled(newReorderValue);
            if (!newReorderValue) {
                props.onSave(entryList);
            }
        }
        return (window.SP_REACT.createElement(React.Fragment, null,
            window.SP_REACT.createElement("div", { style: {
                    width: 'inherit',
                    height: 'inherit',
                    flex: '1 1 1px',
                    scrollPadding: '48px 0px',
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'flex-start',
                    alignContent: 'stretch',
                } },
                window.SP_REACT.createElement(Focusable, { onSecondaryButton: toggleReorderEnabled, onSecondaryActionDescription: reorderEnabled ? 'Save Order' : 'Reorder', onClick: toggleReorderEnabled }, entryList.map((entry) => (window.SP_REACT.createElement(ReorderableItem, { animate: props.animate, listData: entryList, entryData: entry, reorderEntryFunc: setEntryList, reorderEnabled: reorderEnabled, fieldProps: props.fieldProps }, props.interactables ? window.SP_REACT.createElement(props.interactables, { entry: entry }) : null)))))));
    }
    function ReorderableItem(props) {
        const [isSelected, _setIsSelected] = React.useState(false);
        const [isSelectedLastFrame, setIsSelectedLastFrame] = React.useState(false);
        const listEntries = props.listData;
        function onReorder(e) {
            if (!props.reorderEnabled)
                return;
            const event = e;
            const currentIdx = listEntries.findIndex((entryData) => entryData === props.entryData);
            const currentIdxValue = listEntries[currentIdx];
            if (currentIdx < 0)
                return;
            let targetPosition = -1;
            if (event.detail.button == GamepadButton.DIR_DOWN) {
                targetPosition = currentIdxValue.position + 1;
            }
            else if (event.detail.button == GamepadButton.DIR_UP) {
                targetPosition = currentIdxValue.position - 1;
            }
            if (targetPosition >= listEntries.length || targetPosition < 0)
                return;
            let otherToUpdate = listEntries.find((entryData) => entryData.position === targetPosition);
            if (!otherToUpdate)
                return;
            let currentPosition = currentIdxValue.position;
            currentIdxValue.position = otherToUpdate.position;
            otherToUpdate.position = currentPosition;
            props.reorderEntryFunc([...listEntries].sort((a, b) => a.position - b.position));
        }
        async function setIsSelected(val) {
            _setIsSelected(val);
            // Wait 3 frames, then set. I have no idea why, but if you dont wait long enough it doesn't work.
            for (let i = 0; i < 3; i++)
                await new Promise((res) => requestAnimationFrame(res));
            setIsSelectedLastFrame(val);
        }
        return (window.SP_REACT.createElement("div", { style: props.animate
                ? {
                    transition: isSelected || isSelectedLastFrame
                        ? ''
                        : 'transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s cubic-bezier(0.25, 1, 0.5, 1)',
                    transform: !props.reorderEnabled || isSelected ? 'scale(1)' : 'scale(0.9)',
                    opacity: !props.reorderEnabled || isSelected ? 1 : 0.7,
                }
                : {} },
            window.SP_REACT.createElement(Field, { label: props.entryData.label, ...props.fieldProps, focusable: !props.children, onButtonDown: onReorder, onGamepadBlur: () => setIsSelected(false), onGamepadFocus: () => setIsSelected(true) },
                window.SP_REACT.createElement(Focusable, { style: { display: 'flex', width: '100%', position: 'relative' } }, props.children))));
    }

    /**
     * Get the current params from ReactRouter
     *
     * @returns an object with the current ReactRouter params
     *
     * @example
     * import { useParams } from "decky-frontend-lib";
     *
     * const { appid } = useParams<{ appid: string }>()
     */
    const useParams = Object.values(ReactRouter).find((val) => /return (\w)\?\1\.params:{}/.test(`${val}`));

    // TypeScript helper function
    const definePlugin = (fn) => {
        return (...args) => {
            // TODO: Maybe wrap this
            return fn(...args);
        };
    };

    var DefaultContext = {
      color: undefined,
      size: undefined,
      className: undefined,
      style: undefined,
      attr: undefined
    };
    var IconContext = React__default["default"].createContext && React__default["default"].createContext(DefaultContext);

    var __assign = window && window.__assign || function () {
      __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __rest = window && window.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    function Tree2Element(tree) {
      return tree && tree.map(function (node, i) {
        return React__default["default"].createElement(node.tag, __assign({
          key: i
        }, node.attr), Tree2Element(node.child));
      });
    }
    function GenIcon(data) {
      // eslint-disable-next-line react/display-name
      return function (props) {
        return React__default["default"].createElement(IconBase, __assign({
          attr: __assign({}, data.attr)
        }, props), Tree2Element(data.child));
      };
    }
    function IconBase(props) {
      var elem = function (conf) {
        var attr = props.attr,
          size = props.size,
          title = props.title,
          svgProps = __rest(props, ["attr", "size", "title"]);
        var computedSize = size || conf.size || "1em";
        var className;
        if (conf.className) className = conf.className;
        if (props.className) className = (className ? className + " " : "") + props.className;
        return React__default["default"].createElement("svg", __assign({
          stroke: "currentColor",
          fill: "currentColor",
          strokeWidth: "0"
        }, conf.attr, attr, svgProps, {
          className: className,
          style: __assign(__assign({
            color: props.color || conf.color
          }, conf.style), props.style),
          height: computedSize,
          width: computedSize,
          xmlns: "http://www.w3.org/2000/svg"
        }), title && React__default["default"].createElement("title", null, title), props.children);
      };
      return IconContext !== undefined ? React__default["default"].createElement(IconContext.Consumer, null, function (conf) {
        return elem(conf);
      }) : elem(DefaultContext);
    }

    // THIS FILE IS AUTO GENERATED
    function SiBattledotnet (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M20.001 3.106c0-.059 0-.187.063-.187.09 0 .167.19.196.27.486 1.548.35 3.449-.345 5.588 2.756 1.473 4.338 3.382 4.052 5.168-.38 2.347-3.824 3.727-8.462 3.565a27.12 27.12 0 001.55-1.825c1.786-.347 3.066-1.053 3.4-2.184.246-.823-.32-1.736-1.396-2.594-1.768 3.723-4.722 7.058-7.451 8.985 1.323 1.687 2.556 2.858 3.964 3.516.052.025.164.09.126.148-.044.078-.252.05-.33.034-1.585-.352-3.158-1.42-4.673-3.093-2.652 1.65-5.099 2.066-6.502.925-1.842-1.5-1.316-5.178 1.137-9.106.193.631.505 1.526.806 2.253-.594 1.721-.622 3.183.19 4.041.59.623 1.664.59 2.945.088-2.325-3.395-3.738-7.62-4.04-10.954-2.124.303-3.754.785-5.027 1.675-.048.033-.16.098-.195.04-.044-.078.082-.24.137-.304 1.098-1.196 2.812-2.028 5.012-2.496-.102-3.124.758-5.45 2.45-6.093 2.22-.846 5.14 1.448 7.316 5.542a26.617 26.617 0 00-2.354-.429c-1.193-1.372-2.446-2.13-3.594-1.854-.834.2-1.341 1.146-1.547 2.502 4.108-.332 8.473.56 11.51 1.964.8-1.984 1.197-3.637 1.062-5.185zm-9.598 15.057c3.252-1.859 5.889-4.696 7.638-7.965-3.24-1.88-7.013-2.75-10.716-2.627-.008 3.745 1.124 7.451 3.082 10.594Z"}}]})(props);
    }function SiCrowdin (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M16.119 17.793a2.619 2.619 0 0 1-1.667-.562c-.546-.436-1.004-1.09-1.018-1.858-.008-.388.414-.388.414-.388l1.018-.008c.332.008.43.47.445.586.128 1.04.717 1.495 1.168 1.702.273.123.204.513-.362.528zm-5.695-5.287L8.5 12.252c-.867-.214-.844-.982-.807-1.247a5.119 5.119 0 0 1 .814-2.125c.545-.804 1.303-1.508 2.29-2.073 1.856-1.074 4.45-1.673 7.31-1.673 2.09 0 4.256.27 4.29.27.197.025.328.213.333.437a.377.377 0 0 1-.355.393l-.92-.01c-2.902 0-4.968.394-6.506 1.248-1.527.837-2.57 2.117-3.287 4.012-.076.163-.335 1.12-1.24 1.022zm2.533 7.823c-1.44 0-2.797-.622-3.825-1.746-.87-.96-1.397-1.931-1.493-3.164-.06-.813.3-1.094.788-1.044l1.988.218c.45.092.75.34.825.854.397 2.736 2.122 3.814 3.15 4.046.18.042.292.157.283.365a.412.412 0 0 1-.322.398c-.458.074-.936.073-1.394.073zm-4.101 2.418a14.216 14.216 0 0 1-2.307-.214c-1.202-.214-2.208-.582-3.072-1.13C1.41 20.095.163 17.786.014 15.048c-.037-.65-.11-1.89 1.427-1.797.638.033 1.653.343 2.368.548.887.247 1.314.933 1.314 1.608 0 3.858 3.494 6.408 5.02 6.408.654 0 .414.701.127.779-.502.136-1.15.153-1.413.153zM3.525 11.419c-.605-.109-1.194-.358-1.768-.5C-.018 10.479.284 8.688.45 8.196c1.617-4.757 6.746-6.35 10.887-6.773 3.898-.4 7.978-.092 11.778.967.31.083 1.269.327.718.891-.35.358-1.7-.016-2.073-.041-2.23-.167-4.434-.192-6.656.15-2.349.357-4.768 1.099-6.71 2.665-.938.758-1.76 1.723-2.313 2.866-.144.3-.256.6-.354.9-.11.327-.47 1.91-2.215 1.6zm9.94.917c.332-1.488 1.81-3.848 6.385-3.686 1.05.033.57.749.052.731-2.586-.09-3.815 1.578-4.457 3.27-.219.546-.68.626-1.271.53-.415-.074-.866-.123-.71-.846Z"}}]})(props);
    }function SiDiscord (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z"}}]})(props);
    }function SiEpicgames (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M3.537 0C2.165 0 1.66.506 1.66 1.879V18.44a4.262 4.262 0 00.02.433c.031.3.037.59.316.92.027.033.311.245.311.245.153.075.258.13.43.2l8.335 3.491c.433.199.614.276.928.27h.002c.314.006.495-.071.928-.27l8.335-3.492c.172-.07.277-.124.43-.2 0 0 .284-.211.311-.243.28-.33.285-.621.316-.92a4.261 4.261 0 00.02-.434V1.879c0-1.373-.506-1.88-1.878-1.88zm13.366 3.11h.68c1.138 0 1.688.553 1.688 1.696v1.88h-1.374v-1.8c0-.369-.17-.54-.523-.54h-.235c-.367 0-.537.17-.537.539v5.81c0 .369.17.54.537.54h.262c.353 0 .523-.171.523-.54V8.619h1.373v2.143c0 1.144-.562 1.71-1.7 1.71h-.694c-1.138 0-1.7-.566-1.7-1.71V4.82c0-1.144.562-1.709 1.7-1.709zm-12.186.08h3.114v1.274H6.117v2.603h1.648v1.275H6.117v2.774h1.74v1.275h-3.14zm3.816 0h2.198c1.138 0 1.7.564 1.7 1.708v2.445c0 1.144-.562 1.71-1.7 1.71h-.799v3.338h-1.4zm4.53 0h1.4v9.201h-1.4zm-3.13 1.235v3.392h.575c.354 0 .523-.171.523-.54V4.965c0-.368-.17-.54-.523-.54zm-3.74 10.147a1.708 1.708 0 01.591.108 1.745 1.745 0 01.49.299l-.452.546a1.247 1.247 0 00-.308-.195.91.91 0 00-.363-.068.658.658 0 00-.28.06.703.703 0 00-.224.163.783.783 0 00-.151.243.799.799 0 00-.056.299v.008a.852.852 0 00.056.31.7.7 0 00.157.245.736.736 0 00.238.16.774.774 0 00.303.058.79.79 0 00.445-.116v-.339h-.548v-.565H7.37v1.255a2.019 2.019 0 01-.524.307 1.789 1.789 0 01-.683.123 1.642 1.642 0 01-.602-.107 1.46 1.46 0 01-.478-.3 1.371 1.371 0 01-.318-.455 1.438 1.438 0 01-.115-.58v-.008a1.426 1.426 0 01.113-.57 1.449 1.449 0 01.312-.46 1.418 1.418 0 01.474-.309 1.58 1.58 0 01.598-.111 1.708 1.708 0 01.045 0zm11.963.008a2.006 2.006 0 01.612.094 1.61 1.61 0 01.507.277l-.386.546a1.562 1.562 0 00-.39-.205 1.178 1.178 0 00-.388-.07.347.347 0 00-.208.052.154.154 0 00-.07.127v.008a.158.158 0 00.022.084.198.198 0 00.076.066.831.831 0 00.147.06c.062.02.14.04.236.061a3.389 3.389 0 01.43.122 1.292 1.292 0 01.328.17.678.678 0 01.207.24.739.739 0 01.071.337v.008a.865.865 0 01-.081.382.82.82 0 01-.229.285 1.032 1.032 0 01-.353.18 1.606 1.606 0 01-.46.061 2.16 2.16 0 01-.71-.116 1.718 1.718 0 01-.593-.346l.43-.514c.277.223.578.335.9.335a.457.457 0 00.236-.05.157.157 0 00.082-.142v-.008a.15.15 0 00-.02-.077.204.204 0 00-.073-.066.753.753 0 00-.143-.062 2.45 2.45 0 00-.233-.062 5.036 5.036 0 01-.413-.113 1.26 1.26 0 01-.331-.16.72.72 0 01-.222-.243.73.73 0 01-.082-.36v-.008a.863.863 0 01.074-.359.794.794 0 01.214-.283 1.007 1.007 0 01.34-.185 1.423 1.423 0 01.448-.066 2.006 2.006 0 01.025 0zm-9.358.025h.742l1.183 2.81h-.825l-.203-.499H8.623l-.198.498h-.81zm2.197.02h.814l.663 1.08.663-1.08h.814v2.79h-.766v-1.602l-.711 1.091h-.016l-.707-1.083v1.593h-.754zm3.469 0h2.235v.658h-1.473v.422h1.334v.61h-1.334v.442h1.493v.658h-2.255zm-5.3.897l-.315.793h.624zm-1.145 5.19h8.014l-4.09 1.348z"}}]})(props);
    }function SiGithub (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"}}]})(props);
    }function SiMastodon (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792 0 11.813 0h-.03c-3.98 0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057 0 0 0 .023-.043v-1.809a.052.052 0 0 0-.02-.041.053.053 0 0 0-.046-.01 20.282 20.282 0 0 1-4.709.545c-2.73 0-3.463-1.284-3.674-1.818a5.593 5.593 0 0 1-.319-1.433.053.053 0 0 1 .066-.054c1.517.363 3.072.546 4.632.546.376 0 .75 0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23 0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112 0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311 0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13 0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"}}]})(props);
    }function SiOrigin (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M12.588 3.11a8.78 8.78 0 013.417.919 8.775 8.775 0 012.706 2.094 9.113 9.113 0 011.715 2.963 8.65 8.65 0 01.465 3.502 8.224 8.224 0 01-.307 1.848 9.174 9.174 0 01-.674 1.703 19.96 19.96 0 01-1.47 2.412 17.61 17.61 0 01-1.762 2.118 18.61 18.61 0 01-4.286 3.281l-.037.026a.196.196 0 01-.109.023.293.293 0 01-.159-.097.266.266 0 01-.062-.173c0-.029.004-.059.012-.085a.186.186 0 01.037-.062c.277-.393.506-.806.686-1.235a5.42 5.42 0 00.368-1.359.118.118 0 00-.038-.085.11.11 0 00-.085-.038 9.155 9.155 0 01-.795.062 4.926 4.926 0 01-.796-.037 8.818 8.818 0 01-6.123-3.013 9.089 9.089 0 01-1.715-2.963 8.662 8.662 0 01-.465-3.502 8.224 8.224 0 01.306-1.848 8.598 8.598 0 01.675-1.68c.439-.864.93-1.676 1.469-2.436a18.035 18.035 0 011.76-2.119A18.801 18.801 0 0111.609.05l.038-.025a.187.187 0 01.11-.025.295.295 0 01.157.098.255.255 0 01.062.174.244.244 0 01-.012.084.164.164 0 01-.036.061 6.447 6.447 0 00-.687 1.237c-.18.433-.3.885-.366 1.358 0 .033.012.063.036.086a.117.117 0 00.085.037c.262-.033.527-.053.795-.06.272-.01.536.002.798.034zm-.807 12.367a3.32 3.32 0 002.521-.855c.72-.64 1.11-1.438 1.176-2.4a3.357 3.357 0 00-.856-2.535 3.294 3.294 0 00-2.4-1.162 3.36 3.36 0 00-2.534.855 3.3 3.3 0 00-1.164 2.4 3.381 3.381 0 00.846 2.535c.628.725 1.432 1.115 2.411 1.162z"}}]})(props);
    }function SiPatreon (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M0 .48v23.04h4.22V.48zm15.385 0c-4.764 0-8.641 3.88-8.641 8.65 0 4.755 3.877 8.623 8.641 8.623 4.75 0 8.615-3.868 8.615-8.623C24 4.36 20.136.48 15.385.48z"}}]})(props);
    }function SiSteam (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M11.979 0C5.678 0 .511 4.86.022 11.037l6.432 2.658c.545-.371 1.203-.59 1.912-.59.063 0 .125.004.188.006l2.861-4.142V8.91c0-2.495 2.028-4.524 4.524-4.524 2.494 0 4.524 2.031 4.524 4.527s-2.03 4.525-4.524 4.525h-.105l-4.076 2.911c0 .052.004.105.004.159 0 1.875-1.515 3.396-3.39 3.396-1.635 0-3.016-1.173-3.331-2.727L.436 15.27C1.862 20.307 6.486 24 11.979 24c6.627 0 11.999-5.373 11.999-12S18.605 0 11.979 0zM7.54 18.21l-1.473-.61c.262.543.714.999 1.314 1.25 1.297.539 2.793-.076 3.332-1.375.263-.63.264-1.319.005-1.949s-.75-1.121-1.377-1.383c-.624-.26-1.29-.249-1.878-.03l1.523.63c.956.4 1.409 1.5 1.009 2.455-.397.957-1.497 1.41-2.454 1.012H7.54zm11.415-9.303c0-1.662-1.353-3.015-3.015-3.015-1.665 0-3.015 1.353-3.015 3.015 0 1.665 1.35 3.015 3.015 3.015 1.663 0 3.015-1.35 3.015-3.015zm-5.273-.005c0-1.252 1.013-2.266 2.265-2.266 1.249 0 2.266 1.014 2.266 2.266 0 1.251-1.017 2.265-2.266 2.265-1.253 0-2.265-1.014-2.265-2.265z"}}]})(props);
    }function SiTwitter (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"}}]})(props);
    }function SiUbisoft (props) {
      return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"title","attr":{},"child":[]},{"tag":"path","attr":{"d":"M23.561 11.988C23.301-.304 6.954-4.89.656 6.634c.282.206.661.477.943.672a11.747 11.747 0 00-.976 3.067 11.885 11.885 0 00-.184 2.071C.439 18.818 5.621 24 12.005 24c6.385 0 11.556-5.17 11.556-11.556v-.455zm-20.27 2.06c-.152 1.246-.054 1.636-.054 1.788l-.282.098c-.108-.206-.37-.932-.488-1.908C2.163 10.308 4.7 6.96 8.57 6.33c3.544-.52 6.937 1.68 7.728 4.758l-.282.098c-.087-.087-.228-.336-.77-.878-4.281-4.281-11.002-2.32-11.956 3.74zm11.002 2.081a3.145 3.145 0 01-2.59 1.355 3.15 3.15 0 01-3.155-3.155 3.159 3.159 0 012.927-3.144c1.018-.043 1.972.51 2.416 1.398a2.58 2.58 0 01-.455 2.95c.293.205.575.4.856.595zm6.58.12c-1.669 3.782-5.106 5.766-8.77 5.712-7.034-.347-9.083-8.466-4.38-11.393l.207.206c-.076.108-.358.325-.791 1.182-.51 1.041-.672 2.081-.607 2.732.369 5.67 8.314 6.83 11.045 1.214C21.057 8.217 11.822.401 3.626 6.374l-.184-.184C5.599 2.808 9.816 1.3 13.837 2.309c6.147 1.55 9.453 7.956 7.035 13.94z"}}]})(props);
    }

    const BoopIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", fillRule: "evenodd", strokeLinejoin: "round", strokeMiterlimit: "2", clipRule: "evenodd", viewBox: "0 0 350 350", width: "1em", height: "1em", ...props },
        window.SP_REACT.createElement("path", { d: "M350 169v6A175 175 0 1 1 179 0a163 163 0 1 0 171 169Z" }),
        window.SP_REACT.createElement("path", { d: "M198 0h133c11 0 19 8 19 19v133A152 152 0 1 1 198 0Z" })));

    // THIS FILE IS AUTO GENERATED
    function HiEyeSlash (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M3.53 2.47a.75.75 0 00-1.06 1.06l18 18a.75.75 0 101.06-1.06l-18-18zM22.676 12.553a11.249 11.249 0 01-2.631 4.31l-3.099-3.099a5.25 5.25 0 00-6.71-6.71L7.759 4.577a11.217 11.217 0 014.242-.827c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113z"}},{"tag":"path","attr":{"d":"M15.75 12c0 .18-.013.357-.037.53l-4.244-4.243A3.75 3.75 0 0115.75 12zM12.53 15.713l-4.243-4.244a3.75 3.75 0 004.243 4.243z"}},{"tag":"path","attr":{"d":"M6.75 12c0-.619.107-1.213.304-1.764l-3.1-3.1a11.25 11.25 0 00-2.63 4.31c-.12.362-.12.752 0 1.114 1.489 4.467 5.704 7.69 10.675 7.69 1.5 0 2.933-.294 4.242-.827l-2.477-2.477A5.25 5.25 0 016.75 12z"}}]})(props);
    }function HiEye (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M12 15a3 3 0 100-6 3 3 0 000 6z"}},{"tag":"path","attr":{"fillRule":"evenodd","d":"M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.762 1.762 0 010-1.113zM17.25 12a5.25 5.25 0 11-10.5 0 5.25 5.25 0 0110.5 0z","clipRule":"evenodd"}}]})(props);
    }function HiFolder (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M19.5 21a3 3 0 003-3v-4.5a3 3 0 00-3-3h-15a3 3 0 00-3 3V18a3 3 0 003 3h15zM1.5 10.146V6a3 3 0 013-3h5.379a2.25 2.25 0 011.59.659l2.122 2.121c.14.141.331.22.53.22H19.5a3 3 0 013 3v1.146A4.483 4.483 0 0019.5 9h-15a4.483 4.483 0 00-3 1.146z"}}]})(props);
    }function HiHome (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M11.47 3.84a.75.75 0 011.06 0l8.69 8.69a.75.75 0 101.06-1.06l-8.689-8.69a2.25 2.25 0 00-3.182 0l-8.69 8.69a.75.75 0 001.061 1.06l8.69-8.69z"}},{"tag":"path","attr":{"d":"M12 5.432l8.159 8.159c.03.03.06.058.091.086v6.198c0 1.035-.84 1.875-1.875 1.875H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H5.625a1.875 1.875 0 01-1.875-1.875v-6.198a2.29 2.29 0 00.091-.086L12 5.43z"}}]})(props);
    }function HiQrCode (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M3 4.875C3 3.839 3.84 3 4.875 3h4.5c1.036 0 1.875.84 1.875 1.875v4.5c0 1.036-.84 1.875-1.875 1.875h-4.5A1.875 1.875 0 013 9.375v-4.5zM4.875 4.5a.375.375 0 00-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 00.375-.375v-4.5a.375.375 0 00-.375-.375h-4.5zm7.875.375c0-1.036.84-1.875 1.875-1.875h4.5C20.16 3 21 3.84 21 4.875v4.5c0 1.036-.84 1.875-1.875 1.875h-4.5a1.875 1.875 0 01-1.875-1.875v-4.5zm1.875-.375a.375.375 0 00-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 00.375-.375v-4.5a.375.375 0 00-.375-.375h-4.5zM6 6.75A.75.75 0 016.75 6h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75A.75.75 0 016 7.5v-.75zm9.75 0A.75.75 0 0116.5 6h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zM3 14.625c0-1.036.84-1.875 1.875-1.875h4.5c1.036 0 1.875.84 1.875 1.875v4.5c0 1.035-.84 1.875-1.875 1.875h-4.5A1.875 1.875 0 013 19.125v-4.5zm1.875-.375a.375.375 0 00-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 00.375-.375v-4.5a.375.375 0 00-.375-.375h-4.5zm7.875-.75a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zm6 0a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zM6 16.5a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zm9.75 0a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zm-3 3a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75zm6 0a.75.75 0 01.75-.75h.75a.75.75 0 01.75.75v.75a.75.75 0 01-.75.75h-.75a.75.75 0 01-.75-.75v-.75z","clipRule":"evenodd"}}]})(props);
    }function HiTrash (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z","clipRule":"evenodd"}}]})(props);
    }function HiXMark (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M5.47 5.47a.75.75 0 011.06 0L12 10.94l5.47-5.47a.75.75 0 111.06 1.06L13.06 12l5.47 5.47a.75.75 0 11-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 01-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 010-1.06z","clipRule":"evenodd"}}]})(props);
    }function HiOutlineChevronRight (props) {
      return GenIcon({"tag":"svg","attr":{"fill":"none","viewBox":"0 0 24 24","strokeWidth":"1.5","stroke":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"strokeLinecap":"round","strokeLinejoin":"round","d":"M8.25 4.5l7.5 7.5-7.5 7.5"}}]})(props);
    }

    var __defProp = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };

    // src/third-party/qrcodegen/index.ts
    /**
     * @license QR Code generator library (TypeScript)
     * Copyright (c) Project Nayuki.
     * SPDX-License-Identifier: MIT
     */
    var qrcodegen;
    ((qrcodegen2) => {
      const _QrCode = class {
        constructor(version, errorCorrectionLevel, dataCodewords, msk) {
          this.version = version;
          this.errorCorrectionLevel = errorCorrectionLevel;
          this.modules = [];
          this.isFunction = [];
          if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION)
            throw new RangeError("Version value out of range");
          if (msk < -1 || msk > 7)
            throw new RangeError("Mask value out of range");
          this.size = version * 4 + 17;
          let row = [];
          for (let i = 0; i < this.size; i++)
            row.push(false);
          for (let i = 0; i < this.size; i++) {
            this.modules.push(row.slice());
            this.isFunction.push(row.slice());
          }
          this.drawFunctionPatterns();
          const allCodewords = this.addEccAndInterleave(dataCodewords);
          this.drawCodewords(allCodewords);
          if (msk == -1) {
            let minPenalty = 1e9;
            for (let i = 0; i < 8; i++) {
              this.applyMask(i);
              this.drawFormatBits(i);
              const penalty = this.getPenaltyScore();
              if (penalty < minPenalty) {
                msk = i;
                minPenalty = penalty;
              }
              this.applyMask(i);
            }
          }
          assert(0 <= msk && msk <= 7);
          this.mask = msk;
          this.applyMask(msk);
          this.drawFormatBits(msk);
          this.isFunction = [];
        }
        static encodeText(text, ecl) {
          const segs = qrcodegen2.QrSegment.makeSegments(text);
          return _QrCode.encodeSegments(segs, ecl);
        }
        static encodeBinary(data, ecl) {
          const seg = qrcodegen2.QrSegment.makeBytes(data);
          return _QrCode.encodeSegments([seg], ecl);
        }
        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
          if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)
            throw new RangeError("Invalid value");
          let version;
          let dataUsedBits;
          for (version = minVersion; ; version++) {
            const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;
            const usedBits = QrSegment.getTotalBits(segs, version);
            if (usedBits <= dataCapacityBits2) {
              dataUsedBits = usedBits;
              break;
            }
            if (version >= maxVersion)
              throw new RangeError("Data too long");
          }
          for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {
            if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8)
              ecl = newEcl;
          }
          let bb = [];
          for (const seg of segs) {
            appendBits(seg.mode.modeBits, 4, bb);
            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
            for (const b of seg.getData())
              bb.push(b);
          }
          assert(bb.length == dataUsedBits);
          const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;
          assert(bb.length <= dataCapacityBits);
          appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
          appendBits(0, (8 - bb.length % 8) % 8, bb);
          assert(bb.length % 8 == 0);
          for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
            appendBits(padByte, 8, bb);
          let dataCodewords = [];
          while (dataCodewords.length * 8 < bb.length)
            dataCodewords.push(0);
          bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
          return new _QrCode(version, ecl, dataCodewords, mask);
        }
        getModule(x, y) {
          return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
        }
        getModules() {
          return this.modules;
        }
        drawFunctionPatterns() {
          for (let i = 0; i < this.size; i++) {
            this.setFunctionModule(6, i, i % 2 == 0);
            this.setFunctionModule(i, 6, i % 2 == 0);
          }
          this.drawFinderPattern(3, 3);
          this.drawFinderPattern(this.size - 4, 3);
          this.drawFinderPattern(3, this.size - 4);
          const alignPatPos = this.getAlignmentPatternPositions();
          const numAlign = alignPatPos.length;
          for (let i = 0; i < numAlign; i++) {
            for (let j = 0; j < numAlign; j++) {
              if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
                this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
            }
          }
          this.drawFormatBits(0);
          this.drawVersion();
        }
        drawFormatBits(mask) {
          const data = this.errorCorrectionLevel.formatBits << 3 | mask;
          let rem = data;
          for (let i = 0; i < 10; i++)
            rem = rem << 1 ^ (rem >>> 9) * 1335;
          const bits = (data << 10 | rem) ^ 21522;
          assert(bits >>> 15 == 0);
          for (let i = 0; i <= 5; i++)
            this.setFunctionModule(8, i, getBit(bits, i));
          this.setFunctionModule(8, 7, getBit(bits, 6));
          this.setFunctionModule(8, 8, getBit(bits, 7));
          this.setFunctionModule(7, 8, getBit(bits, 8));
          for (let i = 9; i < 15; i++)
            this.setFunctionModule(14 - i, 8, getBit(bits, i));
          for (let i = 0; i < 8; i++)
            this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
          for (let i = 8; i < 15; i++)
            this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
          this.setFunctionModule(8, this.size - 8, true);
        }
        drawVersion() {
          if (this.version < 7)
            return;
          let rem = this.version;
          for (let i = 0; i < 12; i++)
            rem = rem << 1 ^ (rem >>> 11) * 7973;
          const bits = this.version << 12 | rem;
          assert(bits >>> 18 == 0);
          for (let i = 0; i < 18; i++) {
            const color = getBit(bits, i);
            const a = this.size - 11 + i % 3;
            const b = Math.floor(i / 3);
            this.setFunctionModule(a, b, color);
            this.setFunctionModule(b, a, color);
          }
        }
        drawFinderPattern(x, y) {
          for (let dy = -4; dy <= 4; dy++) {
            for (let dx = -4; dx <= 4; dx++) {
              const dist = Math.max(Math.abs(dx), Math.abs(dy));
              const xx = x + dx;
              const yy = y + dy;
              if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
                this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
            }
          }
        }
        drawAlignmentPattern(x, y) {
          for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++)
              this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
          }
        }
        setFunctionModule(x, y, isDark) {
          this.modules[y][x] = isDark;
          this.isFunction[y][x] = true;
        }
        addEccAndInterleave(data) {
          const ver = this.version;
          const ecl = this.errorCorrectionLevel;
          if (data.length != _QrCode.getNumDataCodewords(ver, ecl))
            throw new RangeError("Invalid argument");
          const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
          const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
          const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
          const numShortBlocks = numBlocks - rawCodewords % numBlocks;
          const shortBlockLen = Math.floor(rawCodewords / numBlocks);
          let blocks = [];
          const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
          for (let i = 0, k = 0; i < numBlocks; i++) {
            let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
            k += dat.length;
            const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
            if (i < numShortBlocks)
              dat.push(0);
            blocks.push(dat.concat(ecc));
          }
          let result = [];
          for (let i = 0; i < blocks[0].length; i++) {
            blocks.forEach((block, j) => {
              if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
                result.push(block[i]);
            });
          }
          assert(result.length == rawCodewords);
          return result;
        }
        drawCodewords(data) {
          if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))
            throw new RangeError("Invalid argument");
          let i = 0;
          for (let right = this.size - 1; right >= 1; right -= 2) {
            if (right == 6)
              right = 5;
            for (let vert = 0; vert < this.size; vert++) {
              for (let j = 0; j < 2; j++) {
                const x = right - j;
                const upward = (right + 1 & 2) == 0;
                const y = upward ? this.size - 1 - vert : vert;
                if (!this.isFunction[y][x] && i < data.length * 8) {
                  this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                  i++;
                }
              }
            }
          }
          assert(i == data.length * 8);
        }
        applyMask(mask) {
          if (mask < 0 || mask > 7)
            throw new RangeError("Mask value out of range");
          for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
              let invert;
              switch (mask) {
                case 0:
                  invert = (x + y) % 2 == 0;
                  break;
                case 1:
                  invert = y % 2 == 0;
                  break;
                case 2:
                  invert = x % 3 == 0;
                  break;
                case 3:
                  invert = (x + y) % 3 == 0;
                  break;
                case 4:
                  invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                  break;
                case 5:
                  invert = x * y % 2 + x * y % 3 == 0;
                  break;
                case 6:
                  invert = (x * y % 2 + x * y % 3) % 2 == 0;
                  break;
                case 7:
                  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
                  break;
                default:
                  throw new Error("Unreachable");
              }
              if (!this.isFunction[y][x] && invert)
                this.modules[y][x] = !this.modules[y][x];
            }
          }
        }
        getPenaltyScore() {
          let result = 0;
          for (let y = 0; y < this.size; y++) {
            let runColor = false;
            let runX = 0;
            let runHistory = [0, 0, 0, 0, 0, 0, 0];
            for (let x = 0; x < this.size; x++) {
              if (this.modules[y][x] == runColor) {
                runX++;
                if (runX == 5)
                  result += _QrCode.PENALTY_N1;
                else if (runX > 5)
                  result++;
              } else {
                this.finderPenaltyAddHistory(runX, runHistory);
                if (!runColor)
                  result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                runColor = this.modules[y][x];
                runX = 1;
              }
            }
            result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
          }
          for (let x = 0; x < this.size; x++) {
            let runColor = false;
            let runY = 0;
            let runHistory = [0, 0, 0, 0, 0, 0, 0];
            for (let y = 0; y < this.size; y++) {
              if (this.modules[y][x] == runColor) {
                runY++;
                if (runY == 5)
                  result += _QrCode.PENALTY_N1;
                else if (runY > 5)
                  result++;
              } else {
                this.finderPenaltyAddHistory(runY, runHistory);
                if (!runColor)
                  result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                runColor = this.modules[y][x];
                runY = 1;
              }
            }
            result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
          }
          for (let y = 0; y < this.size - 1; y++) {
            for (let x = 0; x < this.size - 1; x++) {
              const color = this.modules[y][x];
              if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
                result += _QrCode.PENALTY_N2;
            }
          }
          let dark = 0;
          for (const row of this.modules)
            dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
          const total = this.size * this.size;
          const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
          assert(0 <= k && k <= 9);
          result += k * _QrCode.PENALTY_N4;
          assert(0 <= result && result <= 2568888);
          return result;
        }
        getAlignmentPatternPositions() {
          if (this.version == 1)
            return [];
          else {
            const numAlign = Math.floor(this.version / 7) + 2;
            const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
            let result = [6];
            for (let pos = this.size - 7; result.length < numAlign; pos -= step)
              result.splice(1, 0, pos);
            return result;
          }
        }
        static getNumRawDataModules(ver) {
          if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION)
            throw new RangeError("Version number out of range");
          let result = (16 * ver + 128) * ver + 64;
          if (ver >= 2) {
            const numAlign = Math.floor(ver / 7) + 2;
            result -= (25 * numAlign - 10) * numAlign - 55;
            if (ver >= 7)
              result -= 36;
          }
          assert(208 <= result && result <= 29648);
          return result;
        }
        static getNumDataCodewords(ver, ecl) {
          return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        }
        static reedSolomonComputeDivisor(degree) {
          if (degree < 1 || degree > 255)
            throw new RangeError("Degree out of range");
          let result = [];
          for (let i = 0; i < degree - 1; i++)
            result.push(0);
          result.push(1);
          let root = 1;
          for (let i = 0; i < degree; i++) {
            for (let j = 0; j < result.length; j++) {
              result[j] = _QrCode.reedSolomonMultiply(result[j], root);
              if (j + 1 < result.length)
                result[j] ^= result[j + 1];
            }
            root = _QrCode.reedSolomonMultiply(root, 2);
          }
          return result;
        }
        static reedSolomonComputeRemainder(data, divisor) {
          let result = divisor.map((_) => 0);
          for (const b of data) {
            const factor = b ^ result.shift();
            result.push(0);
            divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
          }
          return result;
        }
        static reedSolomonMultiply(x, y) {
          if (x >>> 8 != 0 || y >>> 8 != 0)
            throw new RangeError("Byte out of range");
          let z = 0;
          for (let i = 7; i >= 0; i--) {
            z = z << 1 ^ (z >>> 7) * 285;
            z ^= (y >>> i & 1) * x;
          }
          assert(z >>> 8 == 0);
          return z;
        }
        finderPenaltyCountPatterns(runHistory) {
          const n = runHistory[1];
          assert(n <= this.size * 3);
          const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
          return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
        }
        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
          if (currentRunColor) {
            this.finderPenaltyAddHistory(currentRunLength, runHistory);
            currentRunLength = 0;
          }
          currentRunLength += this.size;
          this.finderPenaltyAddHistory(currentRunLength, runHistory);
          return this.finderPenaltyCountPatterns(runHistory);
        }
        finderPenaltyAddHistory(currentRunLength, runHistory) {
          if (runHistory[0] == 0)
            currentRunLength += this.size;
          runHistory.pop();
          runHistory.unshift(currentRunLength);
        }
      };
      let QrCode = _QrCode;
      QrCode.MIN_VERSION = 1;
      QrCode.MAX_VERSION = 40;
      QrCode.PENALTY_N1 = 3;
      QrCode.PENALTY_N2 = 3;
      QrCode.PENALTY_N3 = 40;
      QrCode.PENALTY_N4 = 10;
      QrCode.ECC_CODEWORDS_PER_BLOCK = [
        [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
        [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
      ];
      QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
        [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
        [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
        [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
        [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
      ];
      qrcodegen2.QrCode = QrCode;
      function appendBits(val, len, bb) {
        if (len < 0 || len > 31 || val >>> len != 0)
          throw new RangeError("Value out of range");
        for (let i = len - 1; i >= 0; i--)
          bb.push(val >>> i & 1);
      }
      function getBit(x, i) {
        return (x >>> i & 1) != 0;
      }
      function assert(cond) {
        if (!cond)
          throw new Error("Assertion error");
      }
      const _QrSegment = class {
        constructor(mode, numChars, bitData) {
          this.mode = mode;
          this.numChars = numChars;
          this.bitData = bitData;
          if (numChars < 0)
            throw new RangeError("Invalid argument");
          this.bitData = bitData.slice();
        }
        static makeBytes(data) {
          let bb = [];
          for (const b of data)
            appendBits(b, 8, bb);
          return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);
        }
        static makeNumeric(digits) {
          if (!_QrSegment.isNumeric(digits))
            throw new RangeError("String contains non-numeric characters");
          let bb = [];
          for (let i = 0; i < digits.length; ) {
            const n = Math.min(digits.length - i, 3);
            appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
            i += n;
          }
          return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);
        }
        static makeAlphanumeric(text) {
          if (!_QrSegment.isAlphanumeric(text))
            throw new RangeError("String contains unencodable characters in alphanumeric mode");
          let bb = [];
          let i;
          for (i = 0; i + 2 <= text.length; i += 2) {
            let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
            temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
            appendBits(temp, 11, bb);
          }
          if (i < text.length)
            appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
          return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);
        }
        static makeSegments(text) {
          if (text == "")
            return [];
          else if (_QrSegment.isNumeric(text))
            return [_QrSegment.makeNumeric(text)];
          else if (_QrSegment.isAlphanumeric(text))
            return [_QrSegment.makeAlphanumeric(text)];
          else
            return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];
        }
        static makeEci(assignVal) {
          let bb = [];
          if (assignVal < 0)
            throw new RangeError("ECI assignment value out of range");
          else if (assignVal < 1 << 7)
            appendBits(assignVal, 8, bb);
          else if (assignVal < 1 << 14) {
            appendBits(2, 2, bb);
            appendBits(assignVal, 14, bb);
          } else if (assignVal < 1e6) {
            appendBits(6, 3, bb);
            appendBits(assignVal, 21, bb);
          } else
            throw new RangeError("ECI assignment value out of range");
          return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);
        }
        static isNumeric(text) {
          return _QrSegment.NUMERIC_REGEX.test(text);
        }
        static isAlphanumeric(text) {
          return _QrSegment.ALPHANUMERIC_REGEX.test(text);
        }
        getData() {
          return this.bitData.slice();
        }
        static getTotalBits(segs, version) {
          let result = 0;
          for (const seg of segs) {
            const ccbits = seg.mode.numCharCountBits(version);
            if (seg.numChars >= 1 << ccbits)
              return Infinity;
            result += 4 + ccbits + seg.bitData.length;
          }
          return result;
        }
        static toUtf8ByteArray(str) {
          str = encodeURI(str);
          let result = [];
          for (let i = 0; i < str.length; i++) {
            if (str.charAt(i) != "%")
              result.push(str.charCodeAt(i));
            else {
              result.push(parseInt(str.substr(i + 1, 2), 16));
              i += 2;
            }
          }
          return result;
        }
      };
      let QrSegment = _QrSegment;
      QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
      QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
      QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      qrcodegen2.QrSegment = QrSegment;
    })(qrcodegen || (qrcodegen = {}));
    ((qrcodegen2) => {
      ((QrCode2) => {
        const _Ecc = class {
          constructor(ordinal, formatBits) {
            this.ordinal = ordinal;
            this.formatBits = formatBits;
          }
        };
        let Ecc = _Ecc;
        Ecc.LOW = new _Ecc(0, 1);
        Ecc.MEDIUM = new _Ecc(1, 0);
        Ecc.QUARTILE = new _Ecc(2, 3);
        Ecc.HIGH = new _Ecc(3, 2);
        QrCode2.Ecc = Ecc;
      })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
    })(qrcodegen || (qrcodegen = {}));
    ((qrcodegen2) => {
      ((QrSegment2) => {
        const _Mode = class {
          constructor(modeBits, numBitsCharCount) {
            this.modeBits = modeBits;
            this.numBitsCharCount = numBitsCharCount;
          }
          numCharCountBits(ver) {
            return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
          }
        };
        let Mode = _Mode;
        Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
        Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
        Mode.BYTE = new _Mode(4, [8, 16, 16]);
        Mode.KANJI = new _Mode(8, [8, 10, 12]);
        Mode.ECI = new _Mode(7, [0, 0, 0]);
        QrSegment2.Mode = Mode;
      })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
    })(qrcodegen || (qrcodegen = {}));
    var qrcodegen_default = qrcodegen;

    // src/index.tsx
    /**
     * @license qrcode.react
     * Copyright (c) Paul O'Shannessy
     * SPDX-License-Identifier: ISC
     */
    var ERROR_LEVEL_MAP = {
      L: qrcodegen_default.QrCode.Ecc.LOW,
      M: qrcodegen_default.QrCode.Ecc.MEDIUM,
      Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
      H: qrcodegen_default.QrCode.Ecc.HIGH
    };
    var DEFAULT_SIZE = 128;
    var DEFAULT_LEVEL = "L";
    var DEFAULT_BGCOLOR = "#FFFFFF";
    var DEFAULT_FGCOLOR = "#000000";
    var DEFAULT_INCLUDEMARGIN = false;
    var MARGIN_SIZE = 4;
    var DEFAULT_IMG_SCALE = 0.1;
    function generatePath(modules, margin = 0) {
      const ops = [];
      modules.forEach(function(row, y) {
        let start = null;
        row.forEach(function(cell, x) {
          if (!cell && start !== null) {
            ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
            start = null;
            return;
          }
          if (x === row.length - 1) {
            if (!cell) {
              return;
            }
            if (start === null) {
              ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
            } else {
              ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
            }
            return;
          }
          if (cell && start === null) {
            start = x;
          }
        });
      });
      return ops.join("");
    }
    function excavateModules(modules, excavation) {
      return modules.slice().map((row, y) => {
        if (y < excavation.y || y >= excavation.y + excavation.h) {
          return row;
        }
        return row.map((cell, x) => {
          if (x < excavation.x || x >= excavation.x + excavation.w) {
            return cell;
          }
          return false;
        });
      });
    }
    function getImageSettings(cells, size, includeMargin, imageSettings) {
      if (imageSettings == null) {
        return null;
      }
      const margin = includeMargin ? MARGIN_SIZE : 0;
      const numCells = cells.length + margin * 2;
      const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
      const scale = numCells / size;
      const w = (imageSettings.width || defaultSize) * scale;
      const h = (imageSettings.height || defaultSize) * scale;
      const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
      const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
      let excavation = null;
      if (imageSettings.excavate) {
        let floorX = Math.floor(x);
        let floorY = Math.floor(y);
        let ceilW = Math.ceil(w + x - floorX);
        let ceilH = Math.ceil(h + y - floorY);
        excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
      }
      return { x, y, h, w, excavation };
    }
    (function() {
      try {
        new Path2D().addPath(new Path2D());
      } catch (e) {
        return false;
      }
      return true;
    })();
    function QRCodeSVG(props) {
      const _a = props, {
        value,
        size = DEFAULT_SIZE,
        level = DEFAULT_LEVEL,
        bgColor = DEFAULT_BGCOLOR,
        fgColor = DEFAULT_FGCOLOR,
        includeMargin = DEFAULT_INCLUDEMARGIN,
        imageSettings
      } = _a, otherProps = __objRest(_a, [
        "value",
        "size",
        "level",
        "bgColor",
        "fgColor",
        "includeMargin",
        "imageSettings"
      ]);
      let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      const margin = includeMargin ? MARGIN_SIZE : 0;
      const numCells = cells.length + margin * 2;
      const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
      let image = null;
      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
        image = /* @__PURE__ */ React__default["default"].createElement("image", {
          xlinkHref: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none"
        });
      }
      const fgPath = generatePath(cells, margin);
      return /* @__PURE__ */ React__default["default"].createElement("svg", __spreadValues({
        height: size,
        width: size,
        viewBox: `0 0 ${numCells} ${numCells}`
      }, otherProps), /* @__PURE__ */ React__default["default"].createElement("path", {
        fill: bgColor,
        d: `M0,0 h${numCells}v${numCells}H0z`,
        shapeRendering: "crispEdges"
      }), /* @__PURE__ */ React__default["default"].createElement("path", {
        fill: fgColor,
        d: fgPath,
        shapeRendering: "crispEdges"
      }), image);
    }

    const showQrModal = (url) => {
        showModal(window.SP_REACT.createElement(ModalRoot, null,
            window.SP_REACT.createElement(QRCodeSVG, { style: { margin: '0 auto 1.5em auto' }, value: url, includeMargin: true, size: 256 }),
            window.SP_REACT.createElement("span", { style: { textAlign: 'center', wordBreak: 'break-word' } }, url)), window);
    };

    var ACTION_SHOW_LINK_QR$i="Ukzat QR odkaz";var MSG_USAGE_INSTRUCTIONS$e="Vyber hru {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$i="Zmnit artwork...";var ASSET_TYPE_CAPSULE$i="Kapsle";var ASSET_TYPE_WIDECAPSULE$i="irok Kapsle";var ASSET_TYPE_HERO$i="Hrdina";var ASSET_TYPE_LOGO$i="Logo";var ASSET_TYPE_ICON$i="Ikona";var LABEL_TAB_CAPSULE$i="Kapsle";var LABEL_TAB_WIDECAPSULE$i="irok Kapsle";var LABEL_TAB_HERO$i="Hrdina";var LABEL_TAB_LOGO$i="Logo";var LABEL_TAB_ICON$i="Ikona";var LABEL_TAB_MANAGE$i="Spravovat";var MSG_ASSET_TAB_SETTINGS_DESC$5="Peuspodat nebo skrt nepouit karty a nastavit vchoz zloku, kter se oteve pi pouit \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$e="Ztracen? Zde je rychl pruka";var LABEL_SETTINGS_ASSET_TABS$5="Nastaven karty aktiv";var LABEL_TRANSLATION_CREDIT_TITLE$i="esk peklad";var LABEL_MORE_SGDB_TITLE$i="Dal z SteamGridDB";var ACTION_SGDB_DISCORD$i="Pipojit na Discord";var ACTION_SGDB_GITHUB$i="Projekty s otevenm zdrojem";var ACTION_SGDB_DONATE$i="Podpote ns na Patreonu";var ACTION_SGDB_TRANSLATE$i="Pomozte s pekladem";var ACTION_SGDB_BOOP$i="Podvejte se na SGDBoop";var LABEL_RESTART_STEAM_TITLE$f="Restartovat Steam?";var ACTION_RESTART_STEAM_LATER$f="Pozdji";var ACTION_RESTART_STEAM_NOW$f="Restartovat nyn";var MSG_RESTART_STEAM_DESC$f="Steam je teba restartovat, aby se zmny projevily.";var LABEL_NOTES$i="Poznmky";var LABEL_ANIMATED$i="Animovan";var LABEL_NSFW$i="Obsah pro dospl";var LABEL_HUMOR$i="Humor";var LABEL_EPILEPSY$i="Epilepsie";var LABEL_GAME_SEARCH_TITLE$i="Hledat hru...";var LABEL_FILTER_MODAL_TITLE$i="{assetType} Filtr";var LABEL_FILTER_GAME$i="Hra";var LABEL_FILTER_DIMENSIONS$i="Rozmry";var LABEL_FILTER_STYLES$i="Styly";var LABEL_FILTER_FILE_TYPES$i="Typy soubor";var LABEL_FILTER_ANIMATION_TYPE_TITLE$i="Druhy";var LABEL_FILTER_TYPE_ANIMATED$i="Animovan";var LABEL_FILTER_TYPE_STATIC$i="Statick";var LABEL_FILTER_TAGS_TITLE$i="ttky";var LABEL_FILTER_TAG_NSFW$i="Obsah pro dospl";var MSG_FILTER_TAG_NSFW_ENABLED$i="Mon radji mrknout pes rameno.";var LABEL_FILTER_TAG_HUMOR$i="Humor";var LABEL_FILTER_TAG_EPILEPSY$i="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$i="Neoznaeno";var ACTION_FILTER_RESET$i="Zruit Filtry";var ACTION_OPEN_FILTER$i="Filtr";var ACTION_OPEN_OFFICIAL_ASSETS$c="Oficiln {assetType}";var ACTION_ASSET_APPLY$i="Pout {assetType}";var MSG_GAME_SELECTED$i="Vybrn {gameName}";var MSG_ASSETS_FILTERED$i="Nkter poloky mohou bt skryty kvli filtru";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i="Vybrn {gameName} s filtrem";var ACTION_HIDE_POS_GUIDES$c="Skrt nvody";var ACTION_SHOW_OUTLINE$c="Zobrazit nvody";var ACTION_ADJUST_POS_SIZE$c="Upravit Velikost";var MSG_ASSET_APPLY_SUCCESS$i="{assetType} byl spn pouit!";var MSG_ASSET_APPLY_ERROR$i="Pi pouit tto ablony dolo k chyb.";var ACTION_OPEN_DETAILS$i="Podrobnosti";var LABEL_ASSET_CURRENT$i="Souasn {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$i="Vymazat vlastn ablonu";var ACTION_ASSET_BROWSE_LOCAL$i="Prochzet mstn soubory";var ACTION_ASSET_APPLY_TRANSPARENT$i="Pout neviditelnou ablonu";var cs = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$i,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$e,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$i,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$i,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$i,ASSET_TYPE_HERO:ASSET_TYPE_HERO$i,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$i,ASSET_TYPE_ICON:ASSET_TYPE_ICON$i,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$i,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$i,LABEL_TAB_HERO:LABEL_TAB_HERO$i,LABEL_TAB_LOGO:LABEL_TAB_LOGO$i,LABEL_TAB_ICON:LABEL_TAB_ICON$i,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$i,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$5,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$e,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$5,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$i,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$i,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$i,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$i,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$i,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$i,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$i,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$f,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$f,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$f,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$f,LABEL_NOTES:LABEL_NOTES$i,LABEL_ANIMATED:LABEL_ANIMATED$i,LABEL_NSFW:LABEL_NSFW$i,LABEL_HUMOR:LABEL_HUMOR$i,LABEL_EPILEPSY:LABEL_EPILEPSY$i,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$i,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$i,LABEL_FILTER_GAME:LABEL_FILTER_GAME$i,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$i,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$i,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$i,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$i,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$i,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$i,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$i,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$i,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$i,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$i,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$i,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$i,ACTION_FILTER_RESET:ACTION_FILTER_RESET$i,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$i,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$c,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$i,MSG_GAME_SELECTED:MSG_GAME_SELECTED$i,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$i,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$c,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$c,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$c,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$i,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$i,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$i,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$i,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$i,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$i,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$i};

    var cs$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$i,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$e,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$i,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$i,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$i,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$i,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$i,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$i,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$i,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$i,
        LABEL_TAB_HERO: LABEL_TAB_HERO$i,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$i,
        LABEL_TAB_ICON: LABEL_TAB_ICON$i,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$i,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$5,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$e,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$5,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$i,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$i,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$i,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$i,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$i,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$i,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$i,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$f,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$f,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$f,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$f,
        LABEL_NOTES: LABEL_NOTES$i,
        LABEL_ANIMATED: LABEL_ANIMATED$i,
        LABEL_NSFW: LABEL_NSFW$i,
        LABEL_HUMOR: LABEL_HUMOR$i,
        LABEL_EPILEPSY: LABEL_EPILEPSY$i,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$i,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$i,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$i,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$i,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$i,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$i,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$i,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$i,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$i,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$i,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$i,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$i,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$i,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$i,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$i,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$i,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$i,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$c,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$i,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$i,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$i,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$c,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$c,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$c,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$i,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$i,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$i,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$i,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$i,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$i,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$i,
        'default': cs
    });

    var ACTION_SHOW_LINK_QR$h="QR Link anzeigen";var MSG_USAGE_INSTRUCTIONS$d="Whle ein Spiel {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$h="Kunstwerk ndern...";var ASSET_TYPE_CAPSULE$h="Kapsel";var ASSET_TYPE_WIDECAPSULE$h="Breite Kapsel";var ASSET_TYPE_HERO$h="Heldenbild";var ASSET_TYPE_LOGO$h="Logo";var ASSET_TYPE_ICON$h="Symbol";var LABEL_TAB_CAPSULE$h="Kapsel";var LABEL_TAB_WIDECAPSULE$h="Breite Kapsel";var LABEL_TAB_HERO$h="Heldenbild";var LABEL_TAB_LOGO$h="Logo";var LABEL_TAB_ICON$h="Symbol";var LABEL_TAB_MANAGE$h="Verwalten";var LABEL_USAGE_TITLE$d="Verlaufen? Hier ist eine Kurzanleitung";var LABEL_TRANSLATION_CREDIT_TITLE$h="Deutsche bersetzung";var LABEL_MORE_SGDB_TITLE$h="Mehr Steamgriddb Plattformen";var ACTION_SGDB_DISCORD$h="Tritt dem Discord bei";var ACTION_SGDB_GITHUB$h="Open Source Projekte";var ACTION_SGDB_DONATE$h="Untersttze uns auf Patreon";var ACTION_SGDB_TRANSLATE$h="Hilf beim bersetzen";var ACTION_SGDB_BOOP$h="Schau dir SGDBoop an";var LABEL_RESTART_STEAM_TITLE$e="Steam neu starten?";var ACTION_RESTART_STEAM_LATER$e="Spter";var ACTION_RESTART_STEAM_NOW$e="Jetzt Neustarten";var MSG_RESTART_STEAM_DESC$e="Steam muss neu gestartet werden, um die nderungen zu bernehmen.";var LABEL_NOTES$h="Notizen";var LABEL_ANIMATED$h="Animiert";var LABEL_NSFW$h="Inhalt fr Erwachsene";var LABEL_HUMOR$h="Humor";var LABEL_EPILEPSY$h="Epilepsie";var LABEL_GAME_SEARCH_TITLE$h="Suche nach einem Spiel...";var LABEL_FILTER_MODAL_TITLE$h="{assetType} Filter";var LABEL_FILTER_GAME$h="Spiel";var LABEL_FILTER_DIMENSIONS$h="Dimensionen";var LABEL_FILTER_STYLES$h="Stile";var LABEL_FILTER_FILE_TYPES$h="Dateitypen";var LABEL_FILTER_ANIMATION_TYPE_TITLE$h="Typen";var LABEL_FILTER_TYPE_ANIMATED$h="Animiert";var LABEL_FILTER_TYPE_STATIC$h="Einzelbild / Statisch";var LABEL_FILTER_TAGS_TITLE$h="Tags / Schlagwort";var LABEL_FILTER_TAG_NSFW$h="Inhalt fr Erwachsene";var MSG_FILTER_TAG_NSFW_ENABLED$h="Vielleicht mchtest du noch einmal drber schauen.";var LABEL_FILTER_TAG_HUMOR$h="Humor";var LABEL_FILTER_TAG_EPILEPSY$h="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$h="Ohne Tag";var ACTION_FILTER_RESET$h="Filter Zurcksetzen";var ACTION_OPEN_FILTER$h="Filter";var ACTION_OPEN_OFFICIAL_ASSETS$b="Offizielle {assetType}";var ACTION_ASSET_APPLY$h="{assetType} bernehmen";var MSG_GAME_SELECTED$h="{gameName} ausgewhlt";var MSG_ASSETS_FILTERED$h="Einige Inhalte knnten durch Filter ausgeblendet werden";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h="{gameName} mit Filter ausgewhlt";var ACTION_HIDE_POS_GUIDES$b="Anleitungen ausblenden";var ACTION_SHOW_OUTLINE$b="Anleitung anzeigen";var ACTION_ADJUST_POS_SIZE$b="Gre anpassen";var MSG_ASSET_APPLY_SUCCESS$h="{assetType} wurde erfolgreich angewendet!";var MSG_ASSET_APPLY_ERROR$h="Es gab ein Problem beim hinzufgen des Inhalts.";var ACTION_OPEN_DETAILS$h="Eigenschaften";var LABEL_ASSET_CURRENT$h="Aktuelle {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$h="Eigenen Inhalt lschen";var ACTION_ASSET_BROWSE_LOCAL$h="Nach lokalen Dateien suchen";var ACTION_ASSET_APPLY_TRANSPARENT$h="Unsichtbaren Inhalt verwenden";var de = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$h,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$d,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$h,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$h,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$h,ASSET_TYPE_HERO:ASSET_TYPE_HERO$h,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$h,ASSET_TYPE_ICON:ASSET_TYPE_ICON$h,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$h,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$h,LABEL_TAB_HERO:LABEL_TAB_HERO$h,LABEL_TAB_LOGO:LABEL_TAB_LOGO$h,LABEL_TAB_ICON:LABEL_TAB_ICON$h,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$h,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$d,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$h,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$h,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$h,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$h,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$h,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$h,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$h,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$e,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$e,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$e,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$e,LABEL_NOTES:LABEL_NOTES$h,LABEL_ANIMATED:LABEL_ANIMATED$h,LABEL_NSFW:LABEL_NSFW$h,LABEL_HUMOR:LABEL_HUMOR$h,LABEL_EPILEPSY:LABEL_EPILEPSY$h,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$h,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$h,LABEL_FILTER_GAME:LABEL_FILTER_GAME$h,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$h,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$h,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$h,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$h,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$h,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$h,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$h,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$h,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$h,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$h,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$h,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$h,ACTION_FILTER_RESET:ACTION_FILTER_RESET$h,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$h,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$b,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$h,MSG_GAME_SELECTED:MSG_GAME_SELECTED$h,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$h,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$b,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$b,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$b,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$h,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$h,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$h,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$h,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$h,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$h,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$h};

    var de$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$h,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$d,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$h,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$h,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$h,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$h,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$h,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$h,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$h,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$h,
        LABEL_TAB_HERO: LABEL_TAB_HERO$h,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$h,
        LABEL_TAB_ICON: LABEL_TAB_ICON$h,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$h,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$d,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$h,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$h,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$h,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$h,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$h,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$h,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$h,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$e,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$e,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$e,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$e,
        LABEL_NOTES: LABEL_NOTES$h,
        LABEL_ANIMATED: LABEL_ANIMATED$h,
        LABEL_NSFW: LABEL_NSFW$h,
        LABEL_HUMOR: LABEL_HUMOR$h,
        LABEL_EPILEPSY: LABEL_EPILEPSY$h,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$h,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$h,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$h,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$h,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$h,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$h,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$h,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$h,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$h,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$h,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$h,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$h,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$h,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$h,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$h,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$h,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$h,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$b,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$h,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$h,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$h,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$b,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$b,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$b,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$h,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$h,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$h,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$h,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$h,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$h,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$h,
        'default': de
    });

    var ACTION_SHOW_LINK_QR$g=" QR ";var MSG_USAGE_INSTRUCTIONS$c="   {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$g="  ...";var ASSET_TYPE_CAPSULE$g="Capsule";var ASSET_TYPE_WIDECAPSULE$g="Wide Capsule";var ASSET_TYPE_HERO$g="Hero";var ASSET_TYPE_LOGO$g="Logo";var ASSET_TYPE_ICON$g="Icon";var LABEL_TAB_CAPSULE$g="Capsule";var LABEL_TAB_WIDECAPSULE$g="Wide Capsule";var LABEL_TAB_HERO$g="Hero";var LABEL_TAB_LOGO$g="Logo";var LABEL_TAB_ICON$g="Icon";var LABEL_TAB_MANAGE$g="";var LABEL_USAGE_TITLE$c=";  ";var LABEL_TRANSLATION_CREDIT_TITLE$g=" ";var LABEL_MORE_SGDB_TITLE$g="  STEAMGRIDDB";var ACTION_SGDB_DISCORD$g="   Discord";var ACTION_SGDB_GITHUB$g="  ";var ACTION_SGDB_DONATE$g="  Patreon";var ACTION_SGDB_TRANSLATE$g=" ";var ACTION_SGDB_BOOP$g="  SGDBoop";var LABEL_RESTART_STEAM_TITLE$d=" Steam;";var ACTION_RESTART_STEAM_LATER$d="";var ACTION_RESTART_STEAM_NOW$d=" ";var MSG_RESTART_STEAM_DESC$d=" Steam        .";var LABEL_NOTES$g="";var LABEL_ANIMATED$g="";var LABEL_NSFW$g=" ";var LABEL_HUMOR$g="";var LABEL_EPILEPSY$g="";var LABEL_GAME_SEARCH_TITLE$g=" ...";var LABEL_FILTER_MODAL_TITLE$g=" {assetType}";var LABEL_FILTER_GAME$g="";var LABEL_FILTER_DIMENSIONS$g="";var LABEL_FILTER_STYLES$g="";var LABEL_FILTER_FILE_TYPES$g=" ";var LABEL_FILTER_ANIMATION_TYPE_TITLE$g="";var LABEL_FILTER_TYPE_ANIMATED$g="";var LABEL_FILTER_TYPE_STATIC$g="";var LABEL_FILTER_TAGS_TITLE$g="";var LABEL_FILTER_TAG_NSFW$g=" ";var MSG_FILTER_TAG_NSFW_ENABLED$g="      .";var LABEL_FILTER_TAG_HUMOR$g="";var LABEL_FILTER_TAG_EPILEPSY$g="";var LABEL_FILTER_TAG_UNTAGGED$g=" ";var ACTION_FILTER_RESET$g=" ";var ACTION_OPEN_FILTER$g="";var ACTION_OPEN_OFFICIAL_ASSETS$a=" {assetType}";var ACTION_ASSET_APPLY$g=" {assetType}";var MSG_GAME_SELECTED$g="  {gameName}";var MSG_ASSETS_FILTERED$g="       ";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g="  {gameName}  ";var ACTION_HIDE_POS_GUIDES$a=" ";var ACTION_SHOW_OUTLINE$a=" ";var ACTION_ADJUST_POS_SIZE$a=" ";var MSG_ASSET_APPLY_SUCCESS$g="{assetType}  !";var MSG_ASSET_APPLY_ERROR$g="       .";var ACTION_OPEN_DETAILS$g="";var LABEL_ASSET_CURRENT$g=" {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$g=" ";var ACTION_ASSET_BROWSE_LOCAL$g="  ";var ACTION_ASSET_APPLY_TRANSPARENT$g="  ";var el = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$g,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$c,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$g,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$g,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$g,ASSET_TYPE_HERO:ASSET_TYPE_HERO$g,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$g,ASSET_TYPE_ICON:ASSET_TYPE_ICON$g,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$g,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$g,LABEL_TAB_HERO:LABEL_TAB_HERO$g,LABEL_TAB_LOGO:LABEL_TAB_LOGO$g,LABEL_TAB_ICON:LABEL_TAB_ICON$g,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$g,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$c,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$g,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$g,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$g,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$g,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$g,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$g,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$g,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$d,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$d,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$d,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$d,LABEL_NOTES:LABEL_NOTES$g,LABEL_ANIMATED:LABEL_ANIMATED$g,LABEL_NSFW:LABEL_NSFW$g,LABEL_HUMOR:LABEL_HUMOR$g,LABEL_EPILEPSY:LABEL_EPILEPSY$g,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$g,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$g,LABEL_FILTER_GAME:LABEL_FILTER_GAME$g,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$g,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$g,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$g,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$g,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$g,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$g,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$g,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$g,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$g,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$g,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$g,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$g,ACTION_FILTER_RESET:ACTION_FILTER_RESET$g,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$g,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$a,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$g,MSG_GAME_SELECTED:MSG_GAME_SELECTED$g,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$g,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$a,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$a,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$a,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$g,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$g,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$g,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$g,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$g,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$g,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$g};

    var el$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$g,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$c,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$g,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$g,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$g,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$g,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$g,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$g,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$g,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$g,
        LABEL_TAB_HERO: LABEL_TAB_HERO$g,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$g,
        LABEL_TAB_ICON: LABEL_TAB_ICON$g,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$g,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$c,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$g,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$g,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$g,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$g,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$g,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$g,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$g,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$d,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$d,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$d,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$d,
        LABEL_NOTES: LABEL_NOTES$g,
        LABEL_ANIMATED: LABEL_ANIMATED$g,
        LABEL_NSFW: LABEL_NSFW$g,
        LABEL_HUMOR: LABEL_HUMOR$g,
        LABEL_EPILEPSY: LABEL_EPILEPSY$g,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$g,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$g,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$g,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$g,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$g,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$g,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$g,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$g,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$g,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$g,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$g,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$g,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$g,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$g,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$g,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$g,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$g,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$a,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$g,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$g,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$g,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$a,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$a,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$a,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$g,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$g,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$g,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$g,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$g,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$g,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$g,
        'default': el
    });

    var ACTION_SHOW_LINK_QR$f="Mostrar cdigo QR del enlace";var MSG_USAGE_INSTRUCTIONS$b="Selecciona un juego {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$f="Cambiar arte...";var ASSET_TYPE_CAPSULE$f="Cpsula";var ASSET_TYPE_WIDECAPSULE$f="Cpsula ancha";var ASSET_TYPE_HERO$f="Imagen principal";var ASSET_TYPE_LOGO$f="Logotipo";var ASSET_TYPE_ICON$f="Icono";var LABEL_TAB_CAPSULE$f="Cpsula";var LABEL_TAB_WIDECAPSULE$f="Cpsula ancha";var LABEL_TAB_HERO$f="Imagen principal";var LABEL_TAB_LOGO$f="Logo";var LABEL_TAB_ICON$f="Icono";var LABEL_TAB_MANAGE$f="Gestionar";var LABEL_USAGE_TITLE$b="Tutorial";var LABEL_TRANSLATION_CREDIT_TITLE$f="Traduccin al Castellano";var LABEL_MORE_SGDB_TITLE$f="Ms cosas de SteamGridDB";var ACTION_SGDB_DISCORD$f="nete al Discord";var ACTION_SGDB_GITHUB$f="Proyectos de cdigo abierto";var ACTION_SGDB_DONATE$f="Apyanos en Patreon";var ACTION_SGDB_TRANSLATE$f="Ayuda a traducir";var ACTION_SGDB_BOOP$f="Mira SGDBoop";var LABEL_RESTART_STEAM_TITLE$c="Reiniciar Steam?";var ACTION_RESTART_STEAM_LATER$c="Reiniciar ms tarde";var ACTION_RESTART_STEAM_NOW$c="Reiniciar ahora";var MSG_RESTART_STEAM_DESC$c="Steam necesita reiniciarse para que los cambios surtan efecto.";var LABEL_NOTES$f="Anotacin";var LABEL_ANIMATED$f="Animada";var LABEL_NSFW$f="Contenido adulto";var LABEL_HUMOR$f="Humor";var LABEL_EPILEPSY$f="Epilepsia";var LABEL_GAME_SEARCH_TITLE$f="Busca un juego...";var LABEL_FILTER_MODAL_TITLE$f="Filtro de {assetType}";var LABEL_FILTER_GAME$f="Juego";var LABEL_FILTER_DIMENSIONS$f="Dimensiones";var LABEL_FILTER_STYLES$f="Estilos";var LABEL_FILTER_FILE_TYPES$f="Tipos de archivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$f="Tipos";var LABEL_FILTER_TYPE_ANIMATED$f="Animada";var LABEL_FILTER_TYPE_STATIC$f="Esttica";var LABEL_FILTER_TAGS_TITLE$f="Etiquetas";var LABEL_FILTER_TAG_NSFW$f="Contenido adulto";var MSG_FILTER_TAG_NSFW_ENABLED$f="Quizs quieras comprobar que no haya nadie detrs de ti.";var LABEL_FILTER_TAG_HUMOR$f="Humor";var LABEL_FILTER_TAG_EPILEPSY$f="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$f="Sin etiquetar";var ACTION_FILTER_RESET$f="Restablecer filtros";var ACTION_OPEN_FILTER$f="Filtros";var ACTION_OPEN_OFFICIAL_ASSETS$9="Oficial {assetType}";var ACTION_ASSET_APPLY$f="Usar {assetType}";var MSG_GAME_SELECTED$f="{gameName} seleccionado";var MSG_ASSETS_FILTERED$f="Algunas imgenes podran no mostrarse debido al filtro";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f="{gameName} seleccionado con filtro";var ACTION_HIDE_POS_GUIDES$9="Ocultar guas";var ACTION_SHOW_OUTLINE$9="Mostrar guas";var ACTION_ADJUST_POS_SIZE$9="Ajustar el tamao";var MSG_ASSET_APPLY_SUCCESS$f="La imagen ha sido aplicada con xito!";var MSG_ASSET_APPLY_ERROR$f="Hubo un problema al aplicar esta imagen.";var ACTION_OPEN_DETAILS$f="Detalles";var LABEL_ASSET_CURRENT$f="{assetType} actual";var ACTION_ASSET_CUSTOM_CLEAR$f="Eliminar arte personalizado";var ACTION_ASSET_BROWSE_LOCAL$f="Buscar archivos locales";var ACTION_ASSET_APPLY_TRANSPARENT$f="Usar imagen invisible";var es = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$f,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$b,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$f,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$f,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$f,ASSET_TYPE_HERO:ASSET_TYPE_HERO$f,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$f,ASSET_TYPE_ICON:ASSET_TYPE_ICON$f,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$f,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$f,LABEL_TAB_HERO:LABEL_TAB_HERO$f,LABEL_TAB_LOGO:LABEL_TAB_LOGO$f,LABEL_TAB_ICON:LABEL_TAB_ICON$f,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$f,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$b,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$f,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$f,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$f,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$f,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$f,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$f,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$f,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$c,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$c,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$c,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$c,LABEL_NOTES:LABEL_NOTES$f,LABEL_ANIMATED:LABEL_ANIMATED$f,LABEL_NSFW:LABEL_NSFW$f,LABEL_HUMOR:LABEL_HUMOR$f,LABEL_EPILEPSY:LABEL_EPILEPSY$f,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$f,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$f,LABEL_FILTER_GAME:LABEL_FILTER_GAME$f,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$f,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$f,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$f,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$f,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$f,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$f,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$f,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$f,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$f,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$f,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$f,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$f,ACTION_FILTER_RESET:ACTION_FILTER_RESET$f,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$f,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$9,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$f,MSG_GAME_SELECTED:MSG_GAME_SELECTED$f,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$f,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$9,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$9,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$9,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$f,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$f,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$f,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$f,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$f,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$f,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$f};

    var es$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$f,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$b,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$f,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$f,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$f,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$f,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$f,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$f,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$f,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$f,
        LABEL_TAB_HERO: LABEL_TAB_HERO$f,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$f,
        LABEL_TAB_ICON: LABEL_TAB_ICON$f,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$f,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$b,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$f,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$f,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$f,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$f,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$f,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$f,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$f,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$c,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$c,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$c,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$c,
        LABEL_NOTES: LABEL_NOTES$f,
        LABEL_ANIMATED: LABEL_ANIMATED$f,
        LABEL_NSFW: LABEL_NSFW$f,
        LABEL_HUMOR: LABEL_HUMOR$f,
        LABEL_EPILEPSY: LABEL_EPILEPSY$f,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$f,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$f,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$f,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$f,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$f,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$f,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$f,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$f,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$f,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$f,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$f,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$f,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$f,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$f,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$f,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$f,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$f,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$9,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$f,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$f,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$f,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$9,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$9,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$9,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$f,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$f,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$f,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$f,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$f,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$f,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$f,
        'default': es
    });

    var ACTION_SHOW_LINK_QR$e="Mostrar cdigo QR del enlace";var MSG_USAGE_INSTRUCTIONS$a="Selcciona un juego {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$e="Cambiar arte...";var ASSET_TYPE_CAPSULE$e="Cpsula";var ASSET_TYPE_WIDECAPSULE$e="Cpsula ancha";var ASSET_TYPE_HERO$e="Arte principal";var ASSET_TYPE_LOGO$e="Logotipo";var ASSET_TYPE_ICON$e="cono";var LABEL_TAB_CAPSULE$e="Cpsula";var LABEL_TAB_WIDECAPSULE$e="Cpsula ancha";var LABEL_TAB_HERO$e="Imagen principal";var LABEL_TAB_LOGO$e="Logotipo";var LABEL_TAB_ICON$e="cono";var LABEL_TAB_MANAGE$e="Gestionar";var LABEL_USAGE_TITLE$a="Tutorial";var LABEL_TRANSLATION_CREDIT_TITLE$e="Traduccin al Espaol";var LABEL_MORE_SGDB_TITLE$e="Ms cosas de SteamGridDB";var ACTION_SGDB_DISCORD$e="nete al Discord";var ACTION_SGDB_GITHUB$e="Proyectos de cdigo abierto";var ACTION_SGDB_DONATE$e="Apoyanos en Patreon";var ACTION_SGDB_TRANSLATE$e="Ayuda a traducir";var ACTION_SGDB_BOOP$e="Chequea SteamGridDB";var LABEL_RESTART_STEAM_TITLE$b="Quieres reiniciar Steam?";var ACTION_RESTART_STEAM_LATER$b="Reiniciar ms tarde";var ACTION_RESTART_STEAM_NOW$b="Reiniciar ahora";var MSG_RESTART_STEAM_DESC$b="Steam necesita reiniciarse para que los cambios tengan efecto.";var LABEL_NOTES$e="Anotacin";var LABEL_ANIMATED$e="Animada";var LABEL_NSFW$e="Contenido para adultos";var LABEL_HUMOR$e="Humor";var LABEL_EPILEPSY$e="Epilepsia";var LABEL_GAME_SEARCH_TITLE$e="Busca un juego...";var LABEL_FILTER_MODAL_TITLE$e="Filtro de {assetType}";var LABEL_FILTER_GAME$e="Juego";var LABEL_FILTER_DIMENSIONS$e="Dimensiones";var LABEL_FILTER_STYLES$e="Estilos";var LABEL_FILTER_FILE_TYPES$e="Tipos de archivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$e="Tipos";var LABEL_FILTER_TYPE_ANIMATED$e="Animada";var LABEL_FILTER_TYPE_STATIC$e="Esttica";var LABEL_FILTER_TAGS_TITLE$e="Etiquetas";var LABEL_FILTER_TAG_NSFW$e="Contenido para adultos";var MSG_FILTER_TAG_NSFW_ENABLED$e="Revisa que no haya nadie detrs de ti.";var LABEL_FILTER_TAG_HUMOR$e="Humor";var LABEL_FILTER_TAG_EPILEPSY$e="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$e="Sin etiquetar";var ACTION_FILTER_RESET$e="Restablecer filtros";var ACTION_OPEN_FILTER$e="Filtros";var ACTION_OPEN_OFFICIAL_ASSETS$8="{assetType} oficial";var ACTION_ASSET_APPLY$e="Usar {assetType}";var MSG_GAME_SELECTED$e="{gameName} seleccionado";var MSG_ASSETS_FILTERED$e="Algunas imgenes podran estar ocultas debido al filtro";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e="{gameName} seleccionado con filtro";var ACTION_HIDE_POS_GUIDES$8="Ocultar guas";var ACTION_SHOW_OUTLINE$8="Mostrar guas";var ACTION_ADJUST_POS_SIZE$8="Ajustar tamao";var MSG_ASSET_APPLY_SUCCESS$e="La imagen ha sido aplicada con xito!";var MSG_ASSET_APPLY_ERROR$e="Hubo un problema al aplicar esta imagen.";var ACTION_OPEN_DETAILS$e="Detalles";var LABEL_ASSET_CURRENT$e="{assetType} actual";var ACTION_ASSET_CUSTOM_CLEAR$e="Eliminar arte personalizado";var ACTION_ASSET_BROWSE_LOCAL$e="Buscar archivos locales";var ACTION_ASSET_APPLY_TRANSPARENT$e="Usar imagen invisible";var es419 = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$e,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$a,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$e,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$e,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$e,ASSET_TYPE_HERO:ASSET_TYPE_HERO$e,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$e,ASSET_TYPE_ICON:ASSET_TYPE_ICON$e,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$e,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$e,LABEL_TAB_HERO:LABEL_TAB_HERO$e,LABEL_TAB_LOGO:LABEL_TAB_LOGO$e,LABEL_TAB_ICON:LABEL_TAB_ICON$e,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$e,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$a,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$e,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$e,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$e,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$e,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$e,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$e,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$e,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$b,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$b,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$b,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$b,LABEL_NOTES:LABEL_NOTES$e,LABEL_ANIMATED:LABEL_ANIMATED$e,LABEL_NSFW:LABEL_NSFW$e,LABEL_HUMOR:LABEL_HUMOR$e,LABEL_EPILEPSY:LABEL_EPILEPSY$e,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$e,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$e,LABEL_FILTER_GAME:LABEL_FILTER_GAME$e,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$e,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$e,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$e,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$e,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$e,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$e,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$e,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$e,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$e,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$e,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$e,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$e,ACTION_FILTER_RESET:ACTION_FILTER_RESET$e,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$e,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$8,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$e,MSG_GAME_SELECTED:MSG_GAME_SELECTED$e,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$e,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$8,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$8,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$8,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$e,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$e,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$e,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$e,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$e,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$e,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$e};

    var es419$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$e,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$a,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$e,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$e,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$e,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$e,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$e,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$e,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$e,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$e,
        LABEL_TAB_HERO: LABEL_TAB_HERO$e,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$e,
        LABEL_TAB_ICON: LABEL_TAB_ICON$e,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$e,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$a,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$e,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$e,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$e,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$e,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$e,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$e,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$e,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$b,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$b,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$b,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$b,
        LABEL_NOTES: LABEL_NOTES$e,
        LABEL_ANIMATED: LABEL_ANIMATED$e,
        LABEL_NSFW: LABEL_NSFW$e,
        LABEL_HUMOR: LABEL_HUMOR$e,
        LABEL_EPILEPSY: LABEL_EPILEPSY$e,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$e,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$e,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$e,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$e,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$e,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$e,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$e,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$e,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$e,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$e,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$e,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$e,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$e,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$e,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$e,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$e,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$e,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$8,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$e,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$e,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$e,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$8,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$8,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$8,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$e,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$e,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$e,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$e,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$e,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$e,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$e,
        'default': es419
    });

    var ACTION_SHOW_LINK_QR$d="Afficher le code QR du lien";var MSG_USAGE_INSTRUCTIONS$9="Slectionner un jeu {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$d="Modifier les images...";var ASSET_TYPE_CAPSULE$d="Couverture";var ASSET_TYPE_WIDECAPSULE$d="Couverture large";var ASSET_TYPE_HERO$d="Bannire";var ASSET_TYPE_LOGO$d="Marque";var ASSET_TYPE_ICON$d="Icne";var LABEL_TAB_CAPSULE$d="Couverture";var LABEL_TAB_WIDECAPSULE$d="Couverture large";var LABEL_TAB_HERO$d="Bannire";var LABEL_TAB_LOGO$d="Marque";var LABEL_TAB_ICON$d="Icne";var LABEL_TAB_MANAGE$d="Grer";var LABEL_USAGE_TITLE$9="Perdu? Voici un guide rapide";var LABEL_TRANSLATION_CREDIT_TITLE$d="Traduction franaise";var LABEL_MORE_SGDB_TITLE$d="Plus de contenu SteamGridDB";var ACTION_SGDB_DISCORD$d="Rejoignez le Discord";var ACTION_SGDB_GITHUB$d="Projets Open Source";var ACTION_SGDB_DONATE$d="Soutenez-nous sur Patreon";var ACTION_SGDB_TRANSLATE$d="Aidez  traduire";var ACTION_SGDB_BOOP$d="Dcouvrez SGDBoop";var LABEL_RESTART_STEAM_TITLE$a="Redmarrer Steam?";var ACTION_RESTART_STEAM_LATER$a="Plus tard";var ACTION_RESTART_STEAM_NOW$a="Redmarrer maintenant";var MSG_RESTART_STEAM_DESC$a="Steam doit tre redmarr pour appliquer les modifications.";var LABEL_NOTES$d="Notes";var LABEL_ANIMATED$d="Anim";var LABEL_NSFW$d="Contenu Adulte";var LABEL_HUMOR$d="Humoristique";var LABEL_EPILEPSY$d="pilepsie";var LABEL_GAME_SEARCH_TITLE$d="Rechercher un jeu...";var LABEL_FILTER_MODAL_TITLE$d="Filtres {assetType}";var LABEL_FILTER_GAME$d="Jeu";var LABEL_FILTER_DIMENSIONS$d="Dimensions";var LABEL_FILTER_STYLES$d="Styles";var LABEL_FILTER_FILE_TYPES$d="Types de fichiers";var LABEL_FILTER_ANIMATION_TYPE_TITLE$d="Types";var LABEL_FILTER_TYPE_ANIMATED$d="Anim";var LABEL_FILTER_TYPE_STATIC$d="Statique";var LABEL_FILTER_TAGS_TITLE$d="Tags";var LABEL_FILTER_TAG_NSFW$d="Contenu adulte";var MSG_FILTER_TAG_NSFW_ENABLED$d="Avez-vous demand  vos parents?";var LABEL_FILTER_TAG_HUMOR$d="Humoristique";var LABEL_FILTER_TAG_EPILEPSY$d="pilepsie";var LABEL_FILTER_TAG_UNTAGGED$d="Aucun tag";var ACTION_FILTER_RESET$d="Rinitialiser les filtres";var ACTION_OPEN_FILTER$d="Filtre";var ACTION_OPEN_OFFICIAL_ASSETS$7="{assetType} officielle";var ACTION_ASSET_APPLY$d="Appliquer {assetType}";var MSG_GAME_SELECTED$d="{gameName} slectionn";var MSG_ASSETS_FILTERED$d="Certains lments peuvent tre cachs en raison du filtre";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d="{gameName} slectionn avec le filtre";var ACTION_HIDE_POS_GUIDES$7="Masquer les guides";var ACTION_SHOW_OUTLINE$7="Afficher les guides";var ACTION_ADJUST_POS_SIZE$7="Ajuster la taille";var MSG_ASSET_APPLY_SUCCESS$d="{assetType} a t applique avec succs!";var MSG_ASSET_APPLY_ERROR$d="Il y a eu un problme avec cette image.";var ACTION_OPEN_DETAILS$d="Dtails";var LABEL_ASSET_CURRENT$d="{assetType} actuelle";var ACTION_ASSET_CUSTOM_CLEAR$d="Effacer l'image slectionne";var ACTION_ASSET_BROWSE_LOCAL$d="Parcourir les fichiers locaux";var ACTION_ASSET_APPLY_TRANSPARENT$d="Aucune image";var fr = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$d,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$9,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$d,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$d,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$d,ASSET_TYPE_HERO:ASSET_TYPE_HERO$d,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$d,ASSET_TYPE_ICON:ASSET_TYPE_ICON$d,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$d,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$d,LABEL_TAB_HERO:LABEL_TAB_HERO$d,LABEL_TAB_LOGO:LABEL_TAB_LOGO$d,LABEL_TAB_ICON:LABEL_TAB_ICON$d,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$d,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$9,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$d,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$d,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$d,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$d,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$d,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$d,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$d,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$a,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$a,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$a,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$a,LABEL_NOTES:LABEL_NOTES$d,LABEL_ANIMATED:LABEL_ANIMATED$d,LABEL_NSFW:LABEL_NSFW$d,LABEL_HUMOR:LABEL_HUMOR$d,LABEL_EPILEPSY:LABEL_EPILEPSY$d,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$d,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$d,LABEL_FILTER_GAME:LABEL_FILTER_GAME$d,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$d,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$d,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$d,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$d,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$d,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$d,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$d,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$d,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$d,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$d,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$d,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$d,ACTION_FILTER_RESET:ACTION_FILTER_RESET$d,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$d,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$7,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$d,MSG_GAME_SELECTED:MSG_GAME_SELECTED$d,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$d,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$7,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$7,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$7,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$d,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$d,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$d,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$d,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$d,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$d,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$d};

    var fr$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$d,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$9,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$d,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$d,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$d,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$d,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$d,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$d,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$d,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$d,
        LABEL_TAB_HERO: LABEL_TAB_HERO$d,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$d,
        LABEL_TAB_ICON: LABEL_TAB_ICON$d,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$d,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$9,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$d,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$d,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$d,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$d,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$d,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$d,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$d,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$a,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$a,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$a,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$a,
        LABEL_NOTES: LABEL_NOTES$d,
        LABEL_ANIMATED: LABEL_ANIMATED$d,
        LABEL_NSFW: LABEL_NSFW$d,
        LABEL_HUMOR: LABEL_HUMOR$d,
        LABEL_EPILEPSY: LABEL_EPILEPSY$d,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$d,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$d,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$d,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$d,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$d,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$d,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$d,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$d,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$d,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$d,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$d,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$d,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$d,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$d,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$d,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$d,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$d,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$7,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$d,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$d,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$d,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$7,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$7,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$7,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$d,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$d,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$d,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$d,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$d,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$d,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$d,
        'default': fr
    });

    var ACTION_SHOW_LINK_QR$c="Mostra codice QR";var ACTION_CHANGE_ARTWORK$c="Cambia grafica...";var ASSET_TYPE_CAPSULE$c="Fronte";var ASSET_TYPE_WIDECAPSULE$c="Fronte Orizzontale";var ASSET_TYPE_HERO$c="Banner";var ASSET_TYPE_LOGO$c="Logo";var ASSET_TYPE_ICON$c="Icona";var LABEL_TAB_CAPSULE$c="Fronte";var LABEL_TAB_WIDECAPSULE$c="Fronte grande";var LABEL_TAB_HERO$c="Banner";var LABEL_TAB_LOGO$c="Logo";var LABEL_TAB_ICON$c="Icona";var LABEL_TAB_MANAGE$c="Gestisci";var LABEL_TRANSLATION_CREDIT_TITLE$c="Traduzione italiana";var LABEL_MORE_SGDB_TITLE$c="Canali SteamGridDB";var ACTION_SGDB_DISCORD$c="Unisciti al Discord";var ACTION_SGDB_GITHUB$c="Progetti Open Source";var ACTION_SGDB_DONATE$c="Supportaci su Patreon";var ACTION_SGDB_TRANSLATE$c="Aiutaci a tradurre";var ACTION_SGDB_BOOP$c="Scopri SGDBoop";var LABEL_RESTART_STEAM_TITLE$9="Riavviare Steam?";var ACTION_RESTART_STEAM_LATER$9="Pi tardi";var ACTION_RESTART_STEAM_NOW$9="Riavvia ora";var MSG_RESTART_STEAM_DESC$9="Steam ha bisogno di essere riavviato per applicare le modifiche.";var LABEL_NOTES$c="Note";var LABEL_ANIMATED$c="Animato";var LABEL_NSFW$c="+18";var LABEL_HUMOR$c="Comico";var LABEL_EPILEPSY$c="Epilessia";var LABEL_GAME_SEARCH_TITLE$c="Cerca un titolo...";var LABEL_FILTER_MODAL_TITLE$c="Filtri {assetType}";var LABEL_FILTER_GAME$c="Titolo";var LABEL_FILTER_DIMENSIONS$c="Dimensioni";var LABEL_FILTER_STYLES$c="Stile";var LABEL_FILTER_FILE_TYPES$c="Tipo di file";var LABEL_FILTER_ANIMATION_TYPE_TITLE$c="Stili";var LABEL_FILTER_TYPE_ANIMATED$c="Animato";var LABEL_FILTER_TYPE_STATIC$c="Statico";var LABEL_FILTER_TAGS_TITLE$c="Tags";var LABEL_FILTER_TAG_NSFW$c="+18";var MSG_FILTER_TAG_NSFW_ENABLED$c="Forse dovresti controllarti alle spalle.";var LABEL_FILTER_TAG_HUMOR$c="Comico";var LABEL_FILTER_TAG_EPILEPSY$c="Epilessia";var LABEL_FILTER_TAG_UNTAGGED$c="Senza tag";var ACTION_FILTER_RESET$c="Resetta filtri";var ACTION_OPEN_FILTER$c="Filtri";var ACTION_ASSET_APPLY$c="Applica {assetType}";var MSG_GAME_SELECTED$c="Selezionato {gameName}";var MSG_ASSETS_FILTERED$c="Alcuni risultati potrebbero essere nascosto dai filtri";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c="Selezionato {gameName} con filtro";var MSG_ASSET_APPLY_SUCCESS$c="{assetType} applicato con successo!";var MSG_ASSET_APPLY_ERROR$c="C` stato un problema con questo elemento.";var ACTION_OPEN_DETAILS$c="Dettagli";var LABEL_ASSET_CURRENT$c="{assetType} corrente";var ACTION_ASSET_CUSTOM_CLEAR$c="Rimuovi";var ACTION_ASSET_BROWSE_LOCAL$c="Sfoglia i file locali";var ACTION_ASSET_APPLY_TRANSPARENT$c="Lascia vuoto";var it = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$c,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$c,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$c,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$c,ASSET_TYPE_HERO:ASSET_TYPE_HERO$c,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$c,ASSET_TYPE_ICON:ASSET_TYPE_ICON$c,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$c,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$c,LABEL_TAB_HERO:LABEL_TAB_HERO$c,LABEL_TAB_LOGO:LABEL_TAB_LOGO$c,LABEL_TAB_ICON:LABEL_TAB_ICON$c,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$c,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$c,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$c,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$c,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$c,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$c,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$c,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$c,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$9,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$9,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$9,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$9,LABEL_NOTES:LABEL_NOTES$c,LABEL_ANIMATED:LABEL_ANIMATED$c,LABEL_NSFW:LABEL_NSFW$c,LABEL_HUMOR:LABEL_HUMOR$c,LABEL_EPILEPSY:LABEL_EPILEPSY$c,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$c,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$c,LABEL_FILTER_GAME:LABEL_FILTER_GAME$c,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$c,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$c,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$c,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$c,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$c,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$c,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$c,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$c,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$c,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$c,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$c,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$c,ACTION_FILTER_RESET:ACTION_FILTER_RESET$c,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$c,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$c,MSG_GAME_SELECTED:MSG_GAME_SELECTED$c,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$c,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$c,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$c,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$c,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$c,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$c,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$c,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$c};

    var it$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$c,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$c,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$c,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$c,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$c,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$c,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$c,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$c,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$c,
        LABEL_TAB_HERO: LABEL_TAB_HERO$c,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$c,
        LABEL_TAB_ICON: LABEL_TAB_ICON$c,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$c,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$c,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$c,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$c,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$c,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$c,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$c,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$c,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$9,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$9,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$9,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$9,
        LABEL_NOTES: LABEL_NOTES$c,
        LABEL_ANIMATED: LABEL_ANIMATED$c,
        LABEL_NSFW: LABEL_NSFW$c,
        LABEL_HUMOR: LABEL_HUMOR$c,
        LABEL_EPILEPSY: LABEL_EPILEPSY$c,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$c,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$c,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$c,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$c,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$c,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$c,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$c,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$c,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$c,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$c,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$c,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$c,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$c,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$c,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$c,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$c,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$c,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$c,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$c,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$c,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$c,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$c,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$c,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$c,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$c,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$c,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$c,
        'default': it
    });

    var ACTION_SHOW_LINK_QR$b="QR";var MSG_USAGE_INSTRUCTIONS$8=" {arrow} {optionsButton} {arrow}{ACTION_CHANGE_ARTWORK}";var ACTION_CHANGE_ARTWORK$b="";var ASSET_TYPE_CAPSULE$b="";var ASSET_TYPE_WIDECAPSULE$b="";var ASSET_TYPE_HERO$b="";var ASSET_TYPE_LOGO$b="";var ASSET_TYPE_ICON$b="";var LABEL_TAB_CAPSULE$b="";var LABEL_TAB_WIDECAPSULE$b="";var LABEL_TAB_HERO$b="";var LABEL_TAB_LOGO$b="";var LABEL_TAB_ICON$b="";var LABEL_TAB_MANAGE$b="";var LABEL_USAGE_TITLE$8="";var LABEL_TRANSLATION_CREDIT_TITLE$b="";var LABEL_MORE_SGDB_TITLE$b="SteamGridDB";var ACTION_SGDB_DISCORD$b="Discord";var ACTION_SGDB_GITHUB$b="";var ACTION_SGDB_DONATE$b="Patreon";var ACTION_SGDB_TRANSLATE$b="";var ACTION_SGDB_BOOP$b="SGDBoop";var LABEL_RESTART_STEAM_TITLE$8="Steam";var ACTION_RESTART_STEAM_LATER$8="";var ACTION_RESTART_STEAM_NOW$8="";var MSG_RESTART_STEAM_DESC$8="Steam";var LABEL_NOTES$b="";var LABEL_ANIMATED$b="";var LABEL_NSFW$b="";var LABEL_HUMOR$b="";var LABEL_EPILEPSY$b="";var LABEL_GAME_SEARCH_TITLE$b="";var LABEL_FILTER_MODAL_TITLE$b="{assetType}";var LABEL_FILTER_GAME$b="";var LABEL_FILTER_DIMENSIONS$b="";var LABEL_FILTER_STYLES$b="";var LABEL_FILTER_FILE_TYPES$b="";var LABEL_FILTER_ANIMATION_TYPE_TITLE$b="";var LABEL_FILTER_TYPE_ANIMATED$b="";var LABEL_FILTER_TYPE_STATIC$b="";var LABEL_FILTER_TAGS_TITLE$b="";var LABEL_FILTER_TAG_NSFW$b="";var MSG_FILTER_TAG_NSFW_ENABLED$b="";var LABEL_FILTER_TAG_HUMOR$b="";var LABEL_FILTER_TAG_EPILEPSY$b="";var LABEL_FILTER_TAG_UNTAGGED$b="";var ACTION_FILTER_RESET$b="";var ACTION_OPEN_FILTER$b="";var ACTION_OPEN_OFFICIAL_ASSETS$6="{assetType}";var ACTION_ASSET_APPLY$b="{assetType}";var MSG_GAME_SELECTED$b="{gameName}";var MSG_ASSETS_FILTERED$b="";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b="{gameName}";var ACTION_HIDE_POS_GUIDES$6="";var ACTION_SHOW_OUTLINE$6="";var ACTION_ADJUST_POS_SIZE$6="";var MSG_ASSET_APPLY_SUCCESS$b="{assetType}";var MSG_ASSET_APPLY_ERROR$b="";var ACTION_OPEN_DETAILS$b="";var LABEL_ASSET_CURRENT$b="{assetType}";var ACTION_ASSET_CUSTOM_CLEAR$b="";var ACTION_ASSET_BROWSE_LOCAL$b="";var ACTION_ASSET_APPLY_TRANSPARENT$b="";var ja = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$b,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$8,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$b,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$b,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$b,ASSET_TYPE_HERO:ASSET_TYPE_HERO$b,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$b,ASSET_TYPE_ICON:ASSET_TYPE_ICON$b,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$b,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$b,LABEL_TAB_HERO:LABEL_TAB_HERO$b,LABEL_TAB_LOGO:LABEL_TAB_LOGO$b,LABEL_TAB_ICON:LABEL_TAB_ICON$b,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$b,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$8,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$b,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$b,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$b,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$b,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$b,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$b,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$b,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$8,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$8,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$8,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$8,LABEL_NOTES:LABEL_NOTES$b,LABEL_ANIMATED:LABEL_ANIMATED$b,LABEL_NSFW:LABEL_NSFW$b,LABEL_HUMOR:LABEL_HUMOR$b,LABEL_EPILEPSY:LABEL_EPILEPSY$b,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$b,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$b,LABEL_FILTER_GAME:LABEL_FILTER_GAME$b,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$b,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$b,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$b,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$b,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$b,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$b,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$b,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$b,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$b,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$b,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$b,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$b,ACTION_FILTER_RESET:ACTION_FILTER_RESET$b,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$b,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$6,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$b,MSG_GAME_SELECTED:MSG_GAME_SELECTED$b,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$b,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$6,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$6,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$6,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$b,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$b,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$b,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$b,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$b,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$b,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$b};

    var ja$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$b,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$8,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$b,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$b,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$b,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$b,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$b,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$b,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$b,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$b,
        LABEL_TAB_HERO: LABEL_TAB_HERO$b,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$b,
        LABEL_TAB_ICON: LABEL_TAB_ICON$b,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$b,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$8,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$b,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$b,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$b,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$b,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$b,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$b,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$b,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$8,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$8,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$8,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$8,
        LABEL_NOTES: LABEL_NOTES$b,
        LABEL_ANIMATED: LABEL_ANIMATED$b,
        LABEL_NSFW: LABEL_NSFW$b,
        LABEL_HUMOR: LABEL_HUMOR$b,
        LABEL_EPILEPSY: LABEL_EPILEPSY$b,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$b,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$b,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$b,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$b,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$b,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$b,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$b,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$b,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$b,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$b,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$b,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$b,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$b,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$b,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$b,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$b,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$b,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$6,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$b,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$b,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$b,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$6,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$6,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$6,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$b,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$b,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$b,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$b,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$b,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$b,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$b,
        'default': ja
    });

    var ACTION_SHOW_LINK_QR$a=" QR ";var MSG_USAGE_INSTRUCTIONS$7="  {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$a=" ...";var ASSET_TYPE_CAPSULE$a="";var ASSET_TYPE_WIDECAPSULE$a=" ";var ASSET_TYPE_HERO$a="";var ASSET_TYPE_LOGO$a="";var ASSET_TYPE_ICON$a="";var LABEL_TAB_CAPSULE$a="";var LABEL_TAB_WIDECAPSULE$a=" ";var LABEL_TAB_HERO$a="";var LABEL_TAB_LOGO$a="";var LABEL_TAB_ICON$a="";var LABEL_TAB_MANAGE$a="";var LABEL_USAGE_TITLE$7=" ?  .";var LABEL_TRANSLATION_CREDIT_TITLE$a=" ";var LABEL_MORE_SGDB_TITLE$a="SteamGridDB  ";var ACTION_SGDB_DISCORD$a="Discord ";var ACTION_SGDB_GITHUB$a="  ";var ACTION_SGDB_DONATE$a="Patreon ";var ACTION_SGDB_TRANSLATE$a=" ";var ACTION_SGDB_BOOP$a="SGDBoop ";var LABEL_RESTART_STEAM_TITLE$7="Steam  ?";var ACTION_RESTART_STEAM_LATER$7="";var ACTION_RESTART_STEAM_NOW$7="  ";var MSG_RESTART_STEAM_DESC$7="   Steam   .";var LABEL_NOTES$a="";var LABEL_ANIMATED$a=" ";var LABEL_NSFW$a=" ";var LABEL_HUMOR$a="";var LABEL_EPILEPSY$a="";var LABEL_GAME_SEARCH_TITLE$a="  ...";var LABEL_FILTER_MODAL_TITLE$a="{assetType} ";var LABEL_FILTER_GAME$a="";var LABEL_FILTER_DIMENSIONS$a=" ";var LABEL_FILTER_STYLES$a="";var LABEL_FILTER_FILE_TYPES$a=" ";var LABEL_FILTER_ANIMATION_TYPE_TITLE$a="";var LABEL_FILTER_TYPE_ANIMATED$a=" ";var LABEL_FILTER_TYPE_STATIC$a=" ";var LABEL_FILTER_TAGS_TITLE$a="";var LABEL_FILTER_TAG_NSFW$a=" ";var MSG_FILTER_TAG_NSFW_ENABLED$a=" !";var LABEL_FILTER_TAG_HUMOR$a="";var LABEL_FILTER_TAG_EPILEPSY$a="";var LABEL_FILTER_TAG_UNTAGGED$a=" ";var ACTION_FILTER_RESET$a=" ";var ACTION_OPEN_FILTER$a="";var ACTION_ASSET_APPLY$a="{assetType} ";var MSG_GAME_SELECTED$a="{gameName} () ";var MSG_ASSETS_FILTERED$a="       .";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a="{gameName} ()    ";var MSG_ASSET_APPLY_SUCCESS$a="{assetType}   !";var MSG_ASSET_APPLY_ERROR$a="     .";var ACTION_OPEN_DETAILS$a=" ";var LABEL_ASSET_CURRENT$a=" {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$a="   ";var ACTION_ASSET_BROWSE_LOCAL$a="   ";var ACTION_ASSET_APPLY_TRANSPARENT$a="  ";var ko = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$a,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$7,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$a,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$a,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$a,ASSET_TYPE_HERO:ASSET_TYPE_HERO$a,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$a,ASSET_TYPE_ICON:ASSET_TYPE_ICON$a,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$a,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$a,LABEL_TAB_HERO:LABEL_TAB_HERO$a,LABEL_TAB_LOGO:LABEL_TAB_LOGO$a,LABEL_TAB_ICON:LABEL_TAB_ICON$a,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$a,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$7,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$a,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$a,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$a,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$a,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$a,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$a,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$a,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$7,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$7,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$7,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$7,LABEL_NOTES:LABEL_NOTES$a,LABEL_ANIMATED:LABEL_ANIMATED$a,LABEL_NSFW:LABEL_NSFW$a,LABEL_HUMOR:LABEL_HUMOR$a,LABEL_EPILEPSY:LABEL_EPILEPSY$a,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$a,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$a,LABEL_FILTER_GAME:LABEL_FILTER_GAME$a,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$a,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$a,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$a,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$a,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$a,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$a,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$a,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$a,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$a,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$a,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$a,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$a,ACTION_FILTER_RESET:ACTION_FILTER_RESET$a,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$a,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$a,MSG_GAME_SELECTED:MSG_GAME_SELECTED$a,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$a,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$a,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$a,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$a,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$a,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$a,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$a,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$a};

    var ko$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$a,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$7,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$a,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$a,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$a,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$a,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$a,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$a,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$a,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$a,
        LABEL_TAB_HERO: LABEL_TAB_HERO$a,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$a,
        LABEL_TAB_ICON: LABEL_TAB_ICON$a,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$a,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$7,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$a,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$a,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$a,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$a,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$a,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$a,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$a,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$7,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$7,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$7,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$7,
        LABEL_NOTES: LABEL_NOTES$a,
        LABEL_ANIMATED: LABEL_ANIMATED$a,
        LABEL_NSFW: LABEL_NSFW$a,
        LABEL_HUMOR: LABEL_HUMOR$a,
        LABEL_EPILEPSY: LABEL_EPILEPSY$a,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$a,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$a,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$a,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$a,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$a,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$a,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$a,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$a,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$a,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$a,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$a,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$a,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$a,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$a,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$a,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$a,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$a,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$a,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$a,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$a,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$a,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$a,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$a,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$a,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$a,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$a,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$a,
        'default': ko
    });

    var ACTION_SHOW_LINK_QR$9="Laat QR-code zien";var MSG_USAGE_INSTRUCTIONS$6="Selecteer een spel {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$9="Wijzig afbeelding...";var ASSET_TYPE_CAPSULE$9="Capsule";var ASSET_TYPE_WIDECAPSULE$9="Wijde capsule";var ASSET_TYPE_HERO$9="Heldenplaatje";var ASSET_TYPE_LOGO$9="Logo";var ASSET_TYPE_ICON$9="Icoon";var LABEL_TAB_CAPSULE$9="Capsule";var LABEL_TAB_WIDECAPSULE$9="Wijde capsule";var LABEL_TAB_HERO$9="Heldenplaatje";var LABEL_TAB_LOGO$9="Logo";var LABEL_TAB_ICON$9="Icoon";var LABEL_TAB_MANAGE$9="Beheren";var MSG_ASSET_TAB_SETTINGS_DESC$4="Rangschik of verberg ongebruikte tabs, en kies de standaard tab die opent bij gebruik";var LABEL_USAGE_TITLE$6="Verloren? Hier is een snelle handleiding";var LABEL_SETTINGS_ASSET_TABS$4="Asset Tab Instellingen";var LABEL_TRANSLATION_CREDIT_TITLE$9="Nederlandse Vertaling";var LABEL_MORE_SGDB_TITLE$9="Meer van SteamGridDB";var ACTION_SGDB_DISCORD$9="Word lid van de Discord";var ACTION_SGDB_GITHUB$9="Open source projecten";var ACTION_SGDB_DONATE$9="Steun ons on Patreon";var ACTION_SGDB_TRANSLATE$9="Help met vertalen";var ACTION_SGDB_BOOP$9="Probeer SGDBoop";var LABEL_RESTART_STEAM_TITLE$6="Steam herstarten?";var ACTION_RESTART_STEAM_LATER$6="Niet nu";var ACTION_RESTART_STEAM_NOW$6="Nu herstarten";var MSG_RESTART_STEAM_DESC$6="Steam moet opnieuw worden opgestart voordat wijzigingen zichtbaar zijn.";var LABEL_NOTES$9="Notities";var LABEL_ANIMATED$9="Geanimeerd";var LABEL_NSFW$9="18+ Content";var LABEL_HUMOR$9="Grappig";var LABEL_EPILEPSY$9="Flitsend";var LABEL_GAME_SEARCH_TITLE$9="Zoek voor een Spelletje...";var LABEL_FILTER_MODAL_TITLE$9="{assetType} filter";var LABEL_FILTER_GAME$9="Spel";var LABEL_FILTER_DIMENSIONS$9="Afmetingen";var LABEL_FILTER_STYLES$9="Stijlen";var LABEL_FILTER_FILE_TYPES$9="Bestandstypen";var LABEL_FILTER_ANIMATION_TYPE_TITLE$9="Typen";var LABEL_FILTER_TYPE_ANIMATED$9="Geanimeerd";var LABEL_FILTER_TYPE_STATIC$9="Statisch";var LABEL_FILTER_TAGS_TITLE$9="Labels";var LABEL_FILTER_TAG_NSFW$9="18+ Content";var MSG_FILTER_TAG_NSFW_ENABLED$9="Weet je zeker dat je hier oud genoeg voor bent? Steamgriddb is niet afhankelijk van verlies van onschuld en algemeen zicht.";var LABEL_FILTER_TAG_HUMOR$9="Grappig";var LABEL_FILTER_TAG_EPILEPSY$9="Flitsend";var LABEL_FILTER_TAG_UNTAGGED$9="Zonder label";var ACTION_FILTER_RESET$9="Filters opnieuw instellen";var ACTION_OPEN_FILTER$9="Filter";var ACTION_OPEN_OFFICIAL_ASSETS$5="Officile {assetType}";var ACTION_ASSET_APPLY$9="{assetType} toepassen";var MSG_GAME_SELECTED$9="{gameName} geselecteerd";var MSG_ASSETS_FILTERED$9="Sommige afbeeldingen zijn misschien verborgen door een filter";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9="{gameName} met filter geselecteerd";var ACTION_HIDE_POS_GUIDES$5="Verberg handleidingen";var ACTION_SHOW_OUTLINE$5="Kantlijnen tonen";var ACTION_ADJUST_POS_SIZE$5="Grootte aanpassen";var MSG_ASSET_APPLY_SUCCESS$9="{assetType} is met succes toegepast!";var MSG_ASSET_APPLY_ERROR$9="Er is een probleem met het toevoegen van de afbeelding.";var ACTION_OPEN_DETAILS$9="Omschrijving";var LABEL_ASSET_CURRENT$9="Huidige {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$9="Wis aangepaste afbeelding";var ACTION_ASSET_BROWSE_LOCAL$9="Lokale bestanden doorzoeken";var ACTION_ASSET_APPLY_TRANSPARENT$9="Gebruik verborgen materiaal";var nl = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$9,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$6,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$9,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$9,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$9,ASSET_TYPE_HERO:ASSET_TYPE_HERO$9,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$9,ASSET_TYPE_ICON:ASSET_TYPE_ICON$9,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$9,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$9,LABEL_TAB_HERO:LABEL_TAB_HERO$9,LABEL_TAB_LOGO:LABEL_TAB_LOGO$9,LABEL_TAB_ICON:LABEL_TAB_ICON$9,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$9,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$4,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$6,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$4,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$9,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$9,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$9,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$9,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$9,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$9,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$9,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$6,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$6,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$6,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$6,LABEL_NOTES:LABEL_NOTES$9,LABEL_ANIMATED:LABEL_ANIMATED$9,LABEL_NSFW:LABEL_NSFW$9,LABEL_HUMOR:LABEL_HUMOR$9,LABEL_EPILEPSY:LABEL_EPILEPSY$9,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$9,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$9,LABEL_FILTER_GAME:LABEL_FILTER_GAME$9,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$9,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$9,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$9,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$9,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$9,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$9,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$9,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$9,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$9,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$9,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$9,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$9,ACTION_FILTER_RESET:ACTION_FILTER_RESET$9,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$9,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$5,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$9,MSG_GAME_SELECTED:MSG_GAME_SELECTED$9,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$9,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$5,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$5,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$5,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$9,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$9,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$9,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$9,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$9,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$9,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$9};

    var nl$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$9,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$6,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$9,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$9,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$9,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$9,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$9,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$9,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$9,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$9,
        LABEL_TAB_HERO: LABEL_TAB_HERO$9,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$9,
        LABEL_TAB_ICON: LABEL_TAB_ICON$9,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$9,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$4,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$6,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$4,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$9,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$9,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$9,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$9,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$9,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$9,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$9,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$6,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$6,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$6,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$6,
        LABEL_NOTES: LABEL_NOTES$9,
        LABEL_ANIMATED: LABEL_ANIMATED$9,
        LABEL_NSFW: LABEL_NSFW$9,
        LABEL_HUMOR: LABEL_HUMOR$9,
        LABEL_EPILEPSY: LABEL_EPILEPSY$9,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$9,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$9,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$9,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$9,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$9,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$9,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$9,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$9,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$9,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$9,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$9,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$9,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$9,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$9,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$9,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$9,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$9,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$5,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$9,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$9,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$9,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$5,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$5,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$5,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$9,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$9,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$9,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$9,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$9,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$9,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$9,
        'default': nl
    });

    var ACTION_SHOW_LINK_QR$8="Poka Kod QR";var MSG_USAGE_INSTRUCTIONS$5="Wybierz gr {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$8="Zmie grafik...";var ASSET_TYPE_CAPSULE$8="Miniatura";var ASSET_TYPE_WIDECAPSULE$8="Szeroka Miniatura";var ASSET_TYPE_HERO$8="Grafika Czoowa";var ASSET_TYPE_LOGO$8="Logo";var ASSET_TYPE_ICON$8="Ikona";var LABEL_TAB_CAPSULE$8="Miniatura";var LABEL_TAB_WIDECAPSULE$8="Szeroka Miniatura";var LABEL_TAB_HERO$8="Grafika Czoowa";var LABEL_TAB_LOGO$8="Logo";var LABEL_TAB_ICON$8="Ikona";var LABEL_TAB_MANAGE$8="Zarzdzaj";var MSG_ASSET_TAB_SETTINGS_DESC$3="Zmie kolejno, ukryj nieuywane karty lub ustaw domyln kart, ktra otwiera si po klikniciu w \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$5="Krtki przewodnik";var LABEL_SETTINGS_ASSET_TABS$3="Ustawienia Kart";var LABEL_TRANSLATION_CREDIT_TITLE$8="Tumaczenie Polskie";var LABEL_MORE_SGDB_TITLE$8="Wicej z StreamGridDB";var ACTION_SGDB_DISCORD$8="Docz do Discorda";var ACTION_SGDB_GITHUB$8="Projekty Open Source";var ACTION_SGDB_DONATE$8="Wesprzyj nas na Patreon";var ACTION_SGDB_TRANSLATE$8="Pom Tumaczy";var ACTION_SGDB_BOOP$8="Sprawd SGDBop";var LABEL_RESTART_STEAM_TITLE$5="Zrestartowa Steam?";var ACTION_RESTART_STEAM_LATER$5="Pniej";var ACTION_RESTART_STEAM_NOW$5="Restartuj Teraz";var MSG_RESTART_STEAM_DESC$5="Program musi zosta uruchomiony ponownie, aby wprowadzi zmiany.";var LABEL_NOTES$8="Notatki";var LABEL_ANIMATED$8="Animowane";var LABEL_NSFW$8="Materia dla Dorosych";var LABEL_HUMOR$8="Humor";var LABEL_EPILEPSY$8="Epilepsja";var LABEL_GAME_SEARCH_TITLE$8="Wyszukaj gr...";var LABEL_FILTER_MODAL_TITLE$8="Filtr - {assetType}";var LABEL_FILTER_GAME$8="Gra";var LABEL_FILTER_DIMENSIONS$8="Wymiary";var LABEL_FILTER_STYLES$8="Styl";var LABEL_FILTER_FILE_TYPES$8="Typ Pliku";var LABEL_FILTER_ANIMATION_TYPE_TITLE$8="Typy";var LABEL_FILTER_TYPE_ANIMATED$8="Animowany";var LABEL_FILTER_TYPE_STATIC$8="Statyczny";var LABEL_FILTER_TAGS_TITLE$8="Tagi";var LABEL_FILTER_TAG_NSFW$8="Materia dla Dorosych";var MSG_FILTER_TAG_NSFW_ENABLED$8="Moe spjrz za siebie.";var LABEL_FILTER_TAG_HUMOR$8="Humor";var LABEL_FILTER_TAG_EPILEPSY$8="Epilepsja";var LABEL_FILTER_TAG_UNTAGGED$8="Bez Tagw";var ACTION_FILTER_RESET$8="Resetuj Filtry";var ACTION_OPEN_FILTER$8="Filtruj";var ACTION_OPEN_OFFICIAL_ASSETS$4="Oryginalna Grafika";var ACTION_ASSET_APPLY$8="Zastosuj grafik";var MSG_GAME_SELECTED$8="Wybrano {gameName}";var MSG_ASSETS_FILTERED$8="Niektre grafiki mog by ukryte z powodu filtru";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8="Wybrano {gameName} z filtrem";var ACTION_HIDE_POS_GUIDES$4="Ukryj Prowadnice";var ACTION_SHOW_OUTLINE$4="Poka Prowadnice";var ACTION_ADJUST_POS_SIZE$4="Dostosuj Rozmiar";var MSG_ASSET_APPLY_SUCCESS$8="Pomylnie zastosowano grafik!";var MSG_ASSET_APPLY_ERROR$8="Podczas stosowania grafiki wystpi bd.";var ACTION_OPEN_DETAILS$8="Szczegy";var LABEL_ASSET_CURRENT$8="Obecny {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$8="Przywr Oryginaln Grafik";var ACTION_ASSET_BROWSE_LOCAL$8="Przegldaj Pliki Lokalne";var ACTION_ASSET_APPLY_TRANSPARENT$8="Usu Grafik";var pl = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$8,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$5,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$8,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$8,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$8,ASSET_TYPE_HERO:ASSET_TYPE_HERO$8,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$8,ASSET_TYPE_ICON:ASSET_TYPE_ICON$8,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$8,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$8,LABEL_TAB_HERO:LABEL_TAB_HERO$8,LABEL_TAB_LOGO:LABEL_TAB_LOGO$8,LABEL_TAB_ICON:LABEL_TAB_ICON$8,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$8,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$3,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$5,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$3,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$8,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$8,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$8,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$8,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$8,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$8,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$8,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$5,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$5,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$5,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$5,LABEL_NOTES:LABEL_NOTES$8,LABEL_ANIMATED:LABEL_ANIMATED$8,LABEL_NSFW:LABEL_NSFW$8,LABEL_HUMOR:LABEL_HUMOR$8,LABEL_EPILEPSY:LABEL_EPILEPSY$8,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$8,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$8,LABEL_FILTER_GAME:LABEL_FILTER_GAME$8,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$8,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$8,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$8,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$8,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$8,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$8,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$8,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$8,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$8,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$8,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$8,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$8,ACTION_FILTER_RESET:ACTION_FILTER_RESET$8,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$8,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$4,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$8,MSG_GAME_SELECTED:MSG_GAME_SELECTED$8,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$8,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$4,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$4,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$4,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$8,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$8,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$8,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$8,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$8,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$8,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$8};

    var pl$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$8,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$5,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$8,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$8,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$8,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$8,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$8,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$8,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$8,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$8,
        LABEL_TAB_HERO: LABEL_TAB_HERO$8,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$8,
        LABEL_TAB_ICON: LABEL_TAB_ICON$8,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$8,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$3,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$5,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$3,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$8,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$8,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$8,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$8,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$8,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$8,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$8,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$5,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$5,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$5,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$5,
        LABEL_NOTES: LABEL_NOTES$8,
        LABEL_ANIMATED: LABEL_ANIMATED$8,
        LABEL_NSFW: LABEL_NSFW$8,
        LABEL_HUMOR: LABEL_HUMOR$8,
        LABEL_EPILEPSY: LABEL_EPILEPSY$8,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$8,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$8,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$8,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$8,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$8,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$8,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$8,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$8,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$8,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$8,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$8,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$8,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$8,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$8,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$8,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$8,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$8,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$4,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$8,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$8,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$8,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$4,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$4,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$4,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$8,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$8,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$8,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$8,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$8,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$8,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$8,
        'default': pl
    });

    var ACTION_SHOW_LINK_QR$7="Mostrar QR do link";var MSG_USAGE_INSTRUCTIONS$4="Escolhe um jogo {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$7="Alterar imagens...";var ASSET_TYPE_CAPSULE$7="cpsula";var ASSET_TYPE_WIDECAPSULE$7="faixa";var ASSET_TYPE_HERO$7="cabealho";var ASSET_TYPE_LOGO$7="logtipo";var ASSET_TYPE_ICON$7="cone";var LABEL_TAB_CAPSULE$7="Cpsula";var LABEL_TAB_WIDECAPSULE$7="Faixa";var LABEL_TAB_HERO$7="Cabealho";var LABEL_TAB_LOGO$7="Logtipo";var LABEL_TAB_ICON$7="cone";var LABEL_TAB_MANAGE$7="Gerir";var LABEL_USAGE_TITLE$4="Perdido? Aqui est um guia rpido";var LABEL_TRANSLATION_CREDIT_TITLE$7="Traduo portuguesa";var LABEL_MORE_SGDB_TITLE$7="Mais da SteamGridDB";var ACTION_SGDB_DISCORD$7="Entra no Discord";var ACTION_SGDB_GITHUB$7="Projetos de cdigo aberto";var ACTION_SGDB_DONATE$7="Apoie-nos no Patreon";var ACTION_SGDB_TRANSLATE$7="Ajuda a traduzir";var ACTION_SGDB_BOOP$7="Espreita o SGDBoop";var LABEL_RESTART_STEAM_TITLE$4="Reiniciar o Steam?";var ACTION_RESTART_STEAM_LATER$4="Mais tarde";var ACTION_RESTART_STEAM_NOW$4="Reiniciar agora";var MSG_RESTART_STEAM_DESC$4="O Steam precisa de ser reiniciado para as alteraes serem aplicadas.";var LABEL_NOTES$7="Notas";var LABEL_ANIMATED$7="Animado";var LABEL_NSFW$7="Contedo adulto";var LABEL_HUMOR$7="Humor";var LABEL_EPILEPSY$7="Epilepsia";var LABEL_GAME_SEARCH_TITLE$7="Procura por um jogo...";var LABEL_FILTER_MODAL_TITLE$7="Filtro de {assetType}s";var LABEL_FILTER_GAME$7="Jogo";var LABEL_FILTER_DIMENSIONS$7="Dimenses";var LABEL_FILTER_STYLES$7="Estilos";var LABEL_FILTER_FILE_TYPES$7="Tipos de ficheiro";var LABEL_FILTER_ANIMATION_TYPE_TITLE$7="Tipos";var LABEL_FILTER_TYPE_ANIMATED$7="Animado";var LABEL_FILTER_TYPE_STATIC$7="Esttico";var LABEL_FILTER_TAGS_TITLE$7="Etiquetas";var LABEL_FILTER_TAG_NSFW$7="Contedo adulto";var MSG_FILTER_TAG_NSFW_ENABLED$7=" melhor ver se no h ningum por perto.";var LABEL_FILTER_TAG_HUMOR$7="Humor";var LABEL_FILTER_TAG_EPILEPSY$7="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$7="Sem etiqueta";var ACTION_FILTER_RESET$7="Limpar filtros";var ACTION_OPEN_FILTER$7="Filtrar";var ACTION_OPEN_OFFICIAL_ASSETS$3="Ativo oficial";var ACTION_ASSET_APPLY$7="Aplicar {assetType}";var MSG_GAME_SELECTED$7="Selecionou {gameName}";var MSG_ASSETS_FILTERED$7="Alguns ativos podem estar escondidos pelos filtros";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7="Selecionou {gameName} com filtros";var ACTION_HIDE_POS_GUIDES$3="Esconder guias";var ACTION_SHOW_OUTLINE$3="Mostrar guias";var ACTION_ADJUST_POS_SIZE$3="Ajustar tamanho";var MSG_ASSET_APPLY_SUCCESS$7="{assetType} foi aplicado/a com sucesso!";var MSG_ASSET_APPLY_ERROR$7="Houve um problema ao aplicar este ativo.";var ACTION_OPEN_DETAILS$7="Detalhes";var LABEL_ASSET_CURRENT$7="{assetType} atual";var ACTION_ASSET_CUSTOM_CLEAR$7="Limpar ativo personalizado";var ACTION_ASSET_BROWSE_LOCAL$7="Procurar em ficheiros locais";var ACTION_ASSET_APPLY_TRANSPARENT$7="Usar ativo invisvel";var pt = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$7,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$4,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$7,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$7,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$7,ASSET_TYPE_HERO:ASSET_TYPE_HERO$7,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$7,ASSET_TYPE_ICON:ASSET_TYPE_ICON$7,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$7,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$7,LABEL_TAB_HERO:LABEL_TAB_HERO$7,LABEL_TAB_LOGO:LABEL_TAB_LOGO$7,LABEL_TAB_ICON:LABEL_TAB_ICON$7,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$7,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$4,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$7,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$7,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$7,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$7,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$7,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$7,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$7,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$4,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$4,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$4,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$4,LABEL_NOTES:LABEL_NOTES$7,LABEL_ANIMATED:LABEL_ANIMATED$7,LABEL_NSFW:LABEL_NSFW$7,LABEL_HUMOR:LABEL_HUMOR$7,LABEL_EPILEPSY:LABEL_EPILEPSY$7,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$7,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$7,LABEL_FILTER_GAME:LABEL_FILTER_GAME$7,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$7,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$7,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$7,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$7,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$7,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$7,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$7,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$7,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$7,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$7,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$7,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$7,ACTION_FILTER_RESET:ACTION_FILTER_RESET$7,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$7,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$3,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$7,MSG_GAME_SELECTED:MSG_GAME_SELECTED$7,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$7,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$3,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$3,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$3,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$7,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$7,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$7,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$7,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$7,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$7,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$7};

    var pt$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$7,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$4,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$7,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$7,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$7,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$7,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$7,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$7,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$7,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$7,
        LABEL_TAB_HERO: LABEL_TAB_HERO$7,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$7,
        LABEL_TAB_ICON: LABEL_TAB_ICON$7,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$7,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$4,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$7,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$7,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$7,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$7,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$7,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$7,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$7,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$4,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$4,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$4,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$4,
        LABEL_NOTES: LABEL_NOTES$7,
        LABEL_ANIMATED: LABEL_ANIMATED$7,
        LABEL_NSFW: LABEL_NSFW$7,
        LABEL_HUMOR: LABEL_HUMOR$7,
        LABEL_EPILEPSY: LABEL_EPILEPSY$7,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$7,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$7,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$7,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$7,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$7,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$7,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$7,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$7,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$7,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$7,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$7,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$7,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$7,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$7,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$7,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$7,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$7,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$3,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$7,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$7,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$7,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$3,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$3,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$3,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$7,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$7,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$7,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$7,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$7,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$7,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$7,
        'default': pt
    });

    var ACTION_SHOW_LINK_QR$6="Mostrar QR do Link";var MSG_USAGE_INSTRUCTIONS$3="Escolha um jogo {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$6="Alterar Arte do Jogo...";var ASSET_TYPE_CAPSULE$6="cpsula";var ASSET_TYPE_WIDECAPSULE$6="faixa";var ASSET_TYPE_HERO$6="cabealho";var ASSET_TYPE_LOGO$6="logotipo";var ASSET_TYPE_ICON$6="cone";var LABEL_TAB_CAPSULE$6="Cpsula";var LABEL_TAB_WIDECAPSULE$6="Faixa";var LABEL_TAB_HERO$6="Cabealho";var LABEL_TAB_LOGO$6="Logtipo";var LABEL_TAB_ICON$6="cone";var LABEL_TAB_MANAGE$6="Gerenciar";var MSG_ASSET_TAB_SETTINGS_DESC$2="Reorganizar ou ocultar abas no utilizadas, e definir a aba padro a ser aberta quando utilizar \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$3="Perdido? Aqui est um Guia Rpido";var LABEL_SETTINGS_ASSET_TABS$2="Configuraes de Abas de Contedo";var LABEL_TRANSLATION_CREDIT_TITLE$6="Traduo PT-BR";var LABEL_MORE_SGDB_TITLE$6="Mais do SteamGridDB";var ACTION_SGDB_DISCORD$6="Entrar no Discord";var ACTION_SGDB_GITHUB$6="Projetos com Cdigo Aberto";var ACTION_SGDB_DONATE$6="Apoie-nos no Patreon";var ACTION_SGDB_TRANSLATE$6="Ajude a Traduzir";var ACTION_SGDB_BOOP$6="Veja o SGDBoop";var LABEL_RESTART_STEAM_TITLE$3="Reiniciar o Steam?";var ACTION_RESTART_STEAM_LATER$3="Mais Tarde";var ACTION_RESTART_STEAM_NOW$3="Reiniciar Agora";var MSG_RESTART_STEAM_DESC$3="O Steam precisa ser reiniciado para as alteraes terem efeito.";var LABEL_NOTES$6="Notas";var LABEL_ANIMATED$6="Animao";var LABEL_NSFW$6="Contedo Adulto";var LABEL_HUMOR$6="Humor";var LABEL_EPILEPSY$6="Epilepsia";var LABEL_GAME_SEARCH_TITLE$6="Procurar jogo...";var LABEL_FILTER_MODAL_TITLE$6="Filtro de {assetType}s";var LABEL_FILTER_GAME$6="Jogo";var LABEL_FILTER_DIMENSIONS$6="Dimenses";var LABEL_FILTER_STYLES$6="Estilos";var LABEL_FILTER_FILE_TYPES$6="Tipos de Arquivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$6="Tipos";var LABEL_FILTER_TYPE_ANIMATED$6="Animado";var LABEL_FILTER_TYPE_STATIC$6="Inerte";var LABEL_FILTER_TAGS_TITLE$6="Etiquetas";var LABEL_FILTER_TAG_NSFW$6="Contedo Adulto";var MSG_FILTER_TAG_NSFW_ENABLED$6="Verifique se no tem ningum olhando antes.";var LABEL_FILTER_TAG_HUMOR$6="Humor";var LABEL_FILTER_TAG_EPILEPSY$6="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$6="Sem Etiqueta";var ACTION_FILTER_RESET$6="Limpar Filtros";var ACTION_OPEN_FILTER$6="Filtrar";var ACTION_OPEN_OFFICIAL_ASSETS$2="{assetType} Oficial";var ACTION_ASSET_APPLY$6="Aplicar {assetType}";var MSG_GAME_SELECTED$6="Selecionou {gameName}";var MSG_ASSETS_FILTERED$6="Algumas artes podem estar ocultas devido aos filtros";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6="Selecionou {gameName} com filtros";var ACTION_HIDE_POS_GUIDES$2="Ocultar Guias";var ACTION_SHOW_OUTLINE$2="Exibir Guias";var ACTION_ADJUST_POS_SIZE$2="Ajustar Tamanho";var MSG_ASSET_APPLY_SUCCESS$6="Imagem aplicada com sucesso!";var MSG_ASSET_APPLY_ERROR$6="Houve um problema ao aplicar este recurso.";var ACTION_OPEN_DETAILS$6="Detalhes";var LABEL_ASSET_CURRENT$6="{assetType} atual";var ACTION_ASSET_CUSTOM_CLEAR$6="Limpar recurso personalizado";var ACTION_ASSET_BROWSE_LOCAL$6="Navegar pelos arquivos locais";var ACTION_ASSET_APPLY_TRANSPARENT$6="Usar recurso invisvel";var ptBr = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$6,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$3,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$6,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$6,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$6,ASSET_TYPE_HERO:ASSET_TYPE_HERO$6,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$6,ASSET_TYPE_ICON:ASSET_TYPE_ICON$6,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$6,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$6,LABEL_TAB_HERO:LABEL_TAB_HERO$6,LABEL_TAB_LOGO:LABEL_TAB_LOGO$6,LABEL_TAB_ICON:LABEL_TAB_ICON$6,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$6,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$2,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$3,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$2,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$6,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$6,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$6,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$6,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$6,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$6,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$6,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$3,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$3,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$3,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$3,LABEL_NOTES:LABEL_NOTES$6,LABEL_ANIMATED:LABEL_ANIMATED$6,LABEL_NSFW:LABEL_NSFW$6,LABEL_HUMOR:LABEL_HUMOR$6,LABEL_EPILEPSY:LABEL_EPILEPSY$6,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$6,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$6,LABEL_FILTER_GAME:LABEL_FILTER_GAME$6,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$6,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$6,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$6,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$6,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$6,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$6,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$6,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$6,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$6,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$6,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$6,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$6,ACTION_FILTER_RESET:ACTION_FILTER_RESET$6,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$6,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$2,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$6,MSG_GAME_SELECTED:MSG_GAME_SELECTED$6,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$6,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$2,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$2,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$2,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$6,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$6,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$6,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$6,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$6,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$6,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$6};

    var ptBr$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$6,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$3,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$6,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$6,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$6,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$6,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$6,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$6,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$6,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$6,
        LABEL_TAB_HERO: LABEL_TAB_HERO$6,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$6,
        LABEL_TAB_ICON: LABEL_TAB_ICON$6,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$6,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$2,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$3,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$2,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$6,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$6,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$6,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$6,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$6,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$6,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$6,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$3,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$3,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$3,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$3,
        LABEL_NOTES: LABEL_NOTES$6,
        LABEL_ANIMATED: LABEL_ANIMATED$6,
        LABEL_NSFW: LABEL_NSFW$6,
        LABEL_HUMOR: LABEL_HUMOR$6,
        LABEL_EPILEPSY: LABEL_EPILEPSY$6,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$6,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$6,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$6,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$6,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$6,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$6,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$6,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$6,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$6,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$6,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$6,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$6,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$6,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$6,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$6,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$6,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$6,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$2,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$6,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$6,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$6,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$2,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$2,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$2,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$6,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$6,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$6,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$6,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$6,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$6,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$6,
        'default': ptBr
    });

    var ACTION_SHOW_LINK_QR$5="Arat link QR";var ACTION_CHANGE_ARTWORK$5="Schimb imagine...";var ASSET_TYPE_CAPSULE$5="Capsul";var ASSET_TYPE_WIDECAPSULE$5="Capsul lat";var ASSET_TYPE_HERO$5="Erou";var ASSET_TYPE_LOGO$5="Logo";var ASSET_TYPE_ICON$5="Pictogram";var LABEL_TAB_CAPSULE$5="Capsul";var LABEL_TAB_WIDECAPSULE$5="Capsul lat";var LABEL_TAB_HERO$5="Erou";var LABEL_TAB_LOGO$5="Logo";var LABEL_TAB_ICON$5="Pictogram";var LABEL_TAB_MANAGE$5="Administreaz";var LABEL_TRANSLATION_CREDIT_TITLE$5="Traducere Romn";var LABEL_MORE_SGDB_TITLE$5="Alte legturi SteamGridDB";var ACTION_SGDB_DISCORD$5="Altur-te serverului de Discord";var ACTION_SGDB_GITHUB$5="Proiecte Open-source";var ACTION_SGDB_DONATE$5="Sprijin-ne pe Patreon";var ACTION_SGDB_TRANSLATE$5="Ajut cu traducerile";var ACTION_SGDB_BOOP$5="ncearc SGDBoop";var LABEL_NOTES$5="Notie";var LABEL_ANIMATED$5="Animaie";var LABEL_NSFW$5="Coninut pentru aduli";var LABEL_HUMOR$5="Umor";var LABEL_EPILEPSY$5="Epilepsie";var LABEL_GAME_SEARCH_TITLE$5="Caut joc";var LABEL_FILTER_MODAL_TITLE$5="Filtre selecie {assetType}";var LABEL_FILTER_GAME$5="Joc";var LABEL_FILTER_DIMENSIONS$5="Dimensiuni";var LABEL_FILTER_STYLES$5="Stiluri";var LABEL_FILTER_FILE_TYPES$5="Tipuri de fiier";var LABEL_FILTER_ANIMATION_TYPE_TITLE$5="Tipuri";var LABEL_FILTER_TYPE_ANIMATED$5="Animaie";var LABEL_FILTER_TYPE_STATIC$5="Static";var LABEL_FILTER_TAGS_TITLE$5="Etichete";var LABEL_FILTER_TAG_NSFW$5="Coninut pentru aduli";var MSG_FILTER_TAG_NSFW_ENABLED$5="Vezi sa nu fie cineva n spatele tu.";var LABEL_FILTER_TAG_HUMOR$5="Umor";var LABEL_FILTER_TAG_EPILEPSY$5="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$5="Far etichet";var ACTION_FILTER_RESET$5="Reseteaz filtre";var ACTION_OPEN_FILTER$5="Filtreaz";var ACTION_ASSET_APPLY$5="Aplic {assetType}";var MSG_GAME_SELECTED$5="{gameName} selectat";var MSG_ASSETS_FILTERED$5="Unele rezultate pot fi ascunse datorit filtrelor";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5="{gameName} selectat cu filtre";var MSG_ASSET_APPLY_SUCCESS$5="{assetType} a fost aplicat cu succes!";var MSG_ASSET_APPLY_ERROR$5="A aprut o problem n aplicarea seleiei.";var ACTION_OPEN_DETAILS$5="Detalii";var LABEL_ASSET_CURRENT$5="{assetType} activ";var ACTION_ASSET_CUSTOM_CLEAR$5="terge selecie personalizat";var ACTION_ASSET_BROWSE_LOCAL$5="Rsfoiete fiiere locale";var ACTION_ASSET_APPLY_TRANSPARENT$5="Folosete selecie invizibil";var ro = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$5,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$5,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$5,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$5,ASSET_TYPE_HERO:ASSET_TYPE_HERO$5,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$5,ASSET_TYPE_ICON:ASSET_TYPE_ICON$5,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$5,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$5,LABEL_TAB_HERO:LABEL_TAB_HERO$5,LABEL_TAB_LOGO:LABEL_TAB_LOGO$5,LABEL_TAB_ICON:LABEL_TAB_ICON$5,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$5,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$5,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$5,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$5,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$5,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$5,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$5,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$5,LABEL_NOTES:LABEL_NOTES$5,LABEL_ANIMATED:LABEL_ANIMATED$5,LABEL_NSFW:LABEL_NSFW$5,LABEL_HUMOR:LABEL_HUMOR$5,LABEL_EPILEPSY:LABEL_EPILEPSY$5,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$5,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$5,LABEL_FILTER_GAME:LABEL_FILTER_GAME$5,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$5,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$5,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$5,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$5,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$5,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$5,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$5,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$5,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$5,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$5,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$5,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$5,ACTION_FILTER_RESET:ACTION_FILTER_RESET$5,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$5,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$5,MSG_GAME_SELECTED:MSG_GAME_SELECTED$5,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$5,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$5,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$5,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$5,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$5,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$5,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$5,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$5};

    var ro$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$5,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$5,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$5,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$5,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$5,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$5,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$5,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$5,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$5,
        LABEL_TAB_HERO: LABEL_TAB_HERO$5,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$5,
        LABEL_TAB_ICON: LABEL_TAB_ICON$5,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$5,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$5,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$5,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$5,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$5,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$5,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$5,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$5,
        LABEL_NOTES: LABEL_NOTES$5,
        LABEL_ANIMATED: LABEL_ANIMATED$5,
        LABEL_NSFW: LABEL_NSFW$5,
        LABEL_HUMOR: LABEL_HUMOR$5,
        LABEL_EPILEPSY: LABEL_EPILEPSY$5,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$5,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$5,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$5,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$5,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$5,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$5,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$5,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$5,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$5,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$5,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$5,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$5,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$5,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$5,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$5,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$5,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$5,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$5,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$5,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$5,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$5,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$5,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$5,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$5,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$5,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$5,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$5,
        'default': ro
    });

    var ACTION_SHOW_LINK_QR$4=" QR ";var ACTION_CHANGE_ARTWORK$4=" ...";var ASSET_TYPE_CAPSULE$4="";var ASSET_TYPE_WIDECAPSULE$4=" ";var ASSET_TYPE_HERO$4="";var ASSET_TYPE_LOGO$4="";var ASSET_TYPE_ICON$4="";var LABEL_TAB_CAPSULE$4="";var LABEL_TAB_WIDECAPSULE$4=" ";var LABEL_TAB_HERO$4="";var LABEL_TAB_LOGO$4="";var LABEL_TAB_ICON$4="";var LABEL_TAB_MANAGE$4="";var LABEL_TRANSLATION_CREDIT_TITLE$4=" ";var LABEL_MORE_SGDB_TITLE$4="  SteamGridDB";var ACTION_SGDB_DISCORD$4="  Discord";var ACTION_SGDB_GITHUB$4="   ";var ACTION_SGDB_DONATE$4="  Patreon";var ACTION_SGDB_TRANSLATE$4="  ";var ACTION_SGDB_BOOP$4=" SGDBoop";var LABEL_NOTES$4="";var LABEL_ANIMATED$4="";var LABEL_NSFW$4=" ";var LABEL_HUMOR$4="";var LABEL_EPILEPSY$4="";var LABEL_GAME_SEARCH_TITLE$4=" ...";var LABEL_FILTER_MODAL_TITLE$4=" {assetType}";var LABEL_FILTER_GAME$4="";var LABEL_FILTER_DIMENSIONS$4="";var LABEL_FILTER_STYLES$4="";var LABEL_FILTER_FILE_TYPES$4=" ";var LABEL_FILTER_ANIMATION_TYPE_TITLE$4="";var LABEL_FILTER_TYPE_ANIMATED$4="";var LABEL_FILTER_TYPE_STATIC$4="";var LABEL_FILTER_TAGS_TITLE$4="";var LABEL_FILTER_TAG_NSFW$4=" ";var MSG_FILTER_TAG_NSFW_ENABLED$4="  .";var LABEL_FILTER_TAG_HUMOR$4="";var LABEL_FILTER_TAG_EPILEPSY$4="";var LABEL_FILTER_TAG_UNTAGGED$4=" ";var ACTION_FILTER_RESET$4=" ";var ACTION_OPEN_FILTER$4="";var ACTION_ASSET_APPLY$4=" {assetType}";var MSG_GAME_SELECTED$4=" {gameName}";var MSG_ASSETS_FILTERED$4="     - ";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4=" {gameName}  ";var MSG_ASSET_APPLY_SUCCESS$4="{assetType}  !";var MSG_ASSET_APPLY_ERROR$4="     .";var ACTION_OPEN_DETAILS$4="";var LABEL_ASSET_CURRENT$4=" {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$4="  ";var ACTION_ASSET_BROWSE_LOCAL$4="  ";var ACTION_ASSET_APPLY_TRANSPARENT$4="  ";var ru = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$4,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$4,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$4,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$4,ASSET_TYPE_HERO:ASSET_TYPE_HERO$4,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$4,ASSET_TYPE_ICON:ASSET_TYPE_ICON$4,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$4,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$4,LABEL_TAB_HERO:LABEL_TAB_HERO$4,LABEL_TAB_LOGO:LABEL_TAB_LOGO$4,LABEL_TAB_ICON:LABEL_TAB_ICON$4,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$4,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$4,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$4,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$4,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$4,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$4,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$4,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$4,LABEL_NOTES:LABEL_NOTES$4,LABEL_ANIMATED:LABEL_ANIMATED$4,LABEL_NSFW:LABEL_NSFW$4,LABEL_HUMOR:LABEL_HUMOR$4,LABEL_EPILEPSY:LABEL_EPILEPSY$4,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$4,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$4,LABEL_FILTER_GAME:LABEL_FILTER_GAME$4,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$4,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$4,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$4,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$4,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$4,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$4,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$4,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$4,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$4,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$4,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$4,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$4,ACTION_FILTER_RESET:ACTION_FILTER_RESET$4,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$4,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$4,MSG_GAME_SELECTED:MSG_GAME_SELECTED$4,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$4,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$4,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$4,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$4,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$4,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$4,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$4,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$4};

    var ru$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$4,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$4,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$4,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$4,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$4,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$4,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$4,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$4,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$4,
        LABEL_TAB_HERO: LABEL_TAB_HERO$4,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$4,
        LABEL_TAB_ICON: LABEL_TAB_ICON$4,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$4,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$4,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$4,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$4,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$4,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$4,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$4,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$4,
        LABEL_NOTES: LABEL_NOTES$4,
        LABEL_ANIMATED: LABEL_ANIMATED$4,
        LABEL_NSFW: LABEL_NSFW$4,
        LABEL_HUMOR: LABEL_HUMOR$4,
        LABEL_EPILEPSY: LABEL_EPILEPSY$4,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$4,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$4,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$4,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$4,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$4,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$4,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$4,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$4,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$4,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$4,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$4,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$4,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$4,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$4,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$4,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$4,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$4,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$4,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$4,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$4,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$4,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$4,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$4,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$4,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$4,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$4,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$4,
        'default': ru
    });

    var ACTION_SHOW_LINK_QR$3="Visa lnk till QR-kod";var ACTION_CHANGE_ARTWORK$3="ndra tryck...";var ASSET_TYPE_CAPSULE$3="Omslag";var ASSET_TYPE_WIDECAPSULE$3="Brett Omslag";var ASSET_TYPE_HERO$3="Banderoll";var ASSET_TYPE_LOGO$3="Logga";var ASSET_TYPE_ICON$3="Ikon";var LABEL_TAB_CAPSULE$3="Omslag";var LABEL_TAB_WIDECAPSULE$3="Brett Omslag";var LABEL_TAB_HERO$3="Banderoll";var LABEL_TAB_LOGO$3="Logga";var LABEL_TAB_ICON$3="Ikon";var LABEL_TAB_MANAGE$3="Hantera";var LABEL_TRANSLATION_CREDIT_TITLE$3="Svensk versttning";var LABEL_MORE_SGDB_TITLE$3="Mer SteamGridDB grejer";var ACTION_SGDB_DISCORD$3="G med i vr Discord";var ACTION_SGDB_GITHUB$3="Projekt med ppen kllkod";var ACTION_SGDB_DONATE$3="Std oss p Patreon";var ACTION_SGDB_TRANSLATE$3="Hjlp verstta";var ACTION_SGDB_BOOP$3="Kolla in SGDBoop";var LABEL_NOTES$3="Kommentar";var LABEL_ANIMATED$3="Animerad";var LABEL_NSFW$3="Vuxet innehll";var LABEL_HUMOR$3="Humor";var LABEL_EPILEPSY$3="Epilepsi";var LABEL_GAME_SEARCH_TITLE$3="Sk efter ett spel...";var LABEL_FILTER_MODAL_TITLE$3="{assetType} Filter";var LABEL_FILTER_GAME$3="Spel";var LABEL_FILTER_DIMENSIONS$3="Mtt";var LABEL_FILTER_STYLES$3="Stilar";var LABEL_FILTER_FILE_TYPES$3="Filtyper";var LABEL_FILTER_ANIMATION_TYPE_TITLE$3="Typer";var LABEL_FILTER_TYPE_ANIMATED$3="Animerad";var LABEL_FILTER_TYPE_STATIC$3="Statisk";var LABEL_FILTER_TAGS_TITLE$3="Taggar";var LABEL_FILTER_TAG_NSFW$3="Vuxet Innehll";var MSG_FILTER_TAG_NSFW_ENABLED$3="Det r nog bst att du ser dig fr.";var LABEL_FILTER_TAG_HUMOR$3="Humor";var LABEL_FILTER_TAG_EPILEPSY$3="Epilepsi";var LABEL_FILTER_TAG_UNTAGGED$3="Otaggade";var ACTION_FILTER_RESET$3="terstll filter";var ACTION_OPEN_FILTER$3="Filtrera";var ACTION_ASSET_APPLY$3="Tillmpa {assetType}";var MSG_GAME_SELECTED$3="Vald {gameName}";var MSG_ASSETS_FILTERED$3="Vissa tillgngar kan dljas p grund av filter";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3="Vald {gameName} med filter";var MSG_ASSET_APPLY_SUCCESS$3="{assetType} har tillmpats!";var MSG_ASSET_APPLY_ERROR$3="Det gick inte att tillmpa denna tillgng.";var ACTION_OPEN_DETAILS$3="Detaljer";var LABEL_ASSET_CURRENT$3="Nuvarande {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$3="Rensa egen tillgng";var ACTION_ASSET_BROWSE_LOCAL$3="Blddra efter lokala filer";var ACTION_ASSET_APPLY_TRANSPARENT$3="Anvnd osynlig tillgng";var sv = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$3,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$3,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$3,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$3,ASSET_TYPE_HERO:ASSET_TYPE_HERO$3,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$3,ASSET_TYPE_ICON:ASSET_TYPE_ICON$3,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$3,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$3,LABEL_TAB_HERO:LABEL_TAB_HERO$3,LABEL_TAB_LOGO:LABEL_TAB_LOGO$3,LABEL_TAB_ICON:LABEL_TAB_ICON$3,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$3,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$3,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$3,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$3,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$3,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$3,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$3,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$3,LABEL_NOTES:LABEL_NOTES$3,LABEL_ANIMATED:LABEL_ANIMATED$3,LABEL_NSFW:LABEL_NSFW$3,LABEL_HUMOR:LABEL_HUMOR$3,LABEL_EPILEPSY:LABEL_EPILEPSY$3,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$3,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$3,LABEL_FILTER_GAME:LABEL_FILTER_GAME$3,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$3,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$3,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$3,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$3,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$3,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$3,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$3,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$3,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$3,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$3,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$3,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$3,ACTION_FILTER_RESET:ACTION_FILTER_RESET$3,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$3,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$3,MSG_GAME_SELECTED:MSG_GAME_SELECTED$3,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$3,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$3,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$3,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$3,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$3,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$3,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$3,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$3};

    var sv$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$3,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$3,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$3,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$3,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$3,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$3,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$3,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$3,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$3,
        LABEL_TAB_HERO: LABEL_TAB_HERO$3,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$3,
        LABEL_TAB_ICON: LABEL_TAB_ICON$3,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$3,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$3,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$3,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$3,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$3,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$3,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$3,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$3,
        LABEL_NOTES: LABEL_NOTES$3,
        LABEL_ANIMATED: LABEL_ANIMATED$3,
        LABEL_NSFW: LABEL_NSFW$3,
        LABEL_HUMOR: LABEL_HUMOR$3,
        LABEL_EPILEPSY: LABEL_EPILEPSY$3,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$3,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$3,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$3,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$3,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$3,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$3,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$3,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$3,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$3,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$3,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$3,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$3,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$3,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$3,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$3,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$3,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$3,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$3,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$3,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$3,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$3,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$3,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$3,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$3,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$3,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$3,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$3,
        'default': sv
    });

    var ACTION_SHOW_LINK_QR$2="  QR";var MSG_USAGE_INSTRUCTIONS$2="  {arrow} {optionsButton} {arrow} {ACTION_CHANGE_ARTWORK}";var ACTION_CHANGE_ARTWORK$2=" ...";var ASSET_TYPE_CAPSULE$2="";var ASSET_TYPE_WIDECAPSULE$2=" ";var ASSET_TYPE_HERO$2="";var ASSET_TYPE_LOGO$2="";var ASSET_TYPE_ICON$2="";var LABEL_TAB_CAPSULE$2="";var LABEL_TAB_WIDECAPSULE$2=" ";var LABEL_TAB_HERO$2="";var LABEL_TAB_LOGO$2="";var LABEL_TAB_ICON$2="";var LABEL_TAB_MANAGE$2="";var MSG_ASSET_TAB_SETTINGS_DESC$1="    ,   ,     ,      {ACTION_CHANGE_ARTWORK}";var LABEL_USAGE_TITLE$2="  ?   ";var LABEL_SETTINGS_ASSET_TABS$1=" ";var LABEL_TRANSLATION_CREDIT_TITLE$2=" ";var LABEL_MORE_SGDB_TITLE$2="  SteamGridDB";var ACTION_SGDB_DISCORD$2="  Discord";var ACTION_SGDB_GITHUB$2="   ";var ACTION_SGDB_DONATE$2="  Patreon";var ACTION_SGDB_TRANSLATE$2="  ";var ACTION_SGDB_BOOP$2=" SGDBoop";var LABEL_RESTART_STEAM_TITLE$2=" Steam?";var ACTION_RESTART_STEAM_LATER$2="";var ACTION_RESTART_STEAM_NOW$2=" ";var MSG_RESTART_STEAM_DESC$2="  Steam,    .";var LABEL_NOTES$2="";var LABEL_ANIMATED$2="";var LABEL_NSFW$2="  ";var LABEL_HUMOR$2="";var LABEL_EPILEPSY$2="";var LABEL_GAME_SEARCH_TITLE$2=" ...";var LABEL_FILTER_MODAL_TITLE$2=" {assetType}";var LABEL_FILTER_GAME$2="";var LABEL_FILTER_DIMENSIONS$2="";var LABEL_FILTER_STYLES$2="";var LABEL_FILTER_FILE_TYPES$2=" ";var LABEL_FILTER_ANIMATION_TYPE_TITLE$2="";var LABEL_FILTER_TYPE_ANIMATED$2="";var LABEL_FILTER_TYPE_STATIC$2="";var LABEL_FILTER_TAGS_TITLE$2="";var LABEL_FILTER_TAG_NSFW$2="  ";var MSG_FILTER_TAG_NSFW_ENABLED$2="      .";var LABEL_FILTER_TAG_HUMOR$2="";var LABEL_FILTER_TAG_EPILEPSY$2="";var LABEL_FILTER_TAG_UNTAGGED$2=" ";var ACTION_FILTER_RESET$2=" ";var ACTION_OPEN_FILTER$2="";var ACTION_OPEN_OFFICIAL_ASSETS$1=" ";var ACTION_ASSET_APPLY$2=" {assetType}";var MSG_GAME_SELECTED$2=": {gameName}";var MSG_ASSETS_FILTERED$2="      ";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2=": {gameName},  ";var ACTION_HIDE_POS_GUIDES$1=" ";var ACTION_SHOW_OUTLINE$1=" ";var ACTION_ADJUST_POS_SIZE$1=" ";var MSG_ASSET_APPLY_SUCCESS$2="{assetType}  !";var MSG_ASSET_APPLY_ERROR$2="      .";var ACTION_OPEN_DETAILS$2="";var LABEL_ASSET_CURRENT$2=": {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$2="  ";var ACTION_ASSET_BROWSE_LOCAL$2="  ";var ACTION_ASSET_APPLY_TRANSPARENT$2="  ";var uk = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$2,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$2,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$2,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$2,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$2,ASSET_TYPE_HERO:ASSET_TYPE_HERO$2,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$2,ASSET_TYPE_ICON:ASSET_TYPE_ICON$2,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$2,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$2,LABEL_TAB_HERO:LABEL_TAB_HERO$2,LABEL_TAB_LOGO:LABEL_TAB_LOGO$2,LABEL_TAB_ICON:LABEL_TAB_ICON$2,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$2,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$1,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$2,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$1,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$2,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$2,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$2,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$2,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$2,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$2,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$2,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$2,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$2,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$2,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$2,LABEL_NOTES:LABEL_NOTES$2,LABEL_ANIMATED:LABEL_ANIMATED$2,LABEL_NSFW:LABEL_NSFW$2,LABEL_HUMOR:LABEL_HUMOR$2,LABEL_EPILEPSY:LABEL_EPILEPSY$2,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$2,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$2,LABEL_FILTER_GAME:LABEL_FILTER_GAME$2,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$2,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$2,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$2,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$2,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$2,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$2,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$2,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$2,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$2,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$2,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$2,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$2,ACTION_FILTER_RESET:ACTION_FILTER_RESET$2,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$2,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$1,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$2,MSG_GAME_SELECTED:MSG_GAME_SELECTED$2,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$2,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$1,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$1,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$1,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$2,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$2,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$2,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$2,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$2,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$2,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$2};

    var uk$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$2,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$2,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$2,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$2,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$2,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$2,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$2,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$2,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$2,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$2,
        LABEL_TAB_HERO: LABEL_TAB_HERO$2,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$2,
        LABEL_TAB_ICON: LABEL_TAB_ICON$2,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$2,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$1,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$2,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$1,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$2,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$2,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$2,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$2,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$2,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$2,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$2,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$2,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$2,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$2,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$2,
        LABEL_NOTES: LABEL_NOTES$2,
        LABEL_ANIMATED: LABEL_ANIMATED$2,
        LABEL_NSFW: LABEL_NSFW$2,
        LABEL_HUMOR: LABEL_HUMOR$2,
        LABEL_EPILEPSY: LABEL_EPILEPSY$2,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$2,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$2,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$2,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$2,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$2,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$2,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$2,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$2,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$2,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$2,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$2,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$2,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$2,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$2,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$2,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$2,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$2,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$1,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$2,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$2,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$2,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$1,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$1,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$1,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$2,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$2,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$2,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$2,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$2,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$2,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$2,
        'default': uk
    });

    var ACTION_SHOW_LINK_QR$1="";var MSG_USAGE_INSTRUCTIONS$1=" {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$1="...";var ASSET_TYPE_CAPSULE$1="";var ASSET_TYPE_WIDECAPSULE$1="";var ASSET_TYPE_HERO$1="";var ASSET_TYPE_LOGO$1="";var ASSET_TYPE_ICON$1="";var LABEL_TAB_CAPSULE$1="";var LABEL_TAB_WIDECAPSULE$1="";var LABEL_TAB_HERO$1="";var LABEL_TAB_LOGO$1="";var LABEL_TAB_ICON$1="";var LABEL_TAB_MANAGE$1="";var LABEL_USAGE_TITLE$1="";var LABEL_TRANSLATION_CREDIT_TITLE$1="";var LABEL_MORE_SGDB_TITLE$1=" SteamGridDB";var ACTION_SGDB_DISCORD$1=" Discord";var ACTION_SGDB_GITHUB$1="";var ACTION_SGDB_DONATE$1=" Patreon ";var ACTION_SGDB_TRANSLATE$1="";var ACTION_SGDB_BOOP$1=" SGDBoop";var LABEL_RESTART_STEAM_TITLE$1="Steam";var ACTION_RESTART_STEAM_LATER$1="";var ACTION_RESTART_STEAM_NOW$1="";var MSG_RESTART_STEAM_DESC$1="Steam ";var LABEL_NOTES$1="";var LABEL_ANIMATED$1="";var LABEL_NSFW$1="";var LABEL_HUMOR$1="";var LABEL_EPILEPSY$1="";var LABEL_GAME_SEARCH_TITLE$1="";var LABEL_FILTER_MODAL_TITLE$1="{assetType} ";var LABEL_FILTER_GAME$1="";var LABEL_FILTER_DIMENSIONS$1="";var LABEL_FILTER_STYLES$1="";var LABEL_FILTER_FILE_TYPES$1="";var LABEL_FILTER_ANIMATION_TYPE_TITLE$1="";var LABEL_FILTER_TYPE_ANIMATED$1="";var LABEL_FILTER_TYPE_STATIC$1="";var LABEL_FILTER_TAGS_TITLE$1="";var LABEL_FILTER_TAG_NSFW$1="";var MSG_FILTER_TAG_NSFW_ENABLED$1="";var LABEL_FILTER_TAG_HUMOR$1="";var LABEL_FILTER_TAG_EPILEPSY$1="";var LABEL_FILTER_TAG_UNTAGGED$1="";var ACTION_FILTER_RESET$1="";var ACTION_OPEN_FILTER$1="";var ACTION_ASSET_APPLY$1=" {assetType}";var MSG_GAME_SELECTED$1=" {gameName}";var MSG_ASSETS_FILTERED$1="";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1=" {gameName}";var MSG_ASSET_APPLY_SUCCESS$1=" {assetType} ";var MSG_ASSET_APPLY_ERROR$1="";var ACTION_OPEN_DETAILS$1="";var LABEL_ASSET_CURRENT$1=" {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$1="";var ACTION_ASSET_BROWSE_LOCAL$1="";var ACTION_ASSET_APPLY_TRANSPARENT$1="";var zhCn = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$1,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$1,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$1,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$1,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$1,ASSET_TYPE_HERO:ASSET_TYPE_HERO$1,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$1,ASSET_TYPE_ICON:ASSET_TYPE_ICON$1,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$1,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$1,LABEL_TAB_HERO:LABEL_TAB_HERO$1,LABEL_TAB_LOGO:LABEL_TAB_LOGO$1,LABEL_TAB_ICON:LABEL_TAB_ICON$1,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$1,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$1,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$1,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$1,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$1,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$1,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$1,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$1,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$1,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$1,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$1,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$1,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$1,LABEL_NOTES:LABEL_NOTES$1,LABEL_ANIMATED:LABEL_ANIMATED$1,LABEL_NSFW:LABEL_NSFW$1,LABEL_HUMOR:LABEL_HUMOR$1,LABEL_EPILEPSY:LABEL_EPILEPSY$1,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$1,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$1,LABEL_FILTER_GAME:LABEL_FILTER_GAME$1,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$1,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$1,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$1,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$1,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$1,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$1,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$1,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$1,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$1,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$1,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$1,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$1,ACTION_FILTER_RESET:ACTION_FILTER_RESET$1,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$1,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$1,MSG_GAME_SELECTED:MSG_GAME_SELECTED$1,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$1,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$1,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$1,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$1,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$1,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$1,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$1,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$1};

    var zhCn$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$1,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$1,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$1,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$1,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$1,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO$1,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$1,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON$1,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$1,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$1,
        LABEL_TAB_HERO: LABEL_TAB_HERO$1,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO$1,
        LABEL_TAB_ICON: LABEL_TAB_ICON$1,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$1,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$1,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$1,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$1,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$1,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$1,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$1,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$1,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$1,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$1,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$1,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$1,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$1,
        LABEL_NOTES: LABEL_NOTES$1,
        LABEL_ANIMATED: LABEL_ANIMATED$1,
        LABEL_NSFW: LABEL_NSFW$1,
        LABEL_HUMOR: LABEL_HUMOR$1,
        LABEL_EPILEPSY: LABEL_EPILEPSY$1,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$1,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$1,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME$1,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$1,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$1,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$1,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$1,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$1,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$1,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$1,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$1,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$1,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$1,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$1,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$1,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET$1,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$1,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$1,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED$1,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$1,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$1,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$1,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$1,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$1,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$1,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$1,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$1,
        'default': zhCn
    });

    var ACTION_SHOW_LINK_QR=" QR Code";var MSG_USAGE_INSTRUCTIONS=" {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK="...";var ASSET_TYPE_CAPSULE="";var ASSET_TYPE_WIDECAPSULE="";var ASSET_TYPE_HERO="";var ASSET_TYPE_LOGO="";var ASSET_TYPE_ICON="";var LABEL_TAB_CAPSULE="";var LABEL_TAB_WIDECAPSULE="";var LABEL_TAB_HERO="";var LABEL_TAB_LOGO="";var LABEL_TAB_ICON="";var LABEL_TAB_MANAGE="";var MSG_ASSET_TAB_SETTINGS_DESC="{ACTION_CHANGE_ARTWORK}";var LABEL_USAGE_TITLE="";var LABEL_SETTINGS_ASSET_TABS="";var LABEL_TRANSLATION_CREDIT_TITLE="";var LABEL_MORE_SGDB_TITLE=" SteamGridDB";var ACTION_SGDB_DISCORD=" Discord";var ACTION_SGDB_GITHUB="";var ACTION_SGDB_DONATE=" Patreon ";var ACTION_SGDB_TRANSLATE="";var ACTION_SGDB_BOOP=" SGDBoop";var LABEL_RESTART_STEAM_TITLE=" Steam";var ACTION_RESTART_STEAM_LATER="";var ACTION_RESTART_STEAM_NOW="";var MSG_RESTART_STEAM_DESC=" Steam ";var LABEL_NOTES="";var LABEL_ANIMATED="";var LABEL_NSFW="";var LABEL_HUMOR="";var LABEL_EPILEPSY="";var LABEL_GAME_SEARCH_TITLE="...";var LABEL_FILTER_MODAL_TITLE="{assetType} ";var LABEL_FILTER_GAME="";var LABEL_FILTER_DIMENSIONS="";var LABEL_FILTER_STYLES="";var LABEL_FILTER_FILE_TYPES="";var LABEL_FILTER_ANIMATION_TYPE_TITLE="";var LABEL_FILTER_TYPE_ANIMATED="";var LABEL_FILTER_TYPE_STATIC="";var LABEL_FILTER_TAGS_TITLE="";var LABEL_FILTER_TAG_NSFW="";var MSG_FILTER_TAG_NSFW_ENABLED="";var LABEL_FILTER_TAG_HUMOR="";var LABEL_FILTER_TAG_EPILEPSY="";var LABEL_FILTER_TAG_UNTAGGED="";var ACTION_FILTER_RESET="";var ACTION_OPEN_FILTER="";var ACTION_OPEN_OFFICIAL_ASSETS=" {assetType}";var ACTION_ASSET_APPLY=" {assetType}";var MSG_GAME_SELECTED=" {gameName}";var MSG_ASSETS_FILTERED="";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED=" {gameName} ";var ACTION_HIDE_POS_GUIDES="";var ACTION_SHOW_OUTLINE="";var ACTION_ADJUST_POS_SIZE="";var MSG_ASSET_APPLY_SUCCESS=" {assetType}";var MSG_ASSET_APPLY_ERROR="";var ACTION_OPEN_DETAILS="";var LABEL_ASSET_CURRENT=" {assetType}";var ACTION_ASSET_CUSTOM_CLEAR="";var ACTION_ASSET_BROWSE_LOCAL="";var ACTION_ASSET_APPLY_TRANSPARENT="";var zhTw = {ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK,ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE,ASSET_TYPE_HERO:ASSET_TYPE_HERO,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO,ASSET_TYPE_ICON:ASSET_TYPE_ICON,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE,LABEL_TAB_HERO:LABEL_TAB_HERO,LABEL_TAB_LOGO:LABEL_TAB_LOGO,LABEL_TAB_ICON:LABEL_TAB_ICON,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC,LABEL_NOTES:LABEL_NOTES,LABEL_ANIMATED:LABEL_ANIMATED,LABEL_NSFW:LABEL_NSFW,LABEL_HUMOR:LABEL_HUMOR,LABEL_EPILEPSY:LABEL_EPILEPSY,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE,LABEL_FILTER_GAME:LABEL_FILTER_GAME,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED,ACTION_FILTER_RESET:ACTION_FILTER_RESET,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY,MSG_GAME_SELECTED:MSG_GAME_SELECTED,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT};

    var zhTw$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR,
        MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS,
        ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK,
        ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE,
        ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE,
        ASSET_TYPE_HERO: ASSET_TYPE_HERO,
        ASSET_TYPE_LOGO: ASSET_TYPE_LOGO,
        ASSET_TYPE_ICON: ASSET_TYPE_ICON,
        LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE,
        LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE,
        LABEL_TAB_HERO: LABEL_TAB_HERO,
        LABEL_TAB_LOGO: LABEL_TAB_LOGO,
        LABEL_TAB_ICON: LABEL_TAB_ICON,
        LABEL_TAB_MANAGE: LABEL_TAB_MANAGE,
        MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC,
        LABEL_USAGE_TITLE: LABEL_USAGE_TITLE,
        LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS,
        LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE,
        LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE,
        ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD,
        ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB,
        ACTION_SGDB_DONATE: ACTION_SGDB_DONATE,
        ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE,
        ACTION_SGDB_BOOP: ACTION_SGDB_BOOP,
        LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE,
        ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER,
        ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW,
        MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC,
        LABEL_NOTES: LABEL_NOTES,
        LABEL_ANIMATED: LABEL_ANIMATED,
        LABEL_NSFW: LABEL_NSFW,
        LABEL_HUMOR: LABEL_HUMOR,
        LABEL_EPILEPSY: LABEL_EPILEPSY,
        LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE,
        LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE,
        LABEL_FILTER_GAME: LABEL_FILTER_GAME,
        LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS,
        LABEL_FILTER_STYLES: LABEL_FILTER_STYLES,
        LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES,
        LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE,
        LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED,
        LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC,
        LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE,
        LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW,
        MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED,
        LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR,
        LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY,
        LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED,
        ACTION_FILTER_RESET: ACTION_FILTER_RESET,
        ACTION_OPEN_FILTER: ACTION_OPEN_FILTER,
        ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS,
        ACTION_ASSET_APPLY: ACTION_ASSET_APPLY,
        MSG_GAME_SELECTED: MSG_GAME_SELECTED,
        MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED,
        MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED,
        ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES,
        ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE,
        ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE,
        MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS,
        MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR,
        ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS,
        LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT,
        ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR,
        ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL,
        ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT,
        'default': zhTw
    });

    const simplifiedChinese = {
        name: '',
        strings: zhCn$1,
        credit: ['zhzy0077'],
    };
    const LANGS$1 = {
        cs: {
            name: 'etina',
            strings: cs$1,
            credit: ['zenobit'],
        },
        de: {
            name: 'Deutsch',
            strings: de$1,
            credit: ['Kurikuo', 'benutzer_artur7', 'Anja'],
        },
        el: {
            name: '',
            strings: el$1,
            credit: ['Emenesu'],
        },
        es: {
            name: 'Espaol-Espaa',
            strings: es$1,
            credit: ['Andrea Laguillo', 'Kam', 'm0uch0'],
        },
        'es-419': {
            name: 'Espaol-Latinoamrica',
            strings: es419$1,
            credit: ['Kam'],
        },
        fr: {
            name: 'Franais',
            strings: fr$1,
            credit: ['Michael Jean'],
        },
        it: {
            name: 'Italiano',
            strings: it$1,
            credit: ['SpagottoB37'],
        },
        ja: {
            name: '',
            strings: ja$1,
            credit: ['Nes'],
        },
        ko: {
            name: '',
            strings: ko$1,
            credit: ['yor42'],
        },
        nl: {
            name: 'Nederlands',
            strings: nl$1,
            credit: ['Phanpy100 (Fanny)', 'Jannes Verlinde'],
        },
        pl: {
            name: 'Polski',
            strings: pl$1,
            credit: ['DRS', 'Micha Kwiatkowski'],
        },
        pt: {
            name: 'Portugus',
            strings: pt$1,
            credit: ['Kokasgui'],
        },
        'pt-br': {
            name: 'Portugus-Brasil',
            strings: ptBr$1,
            credit: ['Oregano', 'Thomas Eric'],
        },
        ro: {
            name: 'Romn',
            strings: ro$1,
            credit: ['Munt'],
        },
        ru: {
            name: '',
            strings: ru$1,
            credit: ['fycher'],
        },
        sv: {
            name: 'Svenska',
            strings: sv$1,
            credit: ['Moneyman Dan'],
        },
        uk: {
            name: '',
            strings: uk$1,
            credit: ['Veydzher'],
        },
        'zh-cn': simplifiedChinese,
        'sc-sc': simplifiedChinese,
        'zh-tw': {
            name: '',
            strings: zhTw$1,
            credit: ['mingyc']
        },
        //  th: {
        //    name: '',
        //    strings: th,
        //    credit: []
        //  },
        //  da: {
        //    name: 'Dansk',
        //    strings: da,
        //    credit: []
        //  },
        //  fi: {
        //    name: 'Suomi',
        //    strings: fi,
        //    credit: []
        //  },
        //  no: {
        //    name: 'Norsk',
        //    strings: no,
        //    credit: []
        //  },
        //  hu: {
        //    name: 'Magyar',
        //    strings: hu,
        //    credit: []
        //  },
        //  tr: {
        //    name: 'Trke',
        //    strings: tr,
        //    credit: []
        //  },
        //  bg: {
        //    name: ' ',
        //    strings: bg,
        //    credit: []
        //  },
        //  en: {
        //    name: 'English',
        //    strings: en,
        //    credit: []
        //  }
        //  vn: {
        //    name: 'Ting Vit',
        //    strings: vn,
        //    credit: []
        //  },
    };
    let cachedLang;
    const getCurrentLanguage = () => {
        if (cachedLang)
            return cachedLang;
        const lang = window.LocalizationManager.m_rgLocalesToUse[0];
        cachedLang = lang;
        return lang;
    };
    const getCredits = (lang) => {
        if (lang)
            return LANGS$1[lang]?.credit;
        return LANGS$1[getCurrentLanguage()]?.credit;
    };
    /**
     * Very basic translation cause theres like 20 strings and i don't need anything more complex.
     *
     * @param {string} key Locale key
     * @param {string} originalString Original text
     * @param {boolean} steamToken If true, uses the key to query Steams token store.
     *    Good for actions like "Back" or "Cancel". Won't be dumped with the rest of the strings.
     *
     * @example
     * t('TITLE_FILTER_MODAL', 'Asset Filters')
     * @example
     * // if you need variables use .replace()
     * t('ACTION_REMOVE_GAME', 'Delete {gameName}').replaceAll('{gameName}', gameName)
     * @example
     * // Original Steam string
     * t('Button_Back', 'Back', true);
     */
    const trans_string = (key, originalString, steamToken = false) => {
        const lang = getCurrentLanguage();
        if (steamToken) {
            return window.LocalizationManager.m_mapTokens.get(key) ?? window.LocalizationManager.m_mapFallbackTokens.get(key) ?? originalString;
        }
        if (lang === 'en')
            return originalString;
        return LANGS$1[lang]?.strings?.[key] ?? originalString;
    };

    const navLink = (url) => {
        Navigation.CloseSideMenus();
        Navigation.NavigateToExternalWeb(url);
    };
    /**
     * Panel row with a button next to an icon.
     */
    const PanelSocialButton = ({ icon, children, url }) => (window.SP_REACT.createElement(PanelSectionRow, null,
        window.SP_REACT.createElement(Field, { bottomSeparator: "none", icon: null, label: null, childrenLayout: undefined, inlineWrap: "keep-inline", padding: "none", spacingBetweenLabelAndChild: "none", childrenContainerWidth: "max" },
            window.SP_REACT.createElement(Focusable, { style: { display: 'flex' } },
                window.SP_REACT.createElement("div", { style: {
                        display: 'flex',
                        fontSize: '1.5em',
                        justifyContent: 'center',
                        alignItems: 'center',
                        marginRight: '.5em',
                    } }, icon),
                window.SP_REACT.createElement(DialogButton, { onClick: () => navLink(url), onSecondaryButton: () => showQrModal(url), onSecondaryActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), style: {
                        padding: '10px',
                        fontSize: '14px',
                    } }, children),
                window.SP_REACT.createElement(DialogButton, { onOKActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), onClick: () => showQrModal(url), style: {
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        padding: '10px',
                        maxWidth: '40px',
                        minWidth: 'auto',
                        marginLeft: '.5em',
                    } },
                    window.SP_REACT.createElement(HiQrCode, null))))));

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    /* eslint-disable vars-on-top, no-var, prefer-template */

    var isRegExp = function (re) { 
      return re instanceof RegExp;
    };
    var escapeRegExp = function escapeRegExp(string) {
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);

      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    };
    var isString$1 = function (value) {
      return typeof value === 'string';
    };
    var flatten = function (array) {
      var newArray = [];

      array.forEach(function (item) {
        if (Array.isArray(item)) {
          newArray = newArray.concat(item);
        } else {
          newArray.push(item);
        }
      });

      return newArray;
    };

    /**
     * Given a string, replace every substring that is matched by the `match` regex
     * with the result of calling `fn` on matched substring. The result will be an
     * array with all odd indexed elements containing the replacements. The primary
     * use case is similar to using String.prototype.replace except for React.
     *
     * React will happily render an array as children of a react element, which
     * makes this approach very useful for tasks like surrounding certain text
     * within a string with react elements.
     *
     * Example:
     * matchReplace(
     *   'Emphasize all phone numbers like 884-555-4443.',
     *   /([\d|-]+)/g,
     *   (number, i) => <strong key={i}>{number}</strong>
     * );
     * // => ['Emphasize all phone numbers like ', <strong>884-555-4443</strong>, '.'
     *
     * @param {string} str
     * @param {RegExp|str} match Must contain a matching group
     * @param {function} fn
     * @return {array}
     */
    function replaceString(str, match, fn) {
      var curCharStart = 0;
      var curCharLen = 0;

      if (str === '') {
        return str;
      } else if (!str || !isString$1(str)) {
        throw new TypeError('First argument to react-string-replace#replaceString must be a string');
      }

      var re = match;

      if (!isRegExp(re)) {
        re = new RegExp('(' + escapeRegExp(re) + ')', 'gi');
      }

      var result = str.split(re);

      // Apply fn to all odd elements
      for (var i = 1, length = result.length; i < length; i += 2) {
        /** @see {@link https://github.com/iansinnott/react-string-replace/issues/74} */
        if (result[i] === undefined || result[i - 1] === undefined) {
          console.warn('reactStringReplace: Encountered undefined value during string replacement. Your RegExp may not be working the way you expect.');
          continue;
        }

        curCharLen = result[i].length;
        curCharStart += result[i - 1].length;
        result[i] = fn(result[i], i, curCharStart);
        curCharStart += curCharLen;
      }

      return result;
    }

    var reactStringReplace = function reactStringReplace(source, match, fn) {
      if (!Array.isArray(source)) source = [source];

      return flatten(source.map(function(x) {
        return isString$1(x) ? replaceString(x, match, fn) : x;
      }));
    };

    var HowToVideo = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/howto-24bc522f.webm';

    var FooterGlyphType;
    (function (FooterGlyphType) {
        FooterGlyphType[FooterGlyphType["Knockout"] = 0] = "Knockout";
        FooterGlyphType[FooterGlyphType["Light"] = 1] = "Light";
        FooterGlyphType[FooterGlyphType["Dark"] = 2] = "Dark";
    })(FooterGlyphType || (FooterGlyphType = {}));
    var FooterGlyphSize;
    (function (FooterGlyphSize) {
        FooterGlyphSize[FooterGlyphSize["Small"] = 0] = "Small";
        FooterGlyphSize[FooterGlyphSize["Medium"] = 1] = "Medium";
        FooterGlyphSize[FooterGlyphSize["Large"] = 2] = "Large";
    })(FooterGlyphSize || (FooterGlyphSize = {}));
    const FooterGlyph = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (m[prop]?.toString && m[prop].toString().includes('.Knockout') && m[prop].toString().includes('.additionalClassName')) {
                return m[prop];
            }
        }
        return;
    });

    const strInstructions = trans_string('MSG_USAGE_INSTRUCTIONS', 'Select a game {arrow} {optionsButton} {arrow} "{ACTION_CHANGE_ARTWORK}"')
        .replace('{ACTION_CHANGE_ARTWORK}', trans_string('ACTION_CHANGE_ARTWORK', 'Change artwork...'));
    const changeInstructions = reactStringReplace(reactStringReplace(strInstructions, '{arrow}', (_, i) => (window.SP_REACT.createElement(HiOutlineChevronRight, { key: i, strokeWidth: "4", style: { height: '0.65em' } }))), '{optionsButton}', (_, i) => (window.SP_REACT.createElement(FooterGlyph, { key: i, button: 11, type: 0, size: 0 })));
    const GuideVideoField = (props) => {
        const [duration, setDuration] = React.useState(0);
        const [progress, setProgress] = React.useState(0);
        const handlePlay = (evt) => {
            const target = evt.target;
            setDuration(target.duration);
            setProgress(100);
        };
        const handleEnded = (evt) => {
            const target = evt.target;
            setDuration(0.4);
            setProgress(0);
            // replay after .5s
            setTimeout(() => {
                target.play();
            }, 500);
        };
        return (window.SP_REACT.createElement(Field, { padding: "none", childrenLayout: "below", childrenContainerWidth: "max", bottomSeparator: "none", description: window.SP_REACT.createElement("div", { style: {
                    display: 'flex',
                    alignItems: 'center',
                    flexWrap: 'wrap',
                } }, changeInstructions), ...props },
            window.SP_REACT.createElement("video", { src: HowToVideo, style: { maxWidth: '100%' }, autoPlay: true, muted: true, loop: false, onPlay: handlePlay, onEnded: handleEnded }),
            window.SP_REACT.createElement(ProgressBar, { focusable: false, nProgress: progress, nTransitionSec: duration })));
    };

    var global$1 = (typeof global !== "undefined" ? global :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var propTypes$1 = {exports: {}};

    var reactIs_production_min$1 = {};

    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$2="function"===typeof Symbol&&Symbol.for,c$3=b$2?Symbol.for("react.element"):60103,d$2=b$2?Symbol.for("react.portal"):60106,e$3=b$2?Symbol.for("react.fragment"):60107,f$2=b$2?Symbol.for("react.strict_mode"):60108,g$2=b$2?Symbol.for("react.profiler"):60114,h$2=b$2?Symbol.for("react.provider"):60109,k$2=b$2?Symbol.for("react.context"):60110,l$3=b$2?Symbol.for("react.async_mode"):60111,m$2=b$2?Symbol.for("react.concurrent_mode"):60111,n$2=b$2?Symbol.for("react.forward_ref"):60112,p$2=b$2?Symbol.for("react.suspense"):60113,q$1=b$2?
    Symbol.for("react.suspense_list"):60120,r$1=b$2?Symbol.for("react.memo"):60115,t$3=b$2?Symbol.for("react.lazy"):60116,v$2=b$2?Symbol.for("react.block"):60121,w$1=b$2?Symbol.for("react.fundamental"):60117,x$1=b$2?Symbol.for("react.responder"):60118,y$1=b$2?Symbol.for("react.scope"):60119;
    function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$3:switch(a=a.type,a){case l$3:case m$2:case e$3:case g$2:case f$2:case p$2:return a;default:switch(a=a&&a.$$typeof,a){case k$2:case n$2:case t$3:case r$1:case h$2:return a;default:return u}}case d$2:return u}}}function A(a){return z(a)===m$2}reactIs_production_min$1.AsyncMode=l$3;reactIs_production_min$1.ConcurrentMode=m$2;reactIs_production_min$1.ContextConsumer=k$2;reactIs_production_min$1.ContextProvider=h$2;reactIs_production_min$1.Element=c$3;reactIs_production_min$1.ForwardRef=n$2;reactIs_production_min$1.Fragment=e$3;reactIs_production_min$1.Lazy=t$3;reactIs_production_min$1.Memo=r$1;reactIs_production_min$1.Portal=d$2;
    reactIs_production_min$1.Profiler=g$2;reactIs_production_min$1.StrictMode=f$2;reactIs_production_min$1.Suspense=p$2;reactIs_production_min$1.isAsyncMode=function(a){return A(a)||z(a)===l$3};reactIs_production_min$1.isConcurrentMode=A;reactIs_production_min$1.isContextConsumer=function(a){return z(a)===k$2};reactIs_production_min$1.isContextProvider=function(a){return z(a)===h$2};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$3};reactIs_production_min$1.isForwardRef=function(a){return z(a)===n$2};reactIs_production_min$1.isFragment=function(a){return z(a)===e$3};reactIs_production_min$1.isLazy=function(a){return z(a)===t$3};
    reactIs_production_min$1.isMemo=function(a){return z(a)===r$1};reactIs_production_min$1.isPortal=function(a){return z(a)===d$2};reactIs_production_min$1.isProfiler=function(a){return z(a)===g$2};reactIs_production_min$1.isStrictMode=function(a){return z(a)===f$2};reactIs_production_min$1.isSuspense=function(a){return z(a)===p$2};
    reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e$3||a===m$2||a===g$2||a===f$2||a===p$2||a===q$1||"object"===typeof a&&null!==a&&(a.$$typeof===t$3||a.$$typeof===r$1||a.$$typeof===h$2||a.$$typeof===k$2||a.$$typeof===n$2||a.$$typeof===w$1||a.$$typeof===x$1||a.$$typeof===y$1||a.$$typeof===v$2)};reactIs_production_min$1.typeOf=z;

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var ReactPropTypesSecret = ReactPropTypesSecret_1;

    function emptyFunction() {}
    function emptyFunctionWithReset() {}
    emptyFunctionWithReset.resetWarningCache = emptyFunction;

    var factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          // It is still safe when called from React.
          return;
        }
        var err = new Error(
          'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
          'Use PropTypes.checkPropTypes() to call them. ' +
          'Read more at http://fb.me/use-check-prop-types'
        );
        err.name = 'Invariant Violation';
        throw err;
      }  shim.isRequired = shim;
      function getShim() {
        return shim;
      }  // Important!
      // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,

        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,

        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };

      ReactPropTypes.PropTypes = ReactPropTypes;

      return ReactPropTypes;
    };

    {
      // By explicitly using `prop-types` you are opting into new production behavior.
      // http://fb.me/prop-types-in-prod
      propTypes$1.exports = factoryWithThrowingShims();
    }

    var PropTypes = propTypes$1.exports;

    var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t$2=function(r){return "string"==typeof r?r.length>0:"number"==typeof r},n$1=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e$2=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u$1=function(r){return (r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return {r:e$2(r.r,0,255),g:e$2(r.g,0,255),b:e$2(r.b,0,255),a:e$2(r.a)}},o$1=function(r){return {r:n$1(r.r),g:n$1(r.g),b:n$1(r.b),a:n$1(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h$1=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return {h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b$1=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return {r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g$1=function(r){return {h:u$1(r.h),s:e$2(r.s,0,100),l:e$2(r.l,0,100),a:e$2(r.a)}},d$1=function(r){return {h:n$1(r.h),s:n$1(r.s),l:n$1(r.l),a:n$1(r.a,3)}},f$1=function(r){return b$1((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e;},c$2=function(r){return {h:(t=h$1(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u;},l$2=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n$1(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n$1(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v$1.exec(r)||m$1.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l$2.exec(t)||p$1.exec(t);if(!n)return null;var e,u,a=g$1({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f$1(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t$2(n)&&t$2(e)&&t$2(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t$2(n)||!t$2(e)||!t$2(u))return null;var i=g$1({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f$1(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t$2(n)||!t$2(a)||!t$2(o))return null;var h=function(r){return {h:u$1(r.h),s:e$2(r.s,0,100),v:e$2(r.v,0,100),a:e$2(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b$1(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return [e,t[n][1]]}return [null,void 0]},x=function(r){return "string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=c$2(r);return {h:n.h,s:e$2(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return (299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c$2(r);return {h:n.h,s:n.s,l:e$2(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1};}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n$1(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o$1(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n$1(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i;},r.prototype.toRgb=function(){return o$1(this.rgba)},r.prototype.toRgbString=function(){return r=o$1(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u;},r.prototype.toHsl=function(){return d$1(c$2(this.rgba))},r.prototype.toHslString=function(){return r=d$1(c$2(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u;},r.prototype.toHsv=function(){return r=h$1(this.rgba),{h:n$1(r.h),s:n$1(r.s),v:n$1(r.v),a:n$1(r.a,3)};var r;},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r;},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return "number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n$1(this.rgba.a,3);var t;},r.prototype.hue=function(r){var t=c$2(this.rgba);return "number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n$1(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S$1=[],k$1=function(r){r.forEach(function(r){S$1.indexOf(r)<0&&(r(j,y),S$1.push(r));});};

    function namesPlugin(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return "transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g);}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"]);}

    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$1 = freeGlobal || freeSelf || Function('return this')();

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /** Built-in value references. */
    var Symbol$1 = root$1.Symbol;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$1(value) {
      return value == null ? '' : baseToString(value);
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString$1(prefix) + id;
    }

    var lodash_uniqueid = uniqueId;

    var glyphs = {
      '3d': /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M18 14.625V3.375L9 0 0 3.375v11.25L9 18l9-3.375zM9 2.136l5.918 2.22-5.98 2.242-5.919-2.22L9 2.137zM2 13.239V5.065l6.438 2.414v8.174L2 13.24zM9.438 15.7L16 13.239V5.018l-6.563 2.46V15.7z",
        transform: "translate(15 10)",
        fillRule: "evenodd"
      }),
      acrobat: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M10.15 1.095C9.938.33 9.42-.051 8.984.005c-.528.068-1.09.382-1.314.876-.63 1.416.685 5.582.887 6.279-1.28 3.863-5.66 11.5-7.806 12.017-.045-.505.225-1.965 3.055-3.785.146-.157.315-.348.393-.472-2.392 1.168-5.492 3.044-3.628 4.448.102.079.259.146.439.213 1.426.528 3.425-1.201 5.435-5.121 2.213-.73 3.999-1.28 6.526-1.662 2.762 1.875 4.616 2.257 5.874 1.774.348-.135.898-.573 1.055-1.145-1.022 1.258-3.414.382-5.323-.82 1.763-.191 3.582-.303 4.369-.056 1 .314.965.808.954.876.079-.27.191-.708-.022-1.056-.842-1.37-4.706-.573-6.11-.427-2.212-1.336-3.74-3.717-4.358-5.436.573-2.212 1.19-3.818.742-5.413zm-.954 4.638C8.826 4.42 8.309 1.5 9.14.556c1.628.932.618 3.144.056 5.177zm3.044 6.514c-2.134.393-3.583.944-5.66 1.764.617-1.202 1.785-4.268 2.346-6.29.787 1.573 1.741 3.111 3.314 4.526z",
        transform: "translate(14 9)",
        fillRule: "evenodd"
      }),
      audio: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M.25 4.75v4.5h3L7 13V1L3.25 4.75h-3zM10.375 7A3.375 3.375 0 0 0 8.5 3.977v6.037A3.355 3.355 0 0 0 10.375 7zM8.5.421v1.545A5.254 5.254 0 0 1 12.25 7a5.254 5.254 0 0 1-3.75 5.032v1.545A6.747 6.747 0 0 0 13.75 7 6.747 6.747 0 0 0 8.5.421z",
        transform: "translate(17 12)",
        fillRule: "evenodd"
      }),
      binary: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M2.338 6.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504C1.274.928.538 2 .538 3.608c0 1.56.576 2.504 1.8 2.504zM1.61 3.408c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zM2.418 5.2c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568zm7.03.8l.088-.944H8.36V.896L7.272.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zm5.199 0l.088-.944h-1.176V.896L12.47.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zM4.25 14l.088-.944H3.162v-4.16l-1.088.088v.592L.89 9.688l.024.824h1.16v2.544H.754V14zm5.198 0l.088-.944H8.36v-4.16l-1.088.088v.592l-1.184.112.024.824h1.16v2.544h-1.32V14zm3.287.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504-1.192 0-1.928 1.072-1.928 2.68 0 1.56.576 2.504 1.8 2.504zm-.728-2.704c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zm.808 1.792c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568z",
        transform: "translate(16 11)",
        fillRule: "evenodd"
      }),
      code: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M4.078 13.67c-1.875-.527-2.812-1.738-2.812-3.634V9.49C1.266 8.437.844 7.911 0 7.911V6.138c.844 0 1.266-.529 1.266-1.586v-.64c.015-.938.257-1.696.726-2.274C2.466 1.06 3.162.64 4.078.38l.492 1.375c-.656.25-.997.95-1.023 2.102v.695c0 1.167-.482 1.99-1.445 2.469.963.479 1.445 1.304 1.445 2.476v.688c.026 1.15.367 1.851 1.023 2.101l-.492 1.383zm7.844 0c1.875-.527 2.812-1.738 2.812-3.634V9.49c0-1.052.422-1.578 1.266-1.578V6.138c-.844 0-1.266-.529-1.266-1.586v-.64c-.015-.938-.257-1.696-.726-2.274-.474-.578-1.17-.998-2.086-1.258l-.492 1.375c.656.25.997.95 1.023 2.102v.695c0 1.167.482 1.99 1.445 2.469-.963.479-1.445 1.304-1.445 2.476v.688c-.026 1.15-.367 1.851-1.023 2.101l.492 1.383z",
        transform: "translate(16 13)",
        fillRule: "evenodd"
      }),
      code2: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M7.4 10.6L2.8 6l4.6-4.6L6 0 0 6l6 6 1.4-1.4zm5.2 0L17.2 6l-4.6-4.6L14 0l6 6-6 6-1.4-1.4z",
        transform: "translate(14 14)",
        fillRule: "evenodd"
      }),
      compressed: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M.25 0A.25.25 0 0 0 0 .25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 1.75V.25A.25.25 0 0 0 1.75 0H.25zM1 17a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H1zm0 4v3h2v-3H1zM2 2.25A.25.25 0 0 1 2.25 2h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 3.75v-1.5zM.25 4a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 5.75v-1.5A.25.25 0 0 0 1.75 4H.25zM2 6.25A.25.25 0 0 1 2.25 6h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 7.75v-1.5zM.25 8a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 9.75v-1.5A.25.25 0 0 0 1.75 8H.25zM2 10.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5zM.25 12a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5a.25.25 0 0 0 .25-.25v-1.5a.25.25 0 0 0-.25-.25H.25zM2 14.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5z",
        transform: "translate(15 1)",
        fillRule: "evenodd"
      }),
      document: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M12 4H0v2h12V4zM0 10h18V8H0v2zM0 0v2h18V0H0z",
        transform: "translate(15 15)",
        fillRule: "evenodd"
      }),
      drive: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M2.199.289A.5.5 0 0 1 2.652 0h8.696a.5.5 0 0 1 .453.289l1.867 4a.5.5 0 0 1-.453.711H.785a.5.5 0 0 1-.453-.711l1.867-4zM13 6H1a.752.752 0 0 0-.75.75v4.5c0 .412.338.75.75.75h12c.412 0 .75-.338.75-.75v-4.5A.752.752 0 0 0 13 6zm-9.75 4.5c-.825 0-1.5-.675-1.5-1.5s.675-1.5 1.5-1.5 1.5.675 1.5 1.5-.675 1.5-1.5 1.5z",
        transform: "translate(17 13)",
        fillRule: "evenodd"
      }),
      font: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M3.722 8.702l-.686 1.89c-.053.14-.094.28-.123.421-.03.135-.044.252-.044.352 0 .304.097.527.29.668.2.14.501.21.905.21h.414V13H.083v-.756h.343c.176 0 .325-.018.448-.053a.81.81 0 0 0 .334-.22c.1-.105.193-.249.281-.43.094-.182.197-.416.308-.704L5.787.15h1.406l4.07 11.136c.07.187.14.343.21.466.077.123.165.222.264.298.1.07.214.12.343.15.129.03.281.044.457.044h.237V13H7.826v-.756h.413c.72 0 1.081-.287 1.081-.862 0-.1-.014-.202-.044-.307a3.274 3.274 0 0 0-.105-.36l-.72-2.013H3.72zM7.009 4.65c-.188-.533-.36-1.031-.519-1.494a15.92 15.92 0 0 1-.378-1.354 7.12 7.12 0 0 1-.15.633 16.95 16.95 0 0 1-.395 1.283c-.082.229-.175.484-.28.765L4.063 7.796h4.061L7.009 4.65zm8.411 5.74c0 .562.117.984.351 1.265.24.275.61.413 1.108.413.363 0 .691-.059.984-.176.3-.117.551-.284.756-.5.211-.218.372-.481.483-.792.112-.31.168-.656.168-1.037V8.104l-1.152.053c-.51.023-.937.088-1.283.193-.34.1-.615.243-.826.43a1.546 1.546 0 0 0-.457.678c-.088.27-.132.58-.132.931zm2.18-6.32c-.346 0-.627.05-.844.15a1.182 1.182 0 0 0-.501.404 1.594 1.594 0 0 0-.237.624c-.041.24-.062.5-.062.782-.498 0-.879-.085-1.143-.255-.257-.17-.386-.463-.386-.879 0-.31.085-.574.255-.79.17-.218.401-.393.694-.528.299-.14.644-.243 1.037-.308a7.76 7.76 0 0 1 1.257-.097c.55 0 1.031.056 1.441.167.41.106.753.282 1.029.528.275.246.48.568.615.967.14.392.21.876.21 1.45v4.667c0 .252.021.46.062.624a.928.928 0 0 0 .194.395c.088.1.202.17.343.211.146.041.319.062.518.062h.053V13H19.7l-.281-1.547h-.15c-.187.252-.369.483-.544.694-.176.211-.37.393-.58.545-.211.152-.452.27-.721.352a3.053 3.053 0 0 1-.958.131c-.399 0-.77-.058-1.116-.175a2.369 2.369 0 0 1-.888-.519 2.516 2.516 0 0 1-.58-.896c-.14-.364-.211-.791-.211-1.284 0-.955.34-1.664 1.02-2.127.68-.462 1.707-.714 3.084-.755l1.495-.053V6.285a6.93 6.93 0 0 0-.053-.888 1.778 1.778 0 0 0-.229-.703 1.14 1.14 0 0 0-.51-.457c-.216-.111-.51-.167-.878-.167z",
        transform: "translate(13 12)",
        fillRule: "evenodd"
      }),
      image: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M13 0L9.25 5l2.85 3.8-1.6 1.2C8.81 7.75 6 4 6 4l-6 8h22L13 0z",
        transform: "translate(13 14)",
        fillRule: "evenodd"
      }),
      presentation: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M2 4H0v10c0 1.1.9 2 2 2h14v-2H2V4zm16-4H6C4.9 0 4 .9 4 2v8c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm0 10H6V2h12v8z",
        transform: "matrix(-1 0 0 1 34 12)",
        fillRule: "evenodd"
      }),
      settings: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M13.572 8.735c.03-.24.053-.48.053-.735s-.023-.495-.053-.735l1.583-1.237a.378.378 0 0 0 .09-.48l-1.5-2.595a.377.377 0 0 0-.457-.165l-1.868.75a5.48 5.48 0 0 0-1.268-.735L9.868.815A.366.366 0 0 0 9.5.5h-3a.366.366 0 0 0-.367.315l-.285 1.988a5.762 5.762 0 0 0-1.268.735l-1.868-.75a.366.366 0 0 0-.457.165l-1.5 2.595a.37.37 0 0 0 .09.48l1.583 1.237c-.03.24-.053.488-.053.735 0 .248.022.495.053.735L.845 9.973a.378.378 0 0 0-.09.48l1.5 2.595c.09.165.292.225.458.165l1.867-.75c.39.3.81.547 1.268.735l.285 1.987c.022.18.18.315.367.315h3a.366.366 0 0 0 .367-.315l.285-1.988a5.762 5.762 0 0 0 1.268-.734l1.867.75c.173.067.368 0 .458-.165l1.5-2.595a.378.378 0 0 0-.09-.48l-1.582-1.238zM8 10.625A2.628 2.628 0 0 1 5.375 8 2.628 2.628 0 0 1 8 5.375 2.628 2.628 0 0 1 10.625 8 2.628 2.628 0 0 1 8 10.625z",
        transform: "translate(16 11)",
        fillRule: "evenodd"
      }),
      spreadsheet: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M0 8h6V5H0v3zm0 5h6v-3H0v3zM0 3h6V0H0v3zm8 5h12V5H8v3zm0 5h12v-3H8v3zM8 0v3h12V0H8z",
        transform: "translate(14 14)",
        fillRule: "evenodd"
      }),
      vector: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M14.5 2V1a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v1H3.937a2 2 0 1 0 0 1h3.936A9 9 0 0 0 3 11v1h2v-1a7.003 7.003 0 0 1 4.594-6.576A1 1 0 0 0 10.5 5h3a1 1 0 0 0 .906-.576A7.003 7.003 0 0 1 19 11v1h2v-1a9 9 0 0 0-4.873-8h3.936a2 2 0 1 0 0-1H14.5zm-1-1h-3v3h3V1zM2 1.5a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm19 1a1 1 0 1 0 2 0 1 1 0 0 0-2 0z",
        transform: "translate(12 14)",
        fillRule: "evenodd"
      }),
      video: /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M10.75 3.875V1.25A.752.752 0 0 0 10 .5H1a.752.752 0 0 0-.75.75v7.5c0 .412.338.75.75.75h9c.412 0 .75-.338.75-.75V6.125l3 3V.875l-3 3z",
        transform: "translate(17 14)"
      })
    };

    k$1([namesPlugin]);
    var propTypes = {
      /** Color of icon background */
      color: PropTypes.string,

      /** Text to display in label */
      extension: PropTypes.string,

      /** Displays the corner fold */
      fold: PropTypes.bool,

      /** Color of the corner fold */
      foldColor: PropTypes.string,

      /** Color of file type icon */
      glyphColor: PropTypes.string,

      /** Color of page gradient */
      gradientColor: PropTypes.string,

      /** Opacity of page gradient */
      gradientOpacity: PropTypes.number,

      /** Color of label */
      labelColor: PropTypes.string,

      /** Color of label text */
      labelTextColor: PropTypes.string,

      /** Displays the label in all caps */
      labelUppercase: PropTypes.bool,

      /** Corner radius of the file icon */
      radius: PropTypes.number,

      /** Type of glyph icon to display */
      type: PropTypes.oneOf(['3d', 'acrobat', 'audio', 'binary', 'code', 'code2', 'compressed', 'document', 'drive', 'font', 'image', 'presentation', 'settings', 'spreadsheet', 'vector', 'video'])
    };
    var VIEWBOX = {
      WIDTH: 40,
      HEIGHT: 48
    };
    var ICON = {
      WIDTH: VIEWBOX.WIDTH,
      HEIGHT: VIEWBOX.HEIGHT,
      X_OFFSET: 0
    };
    var FOLD = {
      HEIGHT: 12
    };
    var LABEL_HEIGHT = 14;
    var FileIcon = function FileIcon(_ref) {
      var _ref$color = _ref.color,
          color = _ref$color === void 0 ? 'whitesmoke' : _ref$color,
          extension = _ref.extension,
          _ref$fold = _ref.fold,
          fold = _ref$fold === void 0 ? true : _ref$fold,
          foldColor = _ref.foldColor,
          glyphColor = _ref.glyphColor,
          _ref$gradientColor = _ref.gradientColor,
          gradientColor = _ref$gradientColor === void 0 ? 'white' : _ref$gradientColor,
          _ref$gradientOpacity = _ref.gradientOpacity,
          gradientOpacity = _ref$gradientOpacity === void 0 ? 0.25 : _ref$gradientOpacity,
          labelColor = _ref.labelColor,
          _ref$labelTextColor = _ref.labelTextColor,
          labelTextColor = _ref$labelTextColor === void 0 ? 'white' : _ref$labelTextColor,
          _ref$labelUppercase = _ref.labelUppercase,
          labelUppercase = _ref$labelUppercase === void 0 ? false : _ref$labelUppercase,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 4 : _ref$radius,
          type = _ref.type;
      var UNIQUE_ID = lodash_uniqueid();
      return /*#__PURE__*/React__default["default"].createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 " + VIEWBOX.WIDTH + " " + VIEWBOX.HEIGHT,
        width: "100%",
        style: {
          maxWidth: '100%'
        }
      }, /*#__PURE__*/React__default["default"].createElement("defs", null, /*#__PURE__*/React__default["default"].createElement("clipPath", {
        id: "pageRadius" + UNIQUE_ID
      }, /*#__PURE__*/React__default["default"].createElement("rect", {
        x: ICON.X_OFFSET,
        y: "0",
        rx: radius,
        ry: radius,
        width: ICON.WIDTH,
        height: ICON.HEIGHT
      })), /*#__PURE__*/React__default["default"].createElement("clipPath", {
        id: "foldCrop"
      }, /*#__PURE__*/React__default["default"].createElement("rect", {
        width: ICON.WIDTH,
        height: FOLD.HEIGHT,
        transform: "rotate(-45 0 " + FOLD.HEIGHT + ")"
      })), /*#__PURE__*/React__default["default"].createElement("linearGradient", {
        x1: "100%",
        y1: "0%",
        y2: "100%",
        id: "pageGradient" + UNIQUE_ID
      }, /*#__PURE__*/React__default["default"].createElement("stop", {
        stopColor: gradientColor,
        stopOpacity: gradientOpacity,
        offset: "0%"
      }), /*#__PURE__*/React__default["default"].createElement("stop", {
        stopColor: gradientColor,
        stopOpacity: "0",
        offset: "66.67%"
      }))), /*#__PURE__*/React__default["default"].createElement("g", {
        id: "file",
        clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
      }, fold ? /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
        fill: color
      }), /*#__PURE__*/React__default["default"].createElement("path", {
        d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
        fill: "url(#pageGradient" + UNIQUE_ID + ")"
      })) : /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("rect", {
        x: ICON.X_OFFSET,
        y: "0",
        width: ICON.WIDTH,
        height: ICON.HEIGHT,
        fill: color
      }), /*#__PURE__*/React__default["default"].createElement("rect", {
        x: ICON.X_OFFSET,
        y: "0",
        width: ICON.WIDTH,
        height: ICON.HEIGHT,
        fill: "url(#pageGradient" + UNIQUE_ID + ")"
      }))), fold && /*#__PURE__*/React__default["default"].createElement("g", {
        transform: "translate(28 " + FOLD.HEIGHT + ") rotate(-90)"
      }, /*#__PURE__*/React__default["default"].createElement("rect", {
        width: ICON.WIDTH,
        height: ICON.HEIGHT,
        fill: foldColor || w(color).darken(0.1).toHex(),
        rx: radius,
        ry: radius,
        clipPath: "url(#foldCrop)"
      })), extension && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("g", {
        id: "label"
      }, /*#__PURE__*/React__default["default"].createElement("rect", {
        fill: labelColor || w(color).darken(0.3).toHex(),
        x: ICON.X_OFFSET,
        y: ICON.HEIGHT - LABEL_HEIGHT,
        width: ICON.WIDTH,
        height: LABEL_HEIGHT,
        clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
      })), /*#__PURE__*/React__default["default"].createElement("g", {
        id: "labelText",
        transform: "translate(" + ICON.X_OFFSET + " 34)"
      }, /*#__PURE__*/React__default["default"].createElement("text", {
        x: ICON.WIDTH / 2,
        y: "10",
        fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
        fontSize: "9",
        fill: labelTextColor,
        textAnchor: "middle",
        style: {
          fontWeight: 'bold',
          textAlign: 'center',
          pointerEvents: 'none',
          textTransform: labelUppercase ? 'uppercase' : 'none',
          userSelect: 'none'
        }
      }, extension))), type && /*#__PURE__*/React__default["default"].createElement("g", {
        transform: "translate(-4 " + (!extension ? 6 : 0) + ")",
        fill: glyphColor || w(color).darken(0.15).toHex()
      }, glyphs[type]));
    };
    FileIcon.propTypes = propTypes;

    var defaultStyles = {
      '3dm': {
        labelColor: '#8D1A11',
        type: '3d'
      },
      '3ds': {
        labelColor: '#5FB9AD',
        type: '3d'
      },
      '3g2': {
        type: 'video'
      },
      '3gp': {
        type: 'video'
      },
      '7zip': {
        type: 'compressed'
      },
      aac: {
        type: 'audio'
      },
      aep: {
        type: 'video'
      },
      ai: {
        color: '#423325',
        gradientOpacity: 0,
        labelColor: '#423325',
        labelTextColor: '#FF7F18',
        labelUppercase: true,
        foldColor: '#FF7F18',
        radius: 2
      },
      aif: {
        type: 'audio'
      },
      aiff: {
        type: 'audio'
      },
      asf: {
        type: 'video'
      },
      asp: {
        type: 'code'
      },
      aspx: {
        type: 'code'
      },
      avi: {
        type: 'video'
      },
      bin: {
        type: 'binary'
      },
      bmp: {
        type: 'image'
      },
      c: {
        type: 'code'
      },
      cpp: {
        type: 'code'
      },
      cs: {
        type: 'code'
      },
      css: {
        type: 'code'
      },
      csv: {
        type: 'spreadsheet'
      },
      cue: {
        type: 'document'
      },
      dll: {
        type: 'settings'
      },
      dmg: {
        type: 'drive'
      },
      doc: {
        color: '#2C5898',
        foldColor: '#254A80',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#2C5898',
        labelUppercase: true,
        type: 'document'
      },
      docx: {
        color: '#2C5898',
        foldColor: '#254A80',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#2C5898',
        labelUppercase: true,
        type: 'document'
      },
      dwg: {
        type: 'vector'
      },
      dxf: {
        type: 'vector'
      },
      eot: {
        type: 'font'
      },
      eps: {
        type: 'vector'
      },
      exe: {
        type: 'settings'
      },
      flac: {
        type: 'audio'
      },
      flv: {
        type: 'video'
      },
      fnt: {
        type: 'font'
      },
      fodp: {
        type: 'presentation'
      },
      fods: {
        type: 'spreadsheet'
      },
      fodt: {
        type: 'document'
      },
      fon: {
        type: 'font'
      },
      gif: {
        type: 'image'
      },
      gz: {
        type: 'compressed'
      },
      htm: {
        type: 'code'
      },
      html: {
        type: 'code'
      },
      indd: {
        color: '#4B2B36',
        gradientOpacity: 0,
        labelColor: '#4B2B36',
        labelTextColor: '#FF408C',
        labelUppercase: true,
        foldColor: '#FF408C',
        radius: 2
      },
      ini: {
        type: 'settings'
      },
      java: {
        type: 'code'
      },
      jpeg: {
        type: 'image'
      },
      jpg: {
        type: 'image'
      },
      js: {
        labelColor: '#F7DF1E',
        type: 'code'
      },
      json: {
        type: 'code'
      },
      jsx: {
        labelColor: '#00D8FF',
        type: 'code'
      },
      m4a: {
        type: 'audio'
      },
      m4v: {
        type: 'video'
      },
      max: {
        labelColor: '#5FB9AD',
        type: '3d'
      },
      md: {
        type: 'document'
      },
      mid: {
        type: 'audio'
      },
      mkv: {
        type: 'video'
      },
      mov: {
        type: 'video'
      },
      mp3: {
        type: 'audio'
      },
      mp4: {
        type: 'video'
      },
      mpeg: {
        type: 'video'
      },
      mpg: {
        type: 'video'
      },
      obj: {
        type: '3d'
      },
      odp: {
        type: 'presentation'
      },
      ods: {
        type: 'spreadsheet'
      },
      odt: {
        type: 'document'
      },
      ogg: {
        type: 'audio'
      },
      ogv: {
        type: 'video'
      },
      otf: {
        type: 'font'
      },
      pdf: {
        labelColor: '#D93831',
        type: 'acrobat'
      },
      php: {
        labelColor: '#8892BE',
        type: 'code'
      },
      pkg: {
        type: '3d'
      },
      plist: {
        type: 'settings'
      },
      png: {
        type: 'image'
      },
      ppt: {
        color: '#D14423',
        foldColor: '#AB381D',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#D14423',
        labelUppercase: true,
        type: 'presentation'
      },
      pptx: {
        color: '#D14423',
        foldColor: '#AB381D',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#D14423',
        labelUppercase: true,
        type: 'presentation'
      },
      pr: {
        type: 'video'
      },
      ps: {
        type: 'vector'
      },
      psd: {
        color: '#34364E',
        gradientOpacity: 0,
        labelColor: '#34364E',
        labelTextColor: '#31C5F0',
        labelUppercase: true,
        foldColor: '#31C5F0',
        radius: 2
      },
      py: {
        labelColor: '#FFDE57',
        type: 'code'
      },
      rar: {
        type: 'compressed'
      },
      rb: {
        labelColor: '#BB271A',
        type: 'code'
      },
      rm: {
        type: 'video'
      },
      rtf: {
        type: 'document'
      },
      scss: {
        labelColor: '#C16A98',
        type: 'code'
      },
      sitx: {
        type: 'compressed'
      },
      svg: {
        type: 'vector'
      },
      swf: {
        type: 'video'
      },
      sys: {
        type: 'settings'
      },
      tar: {
        type: 'compressed'
      },
      tex: {
        type: 'document'
      },
      tif: {
        type: 'image'
      },
      tiff: {
        type: 'image'
      },
      ts: {
        labelColor: '#3478C7',
        type: 'code'
      },
      ttf: {
        type: 'font'
      },
      txt: {
        type: 'document'
      },
      wav: {
        type: 'audio'
      },
      webm: {
        type: 'video'
      },
      wmv: {
        type: 'video'
      },
      woff: {
        type: 'font'
      },
      wpd: {
        type: 'document'
      },
      wps: {
        type: 'document'
      },
      xlr: {
        type: 'spreadsheet'
      },
      xls: {
        color: '#1A754C',
        foldColor: '#16613F',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#1A754C',
        labelUppercase: true,
        type: 'spreadsheet'
      },
      xlsx: {
        color: '#1A754C',
        foldColor: '#16613F',
        glyphColor: 'rgba(255,255,255,0.4)',
        labelColor: '#1A754C',
        labelUppercase: true,
        type: 'spreadsheet'
      },
      yml: {
        type: 'code'
      },
      zip: {
        type: 'compressed'
      },
      zipx: {
        type: 'compressed'
      }
    };

    // THIS FILE IS AUTO GENERATED
    function FaArrowUp (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 448 512"},"child":[{"tag":"path","attr":{"d":"M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"}}]})(props);
    }function FaFolder (props) {
      return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 512 512"},"child":[{"tag":"path","attr":{"d":"M464 128H272l-64-64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V176c0-26.51-21.49-48-48-48z"}}]})(props);
    }

    /**
     * filesize
     *
     * @copyright 2022 Jason Mulligan <jason.mulligan@avoidwork.com>
     * @license BSD-3-Clause
     * @version 10.0.6
     */
    const ARRAY = "array";
    const BIT = "bit";
    const BITS = "bits";
    const BYTE = "byte";
    const BYTES = "bytes";
    const EMPTY = "";
    const EXPONENT = "exponent";
    const FUNCTION = "function";
    const IEC = "iec";
    const INVALID_NUMBER = "Invalid number";
    const INVALID_ROUND = "Invalid rounding method";
    const JEDEC = "jedec";
    const OBJECT = "object";
    const PERIOD = ".";
    const ROUND = "round";
    const S = "s";
    const SI_KBIT = "kbit";
    const SI_KBYTE = "kB";
    const SPACE = " ";
    const STRING = "string";
    const ZERO = "0";
    const STRINGS = {
    	symbol: {
    		iec: {
    			bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
    			bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    		},
    		jedec: {
    			bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
    			bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    		}
    	},
    	fullform: {
    		iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    		jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
    	}
    };function filesize (arg, {
    	bits = false,
    	pad = false,
    	base = -1,
    	round = 2,
    	locale = EMPTY,
    	localeOptions = {},
    	separator = EMPTY,
    	spacer = SPACE,
    	symbols = {},
    	standard = EMPTY,
    	output = STRING,
    	fullform = false,
    	fullforms = [],
    	exponent = -1,
    	roundingMethod = ROUND,
    	precision = 0
    } = {}) {
    	let e = exponent,
    		num = Number(arg),
    		result = [],
    		val = 0,
    		u = EMPTY;

    	// Sync base & standard
    	if (base === -1 && standard.length === 0) {
    		base = 10;
    		standard = JEDEC;
    	} else if (base === -1 && standard.length > 0) {
    		standard = standard === IEC ? IEC : JEDEC;
    		base = standard === IEC ? 2 : 10;
    	} else {
    		base = base === 2 ? 2 : 10;
    		standard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;
    	}

    	const ceil = base === 10 ? 1000 : 1024,
    		full = fullform === true,
    		neg = num < 0,
    		roundingFunc = Math[roundingMethod];

    	if (typeof arg !== "bigint" && isNaN(arg)) {
    		throw new TypeError(INVALID_NUMBER);
    	}

    	if (typeof roundingFunc !== FUNCTION) {
    		throw new TypeError(INVALID_ROUND);
    	}

    	// Flipping a negative number to determine the size
    	if (neg) {
    		num = -num;
    	}

    	// Determining the exponent
    	if (e === -1 || isNaN(e)) {
    		e = Math.floor(Math.log(num) / Math.log(ceil));

    		if (e < 0) {
    			e = 0;
    		}
    	}

    	// Exceeding supported length, time to reduce & multiply
    	if (e > 8) {
    		if (precision > 0) {
    			precision += 8 - e;
    		}

    		e = 8;
    	}

    	if (output === EXPONENT) {
    		return e;
    	}

    	// Zero is now a special case because bytes divide by 1
    	if (num === 0) {
    		result[0] = 0;
    		u = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];
    	} else {
    		val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));

    		if (bits) {
    			val = val * 8;

    			if (val >= ceil && e < 8) {
    				val = val / ceil;
    				e++;
    			}
    		}

    		const p = Math.pow(10, e > 0 ? round : 0);
    		result[0] = roundingFunc(val * p) / p;

    		if (result[0] === ceil && e < 8 && exponent === -1) {
    			result[0] = 1;
    			e++;
    		}

    		u = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];
    	}

    	// Decorating a 'diff'
    	if (neg) {
    		result[0] = -result[0];
    	}

    	// Setting optional precision
    	if (precision > 0) {
    		result[0] = result[0].toPrecision(precision);
    	}

    	// Applying custom symbol
    	result[1] = symbols[result[1]] || result[1];

    	if (locale === true) {
    		result[0] = result[0].toLocaleString();
    	} else if (locale.length > 0) {
    		result[0] = result[0].toLocaleString(locale, localeOptions);
    	} else if (separator.length > 0) {
    		result[0] = result[0].toString().replace(PERIOD, separator);
    	}

    	if (pad && Number.isInteger(result[0]) === false && round > 0) {
    		const x = separator || PERIOD,
    			tmp = result[0].toString().split(x),
    			s = tmp[1] || EMPTY,
    			l = s.length,
    			n = round - l;

    		result[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;
    	}

    	if (full) {
    		result[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
    	}

    	// Returning Array, Object, or String (default)
    	return output === ARRAY ? result : output === OBJECT ? {
    		value: result[0],
    		symbol: result[1],
    		exponent: e,
    		unit: u
    	} : result.join(spacer);
    }

    const Chevron = ({ direction, ...rest }) => {
        let d;
        switch (direction) {
            case 'up':
                d = 'M17.98 10.23L3.20996 25H32.75L17.98 10.23Z';
                break;
            case 'down':
                d = 'M17.98 26.54L3.20996 11.77H32.75L17.98 26.54Z';
                break;
            case 'left':
                d = 'M9.82497 18.385L24.595 3.61499L24.595 33.155L9.82497 18.385Z';
                break;
            case 'right':
                d = 'M26.135 18.385L11.365 33.155L11.365 3.61503L26.135 18.385Z';
                break;
        }
        return (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36", fill: "none", ...rest },
            window.SP_REACT.createElement("path", { d: d, fill: "currentColor" })));
    };

    const dropDownControlButtonClass = findModuleChild((m) => {
        if (typeof m !== 'object')
            return undefined;
        for (const prop in m) {
            if (m[prop]?.toString()?.includes('gamepaddropdown_DropDownControlButton')) {
                return m[prop];
            }
        }
    });
    const DropdownMultiselectItem = ({ value, onSelect, checked: defaultChecked, ...rest }) => {
        const [checked, setChecked] = React.useState(defaultChecked);
        React.useEffect(() => {
            onSelect?.(checked, value);
        }, [checked, onSelect, value]);
        return (window.SP_REACT.createElement(MenuItem, { bInteractableItem: true, onClick: () => setChecked((x) => !x) },
            window.SP_REACT.createElement(DialogCheckbox, { style: { marginBottom: 0, padding: 0 }, className: "decky_DropdownMultiselectItem_DialogCheckbox", bottomSeparator: "none", ...rest, onClick: () => setChecked((x) => !x), onChange: (checked) => setChecked(checked), controlled: true, checked: checked })));
    };
    const DropdownMultiselect = ({ label, items, selected, onSelect, }) => {
        const [itemsSelected, setItemsSelected] = React.useState(selected);
        const handleItemSelect = React.useCallback((checked, value) => {
            setItemsSelected((x) => (checked ?
                [...x.filter((y) => y !== value), value] :
                x.filter((y) => y !== value)));
        }, []);
        React.useEffect(() => {
            onSelect(itemsSelected);
        }, [itemsSelected, onSelect]);
        return (window.SP_REACT.createElement(DialogButton, { style: {
                display: 'flex',
                alignItems: 'center',
                maxWidth: '100%',
            }, className: dropDownControlButtonClass, onClick: (evt) => {
                evt.preventDefault();
                showContextMenu(window.SP_REACT.createElement(Menu, { label: label, cancelText: trans_string('Button_Back', 'Back', true) },
                    window.SP_REACT.createElement("style", null, `
              /* Inherit color from ".basiccontextmenu" */
              .decky_DropdownMultiselectItem_DialogCheckbox > .DialogToggle_Label {
                color: inherit;
              }
              `),
                    items.map((x) => (window.SP_REACT.createElement(DropdownMultiselectItem, { key: x.value, label: x.label, value: x.value, checked: itemsSelected.includes(x.value), onSelect: handleItemSelect })))), evt.currentTarget ?? window);
            } },
            window.SP_REACT.createElement(Marquee, null, selected.length > 0 ?
                selected.map((x) => items[items.findIndex((v) => v.value === x)].label).join(', ') :
                ''),
            window.SP_REACT.createElement("div", { style: { flexGrow: 1, minWidth: '1ch' } }),
            window.SP_REACT.createElement(Chevron, { style: { height: '1em', flex: '0 0 1em' }, direction: "down" })));
    };

    const styleDef = [];
    // video ////////////////////////////////////
    const videoStyle = {
        color: '#f00f0f',
    };
    const videoExtList = [
        'avi',
        '3g2',
        '3gp',
        'aep',
        'asf',
        'flv',
        'm4v',
        'mkv',
        'mov',
        'mp4',
        'mpeg',
        'mpg',
        'ogv',
        'pr',
        'swfw',
        'webm',
        'wmv',
        'swf',
        'rm',
    ];
    styleDef.push([videoStyle, videoExtList]);
    // image ////////////////////////////////////
    const imageStyle = {
        color: '#d18f00',
    };
    const imageExtList = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'tif', 'tiff', 'apng', 'tga'];
    styleDef.push([imageStyle, imageExtList]);
    // zip ////////////////////////////////////
    const zipStyle = {
        color: '#f7b500',
        labelTextColor: '#000',
        // glyphColor: "#de9400"
    };
    const zipExtList = ['zip', 'zipx', '7zip', 'tar', 'sitx', 'gz', 'rar'];
    styleDef.push([zipStyle, zipExtList]);
    // audio ////////////////////////////////////
    const audioStyle = {
        color: '#f00f0f',
    };
    const audioExtList = ['aac', 'aif', 'aiff', 'flac', 'm4a', 'mid', 'mp3', 'ogg', 'wav'];
    styleDef.push([audioStyle, audioExtList]);
    // text ////////////////////////////////////
    const textStyle = {
        color: '#ffffff',
        glyphColor: '#787878',
    };
    const textExtList = ['cue', 'odt', 'md', 'rtf', 'txt', 'tex', 'wpd', 'wps', 'xlr', 'fodt'];
    styleDef.push([textStyle, textExtList]);
    // system ////////////////////////////////////
    const systemStyle = {
        color: '#111',
    };
    const systemExtList = ['exe', 'ini', 'dll', 'plist', 'sys'];
    styleDef.push([systemStyle, systemExtList]);
    // srcCode ////////////////////////////////////
    const srcCodeStyle = {
        glyphColor: '#787878',
        color: '#ffffff',
    };
    const srcCodeExtList = [
        'asp',
        'aspx',
        'c',
        'cpp',
        'cs',
        'css',
        'scss',
        'py',
        'json',
        'htm',
        'html',
        'java',
        'yml',
        'php',
        'js',
        'ts',
        'rb',
        'jsx',
        'tsx',
    ];
    styleDef.push([srcCodeStyle, srcCodeExtList]);
    // vector ////////////////////////////////////
    const vectorStyle = {
        color: '#ffe600',
    };
    const vectorExtList = ['dwg', 'dxf', 'ps', 'svg', 'eps'];
    styleDef.push([vectorStyle, vectorExtList]);
    // font ////////////////////////////////////
    const fontStyle = {
        color: '#555',
    };
    const fontExtList = ['fnt', 'ttf', 'otf', 'fon', 'eot', 'woff'];
    styleDef.push([fontStyle, fontExtList]);
    // objectModel ////////////////////////////////////
    const objectModelStyle = {
        color: '#bf6a02',
        glyphColor: '#bf6a02',
    };
    const objectModelExtList = ['3dm', '3ds', 'max', 'obj', 'pkg'];
    styleDef.push([objectModelStyle, objectModelExtList]);
    // sheet ////////////////////////////////////
    const sheetStyle = {
        color: '#2a6e00',
    };
    const sheetExtList = ['csv', 'fods', 'ods', 'xlr'];
    styleDef.push([sheetStyle, sheetExtList]);
    // const defaultStyle: Record<string, FileIconProps> = {
    //   pdf: {
    // glyphColor: "white",
    // color: "#D93831"
    //   }
    // };
    //////////////////////////////////////////////////
    function createStyleObj(extList, styleObj) {
        return Object.fromEntries(extList.map((ext) => {
            return [ext, { ...styleObj, glyphColor: 'white' }];
        }));
    }
    const styleDefObj = styleDef.reduce((acc, [fileStyle, fileExtList]) => {
        return { ...acc, ...createStyleObj(fileExtList, fileStyle) };
    });

    function getList(serverApi, path, includeFiles = true) {
        return serverApi.callPluginMethod('filepicker_new', { path, include_files: includeFiles });
    }
    const sortOptions = [
        {
            data: 'name_desc',
            label: 'A-Z',
        },
        {
            data: 'name_asc',
            label: 'Z-A',
        },
        {
            data: 'modified_desc',
            label: 'Modified (Newest)',
        },
        {
            data: 'modified_asc',
            label: 'Modified (Oldest)',
        },
        {
            data: 'created_desc',
            label: 'Created (Newest)',
        },
        {
            data: 'created_asc',
            label: 'Created (Oldest)',
        },
        {
            data: 'size_desc',
            label: 'Size (Largest)',
        },
        {
            data: 'size_asc',
            label: 'Size (Smallest)',
        },
    ];
    const iconStyles = {
        paddingRight: '10px',
        width: '1em',
    };
    const FilePicker = ({ serverApi, startPath, includeFiles = true, filter, validFileExtensions = null, defaultHidden = false, // false by default makes sense for most users
    onSubmit, closeModal, }) => {
        if (startPath !== '/' && startPath.endsWith('/'))
            startPath = startPath.substring(0, startPath.length - 1); // remove trailing path
        const [path, setPath] = React.useState(startPath);
        const [listing, setListing] = React.useState({ files: [], realpath: path });
        const [files, setFiles] = React.useState([]);
        const [error, setError] = React.useState(null);
        const [loading, setLoading] = React.useState(true);
        const [showHidden, setShowHidden] = React.useState(defaultHidden);
        const [sort, setSort] = React.useState('name_desc');
        const [selectedFiles, setSelectedFiles] = React.useState(validFileExtensions);
        const validExtsOptions = React.useMemo(() => {
            if (!validFileExtensions)
                return [];
            return [{ label: 'All Files', value: 'all_files' }, ...validFileExtensions.map((x) => ({ label: x, value: x }))];
        }, [validFileExtensions]);
        const handleExtsSelect = React.useCallback((val) => {
            // unselect other options if "All Files" is checked
            if (val.includes('all_files')) {
                setSelectedFiles(['all_files']);
            }
            else {
                setSelectedFiles(val);
            }
        }, []);
        React.useEffect(() => {
            (async () => {
                setLoading(true);
                const listing = await getList(serverApi, path, includeFiles);
                if (!listing.success) {
                    setListing({ files: [], realpath: path });
                    setLoading(false);
                    setError(listing.result);
                    return;
                }
                else {
                    setError(null);
                    setFiles(listing.result.files);
                }
                setLoading(false);
                setListing(listing.result);
            })();
        }, [error, includeFiles, path, serverApi]);
        React.useEffect(() => {
            const files = [...listing.files]
                // Hidden files filter
                .filter((file) => {
                if (showHidden && file.ishidden)
                    return true;
                if (!showHidden && file.ishidden)
                    return false;
                return true;
            })
                // File extension filter
                .filter((file) => {
                if (!validFileExtensions || file.isdir || selectedFiles.includes('all_files'))
                    return true;
                const extension = file.realpath.split('.').pop();
                if (selectedFiles.includes(extension))
                    return true;
                return false;
            })
                // Custom filter
                .filter((file) => {
                if (filter instanceof RegExp)
                    return filter.test(file.name);
                if (typeof filter === 'function')
                    return filter(file);
                return true;
            })
                // Sort files
                .sort((a, b) => {
                const key = sort.split('_')[0];
                const order = sort.split('_')[1];
                if (key === 'name') {
                    return (order === 'asc' ? b.name.localeCompare(a.name) : a.name.localeCompare(b.name));
                }
                return order === 'asc' ?
                    (a[key] > b[key] ? 1 : -1) :
                    (b[key] > a[key] ? 1 : -1);
            })
                // Put directories before files
                .reduceRight((acc, file) => file.isdir ? [file, ...acc] : [...acc, file], []);
            setFiles(files);
        }, [listing.files, filter, showHidden, sort, selectedFiles, validFileExtensions]);
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            window.SP_REACT.createElement(DialogBody, null,
                window.SP_REACT.createElement(DialogControlsSection, null,
                    window.SP_REACT.createElement(Focusable, { "flow-children": "right", style: { display: 'flex', marginBottom: '1em' } },
                        window.SP_REACT.createElement(DialogButton, { style: {
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                minWidth: 'unset',
                                width: '40px',
                                borderRadius: 'unset',
                                margin: '0',
                                padding: '10px',
                            }, onClick: () => {
                                const newPathArr = path.split('/');
                                newPathArr.pop();
                                let newPath = newPathArr.join('/');
                                if (newPath == '')
                                    newPath = '/';
                                setPath(newPath);
                            } },
                            window.SP_REACT.createElement(FaArrowUp, null)),
                        window.SP_REACT.createElement("div", { style: { width: '100%' } },
                            window.SP_REACT.createElement(TextField, { value: path, onChange: (e) => {
                                    e.target.value && setPath(e.target.value);
                                }, style: { height: '100%' } }))),
                    window.SP_REACT.createElement(ControlsList, { alignItems: "center", spacing: "standard" },
                        window.SP_REACT.createElement(ToggleField, { highlightOnFocus: false, label: "Show Hidden Files", bottomSeparator: "none", checked: showHidden, onChange: () => setShowHidden((x) => !x) }),
                        window.SP_REACT.createElement(Dropdown, { rgOptions: sortOptions, selectedOption: sort, onChange: (x) => setSort(x.data) }),
                        validFileExtensions && (window.SP_REACT.createElement(DropdownMultiselect, { label: "File Type", items: validExtsOptions, selected: selectedFiles, onSelect: handleExtsSelect })))),
                window.SP_REACT.createElement(DialogControlsSection, { style: { marginTop: '1em' } },
                    window.SP_REACT.createElement(Focusable, { style: { display: 'flex', gap: '.25em', flexDirection: 'column', height: '60vh', overflow: 'scroll' } },
                        loading && window.SP_REACT.createElement(SteamSpinner, { style: { height: '100%' } }),
                        !loading &&
                            files
                                .map((file) => {
                                const extension = file.realpath.split('.').pop();
                                return (window.SP_REACT.createElement(DialogButton, { key: `${file.realpath}${file.name}`, style: { borderRadius: 'unset', margin: '0', padding: '10px' }, onClick: () => {
                                        const fullPath = `${path}${path.endsWith('/') ? '' : '/'}${file.name}`;
                                        if (file.isdir)
                                            setPath(fullPath);
                                        else {
                                            onSubmit({ path: fullPath, realpath: file.realpath });
                                            closeModal?.();
                                        }
                                    } },
                                    window.SP_REACT.createElement("div", { style: { display: 'flex', flexDirection: 'row', alignItems: 'flex-start' } },
                                        file.isdir ? (window.SP_REACT.createElement(FaFolder, { style: iconStyles })) : (window.SP_REACT.createElement("div", { style: iconStyles }, file.realpath.includes('.') ? (window.SP_REACT.createElement(FileIcon, { ...defaultStyles[extension], ...styleDefObj[extension], extension: '' })) : (window.SP_REACT.createElement(FileIcon, null)))),
                                        window.SP_REACT.createElement(Marquee, null, file.name)),
                                    window.SP_REACT.createElement("div", { style: {
                                            display: 'flex',
                                            opacity: .5,
                                            fontSize: '.6em',
                                            textAlign: 'left',
                                            lineHeight: 1,
                                            marginTop: '.5em',
                                        } },
                                        file.isdir ? 'Folder' : filesize(file.size, { standard: 'iec' }),
                                        window.SP_REACT.createElement("span", { style: { marginLeft: 'auto' } }, new Date(file.modified * 1000).toLocaleString()))));
                            }),
                        error))),
            !loading && !error && !includeFiles && (window.SP_REACT.createElement(DialogFooter, null,
                window.SP_REACT.createElement(DialogButton, { className: "Primary", style: { marginTop: '10px', alignSelf: 'flex-end' }, onClick: () => {
                        onSubmit({ path, realpath: listing.realpath });
                        closeModal?.();
                    } }, "Use this folder")))));
    };

    /*
      Modified file picker from decky-loader
      Will eventually be submitted to main decky-loader. (and passing "serverApi" won't be necessary)

      - Backwards compatible.
      - More sorting options.
      - Overhauled UX.
      - Allows use of a filter function instead of just RegEx.
      - Added a filter override to only show certain file types.
      - Changed sort to show directories first.
      - Fixed bug where some files and dirs are not shown.
      - Fixed but where you couldn't navigate or start at the root directory.
      - Fixed bug where files from previous dir would appear when navigating due to duplicate keys.
    */
    var openFilePicker = (startPath, includeFiles, filter, filePickerSettings, serverApi) => {
        return new Promise((resolve, reject) => {
            if (!serverApi)
                return reject('No server API');
            const Content = ({ closeModal }) => (
            // Purposely outside of the FilePicker component as lazy-loaded ModalRoots don't focus correctly
            window.SP_REACT.createElement(ModalRoot, { onCancel: () => {
                    reject('User canceled');
                    closeModal?.();
                } },
                window.SP_REACT.createElement(FilePicker, { serverApi: serverApi, startPath: startPath, includeFiles: includeFiles, filter: filter, onSubmit: resolve, closeModal: closeModal, ...filePickerSettings })));
            showModal(window.SP_REACT.createElement(Content, null));
        });
    };

    var log = (...params) => {
    };

    const ASSET_TYPE = {
        grid_p: 0,
        grid_l: 3,
        hero: 1,
        logo: 2,
        icon: 4,
    };
    const SGDB_ASSET_TYPE_READABLE = {
        grid_p: trans_string('ASSET_TYPE_CAPSULE', 'Capsule'),
        grid_l: trans_string('ASSET_TYPE_WIDECAPSULE', 'Wide Capsule'),
        hero: trans_string('ASSET_TYPE_HERO', 'Hero'),
        logo: trans_string('ASSET_TYPE_LOGO', 'Logo'),
        icon: trans_string('ASSET_TYPE_ICON', 'Icon'),
    };
    const gridStyles = {
        options: [
            { label: 'Alternate', value: 'alternate' },
            { label: 'White Logo', value: 'white_logo' },
            { label: 'No Logo', value: 'no_logo' },
            { label: 'Blurred', value: 'blurred' },
            { label: 'Minimal', value: 'material' },
        ],
        default: ['alternate', 'white_logo', 'no_logo', 'blurred', 'material'],
    };
    const STYLES = {
        grid_p: gridStyles,
        grid_l: gridStyles,
        hero: {
            options: [
                { label: 'Alternate', value: 'alternate' },
                { label: 'Blurred', value: 'blurred' },
                { label: 'Minimal', value: 'material' },
            ],
            default: ['alternate', 'blurred', 'material'],
        },
        logo: {
            options: [
                { label: 'Official', value: 'official' },
                { label: 'White', value: 'white' },
                { label: 'Black', value: 'black' },
                { label: 'Custom', value: 'custom' },
            ],
            default: ['official', 'white', 'black', 'custom'],
        },
        icon: {
            options: [
                { label: 'Official', value: 'official' },
                { label: 'Custom', value: 'custom' },
            ],
            default: ['official', 'custom'],
        },
    };
    const allMimes = {
        options: [
            { label: 'PNG', value: 'image/png' },
            { label: 'JPEG', value: 'image/jpeg' },
            { label: 'WebP', value: 'image/webp' },
        ],
        default: ['image/png', 'image/jpeg', 'image/webp'],
    };
    const MIMES = {
        grid_p: allMimes,
        grid_l: allMimes,
        hero: allMimes,
        logo: {
            options: [
                { label: 'PNG', value: 'image/png' },
                { label: 'WebP', value: 'image/webp' },
            ],
            default: ['image/png', 'image/webp'],
        },
        icon: {
            options: [
                { label: 'PNG', value: 'image/png' },
                { label: 'ICO', value: 'image/vnd.microsoft.icon' },
            ],
            default: ['image/png', 'image/vnd.microsoft.icon'],
        },
    };
    const validIconSizes = [1024, 768, 512, 310, 256, 194, 192, 180, 160, 152, 150, 144, 128, 120, 114, 100, 96, 90, 80, 76, 72, 64, 60, 57, 56, 54, 48, 40, 35, 32, 28, 24, 20, 16, 14, 10, 8];
    const DIMENSIONS = {
        grid_p: {
            options: ['600x900', '342x482', '660x930', '512x512', '1024x1024'].map((x) => ({ label: x.replace('x', ''), value: x })),
            default: ['600x900', '342x482', '660x930'],
        },
        grid_l: {
            options: ['460x215', '920x430', '512x512', '1024x1024'].map((x) => ({ label: x.replace('x', ''), value: x })),
            default: ['460x215', '920x430'],
        },
        hero: {
            options: ['1920x620', '3840x1240', '1600x650'].map((x) => ({ label: x.replace('x', ''), value: x })),
            default: ['1920x620', '3840x1240', '1600x650'],
        },
        logo: {
            options: [],
            default: [],
        },
        icon: {
            options: validIconSizes.map((x) => ({ label: `${x}${x}`, value: x })),
            default: validIconSizes,
        },
    };
    // Sometimes tabs needs different translation strings
    const tabStrs = {
        grid_p: trans_string('LABEL_TAB_CAPSULE', 'Capsule'),
        grid_l: trans_string('LABEL_TAB_WIDECAPSULE', 'Wide Capsule'),
        hero: trans_string('LABEL_TAB_HERO', 'Hero'),
        logo: trans_string('LABEL_TAB_LOGO', 'Logo'),
        icon: trans_string('LABEL_TAB_ICON', 'Icon'),
        manage: trans_string('LABEL_TAB_MANAGE', 'Manage'),
    };
    // Default tab order
    const DEFAULT_TABS = [
        ...Object.keys(tabStrs),
    ];

    var justDebounce = debounce;

    function debounce(fn, delay, atStart, guarantee) {
      var timeout;
      var args;
      var self;

      return function debounced() {
        self = this;
        args = Array.prototype.slice.call(arguments);

        if (timeout && (atStart || guarantee)) {
          return;
        } else if (!atStart) {
          clear();

          timeout = setTimeout(run, delay);
          return timeout;
        }

        timeout = setTimeout(clear, delay);
        fn.apply(self, args);

        function run() {
          clear();
          fn.apply(self, args);
        }

        function clear() {
          clearTimeout(timeout);
          timeout = null;
        }
      };
    }

    const SettingsContext = React.createContext({});
    const SettingsProvider = ({ serverApi, children }) => {
        const [setting, setSetting] = React.useState();
        const save = React.useMemo(() => async (setting) => {
            await serverApi.callPluginMethod('set_setting', setting);
        }, [serverApi]);
        const saveDb = React.useMemo(() => justDebounce(async (key, value) => {
            setSetting({ key, value });
        }, 1500), []);
        const set = React.useMemo(() => (key, value, immediate = false) => {
            if (immediate) {
                return setSetting({ key, value });
            }
            return saveDb(key, value);
        }, [saveDb]);
        const get = React.useMemo(() => async (key, fallback) => {
            return (await serverApi.callPluginMethod('get_setting', { key, default: fallback })).result;
        }, [serverApi]);
        React.useEffect(() => {
            if (setting) {
                save(setting);
            }
        }, [save, setting]);
        return (window.SP_REACT.createElement(SettingsContext.Provider, { value: { set, get } }, children));
    };
    const useSettings = () => React.useContext(SettingsContext);

    const buttonStyle = {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        padding: '10px',
        maxWidth: '40px',
        minWidth: 'auto',
        marginLeft: '.5em',
    };
    const Interactables = ({ entry, defaultTab, hiddenTabs, onDefaultClick, onHideClick }) => {
        const [shakeHidden, setShakeHidden] = React.useState(false);
        const isHidden = hiddenTabs?.includes(entry.data?.type);
        React.useEffect(() => {
            if (shakeHidden) {
                const timeout = setTimeout(() => {
                    setShakeHidden(false);
                }, 400); // animation plays for 200ms and repeats twice, so 400ms is enough
                return () => clearTimeout(timeout);
            }
            return undefined;
        }, [shakeHidden]);
        if (!entry.data)
            return null;
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            (defaultTab !== entry.data.type) ? (window.SP_REACT.createElement(DialogButton, { onOKButton: () => onDefaultClick(entry), style: buttonStyle },
                window.SP_REACT.createElement(HiHome, null))) : (window.SP_REACT.createElement("div", { style: buttonStyle },
                window.SP_REACT.createElement(HiHome, { fill: "#008ada" }))),
            window.SP_REACT.createElement(DialogButton, { onOKActionDescription: isHidden ? 'Show' : trans_string('Button_Hide', 'Hide', true), onOKButton: () => {
                    if (!entry.data)
                        return;
                    if (hiddenTabs &&
                        !isHidden &&
                        hiddenTabs.length === DEFAULT_TABS.length - 1) {
                        setShakeHidden(true);
                    }
                    else {
                        onHideClick(entry);
                    }
                }, style: shakeHidden ? {
                    ...buttonStyle,
                    ...{ animation: '200ms sgdb-button-shake 2' },
                } : buttonStyle }, isHidden ? window.SP_REACT.createElement(HiEye, null) : window.SP_REACT.createElement(HiEyeSlash, null))));
    };
    const TabSorter = () => {
        const { set, get } = useSettings();
        const [defaultTab, setDefaultTab] = React.useState(null);
        const [hiddenTabs, setHiddenTabs] = React.useState(null);
        const [tabPositions, setTabPositions] = React.useState(null);
        const fieldRef = React.useRef(null);
        const once = React.useRef(false);
        const tabEntries = React.useMemo(() => {
            if (tabPositions === null || hiddenTabs === null)
                return [];
            return tabPositions.map((type, i) => ({
                label: (window.SP_REACT.createElement(Marquee, { style: {
                        maxWidth: '340px',
                        opacity: hiddenTabs.includes(type) ? .5 : 1,
                    } }, tabStrs[type])),
                data: { type },
                position: i,
            }));
        }, [tabPositions, hiddenTabs]);
        const handleSave = (entries) => {
            const sortedTabs = entries.map((entry) => entry.data?.type);
            set('tabs_order', sortedTabs, true);
            setTabPositions(sortedTabs);
        };
        const handleHideClick = React.useCallback((entry) => {
            setHiddenTabs((x) => {
                if (entry.data && x) {
                    const v = [...x];
                    if (v.includes(entry.data.type)) {
                        v.splice(v.indexOf(entry.data.type), 1);
                    }
                    else {
                        v.push(entry.data.type);
                    }
                    set('tabs_hidden', v, true);
                    return v;
                }
                return null;
            });
        }, [set]);
        const handleDefaultClick = React.useCallback((entry) => {
            if (entry.data) {
                set('tab_default', entry.data.type, true);
                setDefaultTab(entry.data.type);
            }
        }, [set]);
        React.useEffect(() => {
            (async () => {
                const positions = await get('tabs_order', DEFAULT_TABS);
                const hidden = await get('tabs_hidden', []);
                let tabDefault = await get('tab_default', 'grid_p');
                const filtered = positions.filter((x) => !hidden.includes(x));
                setTabPositions(positions);
                setHiddenTabs(hidden);
                // Set first tab as default if default is hidden
                if (!filtered.includes(tabDefault)) {
                    tabDefault = filtered[0];
                }
                setDefaultTab(tabDefault);
            })();
        }, [get]);
        React.useEffect(() => {
            // hack to auto focus first element after render
            if (tabEntries.length > 0 && defaultTab && !once.current) {
                fieldRef.current?.querySelector('button')?.focus();
                once.current = true;
            }
        }, [tabEntries, defaultTab]);
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            window.SP_REACT.createElement("style", null, `
        @keyframes sgdb-button-shake {
          0% { transform: translateX(0) }
          25% { transform: translateX(3px) }
          50% { transform: translateX(-3px) }
          75% { transform: translateX(3px) }
          100% { transform: translateX(0) }
        }
      `),
            window.SP_REACT.createElement(Focusable, { ref: fieldRef },
                window.SP_REACT.createElement(ReorderableList, { animate: true, entries: tabEntries, onSave: handleSave, interactables: (props) => (window.SP_REACT.createElement(Interactables, { ...props, defaultTab: defaultTab, hiddenTabs: hiddenTabs, onDefaultClick: handleDefaultClick, onHideClick: handleHideClick })) }))));
    };
    TabSorter.displayName = 'TabSorter';

    const tabSettingsDesc = trans_string('MSG_ASSET_TAB_SETTINGS_DESC', 'Reorder or hide unused tabs, and set the default tab that opens when using "{ACTION_CHANGE_ARTWORK}"').replace('{ACTION_CHANGE_ARTWORK}', trans_string('ACTION_CHANGE_ARTWORK', 'Change artwork...'));
    const QuickAccessSettings = ({ serverApi }) => {
        const { get, set } = useSettings();
        const [useCount, setUseCount] = React.useState(null);
        const [squares, setSquares] = React.useState(false);
        React.useState('70');
        const handleSquareToggle = React.useCallback((checked) => {
            set('experiment_squares', checked);
            setSquares(checked);
        }, [set]);
        React.useEffect(() => {
            (async () => {
                setUseCount(await get('plugin_use_count', 0));
                setSquares(await get('experiment_squares', false));
            })();
        }, [get]);
        if (useCount === null)
            return null;
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            "production" === 'development' ,
            (useCount <= 5) && ( // Hide tutorial if plugin has been used more than 5 times
            window.SP_REACT.createElement(PanelSection, { title: trans_string('LABEL_USAGE_TITLE', 'Lost? Here\'s a Quick Guide') },
                window.SP_REACT.createElement(PanelSectionRow, null,
                    window.SP_REACT.createElement(GuideVideoField, { bottomSeparator: "standard", highlightOnFocus: true, focusable: true, onActivate: () => {
                            showModal(window.SP_REACT.createElement(ModalRoot, null,
                                window.SP_REACT.createElement(DialogBody, { style: { padding: '0 3.5em' } },
                                    window.SP_REACT.createElement(GuideVideoField, null))));
                        } })))),
            window.SP_REACT.createElement(PanelSection, { title: trans_string('Settings', 'Settings', true) },
                window.SP_REACT.createElement(PanelSectionRow, null,
                    window.SP_REACT.createElement(Field, { childrenLayout: "below", description: tabSettingsDesc },
                        window.SP_REACT.createElement(DialogButton, { onClick: () => {
                                showModal((window.SP_REACT.createElement(ModalRoot, null,
                                    window.SP_REACT.createElement(SettingsProvider, { serverApi: serverApi },
                                        window.SP_REACT.createElement(DialogHeader, null, trans_string('LABEL_SETTINGS_ASSET_TABS', 'Asset Tab Settings')),
                                        window.SP_REACT.createElement(DialogBodyText, null, tabSettingsDesc),
                                        window.SP_REACT.createElement(DialogBody, null,
                                            window.SP_REACT.createElement(TabSorter, null))))));
                            } }, trans_string('LABEL_SETTINGS_ASSET_TABS', 'Asset Tab Settings'))))),
            window.SP_REACT.createElement(PanelSection, { title: "Experiments" },
                window.SP_REACT.createElement("div", { style: { fontSize: '12px', padding: '12px 0px' } }, "Features with little testing that may be too unstable for regular usage and might be removed later. (Requires restart)"),
                window.SP_REACT.createElement(PanelSectionRow, null,
                    window.SP_REACT.createElement(ToggleField, { label: "Square Capsules", description: "Use square capsules instead of portrait ones. Remember to add square sizes (1024x1024 & 512x512) to the dimensions filter to find them.", checked: squares, onChange: handleSquareToggle }))),
            getCredits() && (window.SP_REACT.createElement(PanelSection, { title: trans_string('LABEL_TRANSLATION_CREDIT_TITLE', 'English Translation') },
                window.SP_REACT.createElement("div", { style: {
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '.25em',
                    } }, getCredits().map((person) => window.SP_REACT.createElement("span", { key: person }, person))))),
            window.SP_REACT.createElement(PanelSection, { title: trans_string('LABEL_MORE_SGDB_TITLE', 'More SteamGridDB Stuff') },
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiDiscord, { fill: "#5865F2" }), url: "https://discord.gg/bnSVJrz" }, trans_string('ACTION_SGDB_DISCORD', 'Join the Discord')),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiGithub, null), url: "https://github.com/SteamGridDB/" }, trans_string('ACTION_SGDB_GITHUB', 'Open Source Projects')),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiPatreon, { fill: "#FF424D" }), url: "https://www.patreon.com/steamgriddb" }, trans_string('ACTION_SGDB_DONATE', 'Support us on Patreon')),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiCrowdin, { fill: "#fff" }), url: "https://crowdin.com/project/decky-steamgriddb" }, trans_string('ACTION_SGDB_TRANSLATE', 'Help Translate')),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(BoopIcon, { fill: "#4e9ac6" }), url: "https://www.steamgriddb.com/boop" }, trans_string('ACTION_SGDB_BOOP', 'Check out SGDBoop')),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiTwitter, { fill: "#1DA1F2" }), url: "https://twitter.com/SteamGridDB" }, "Twitter"),
                window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiMastodon, { fill: "#6364FF" }), url: "https://mastodon.gamedev.place/@SteamGridDB" }, "Mastodon"))));
    };

    // this will be blurry unless you're on 1x UI scale cause the quick access menu icons arent being scaled pixel perfect :(
    const MenuIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 16 16", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
        window.SP_REACT.createElement("path", { d: "M0,3L0,11L1,11L1,4L12,4L12,3L0,3Z" }),
        window.SP_REACT.createElement("path", { d: "M14,5L2,5L2,12L3,12L3,6L14,6L14,5Z" }),
        window.SP_REACT.createElement("rect", { x: "4", y: "7", width: "12", height: "6" })));

    class e$1 extends Error{constructor(t){super(null!=t?`Timed out after waiting for ${t} ms`:"Timed out"),Object.setPrototypeOf(this,e$1.prototype);}}const t$1=(e,t)=>new Promise(((o,n)=>{try{e.schedule(o,t);}catch(e){n(e);}})),o={schedule:(e,t)=>{let o;const n=e=>{null!=e&&clearTimeout(e),o=void 0;};return o=setTimeout((()=>{n(o),e();}),t),{cancel:()=>n(o)}}},c$1=Number.POSITIVE_INFINITY,l$1=(n,r,l)=>{var s,u;const i=null!==(s="number"==typeof r?r:null==r?void 0:r.timeout)&&void 0!==s?s:5e3,a=null!==(u="number"==typeof r?l:null==r?void 0:r.intervalBetweenAttempts)&&void 0!==u?u:50;let m=!1;const d=()=>new Promise(((e,r)=>{const c=()=>{m||new Promise(((e,t)=>{try{e(n());}catch(e){t(e);}})).then((n=>{n?e(n):t$1(o,a).then(c).catch(r);})).catch(r);};c();})),h=i!==c$1?()=>t$1(o,i).then((()=>{throw m=!0,new e$1(i)})):void 0;return null!=h?Promise.race([d(),h()]):d()};

    const getAppOverview = async (appId) => {
        try {
            return await l$1(() => {
                return window.appStore.GetAppOverviewByAppID(appId) ?? null;
            }, { timeout: 5000, intervalBetweenAttempts: 200 });
        }
        catch (err) {
            return null;
        }
    };

    /**
     * Tries to retrieve the app details from Steam.
     *
     * @param appId id to get details for.
     * @returns AppDetails if succeeded or null otherwise.
     */
    async function getAppDetails(appId) {
        return await new Promise((resolve) => {
            let timeoutId = undefined;
            try {
                const { unregister } = SteamClient.Apps.RegisterForAppDetails(appId, (details) => {
                    clearTimeout(timeoutId);
                    unregister();
                    resolve(details);
                });
                timeoutId = setTimeout(() => {
                    unregister();
                    resolve(null);
                }, 300);
            }
            catch (error) {
                clearTimeout(timeoutId);
                resolve(null);
            }
        });
    }

    const restartSteam = () => {
        SteamClient.User.StartRestart();
    };
    const showRestartConfirm = () => {
        showModal(window.SP_REACT.createElement(ConfirmModal, { strTitle: trans_string('LABEL_RESTART_STEAM_TITLE', 'Restart Steam?'), strCancelButtonText: trans_string('ACTION_RESTART_STEAM_LATER', 'Later'), strOKButtonText: trans_string('ACTION_RESTART_STEAM_NOW', 'Restart Now'), strDescription: trans_string('MSG_RESTART_STEAM_DESC', 'Steam needs to be restarted for the changes to take effect.'), onOK: restartSteam }));
    };

    var getCurrentSteamUserId = (steam64 = false) => {
        if (steam64)
            return window.App.m_CurrentUser.strSteamID;
        return BigInt.asUintN(32, BigInt(window.App.m_CurrentUser.strSteamID)).toString();
    };

    /*
      special key only for use with this decky plugin
      attempting to use this in your own projects will
      cause you to be automatically banned and blacklisted
    */
    const SGDB_API_KEY = '6465636b796c6f616465723432303639';
    const API_BASE = 'https://www.steamgriddb.com/api/v2';
    const getAmbiguousAssetType = (assetType) => typeof assetType === 'number' ? assetType : ASSET_TYPE[assetType];
    const getApiParams = (assetType, filters, page) => {
        let adult = 'false';
        let humor = 'any';
        let epilepsy = 'any';
        let oneoftag = '';
        if (filters?.untagged === true) {
            if (filters?.humor === false) {
                humor = 'false';
            }
            if (filters?.adult === false) {
                adult = 'false';
            }
            if (filters?.adult === true) {
                adult = 'any';
            }
            if (filters?.epilepsy === false) {
                epilepsy = 'false';
            }
        }
        else {
            const selectedTags = [];
            if (filters?.humor === true) {
                humor = 'any';
                selectedTags.push('humor');
            }
            if (filters?.adult === true) {
                adult = 'any';
                selectedTags.push('nsfw');
            }
            if (filters?.epilepsy === true) {
                epilepsy = 'any';
                selectedTags.push('epilepsy');
            }
            oneoftag = selectedTags.join(',');
        }
        return new URLSearchParams({
            page: page.toString(),
            styles: filters?.styles ?? STYLES[assetType].default.join(','),
            dimensions: filters?.dimensions ?? DIMENSIONS[assetType].default.join(','),
            mimes: filters?.mimes ?? MIMES[assetType].default.join(','),
            nsfw: adult,
            humor,
            epilepsy,
            oneoftag,
            types: [filters?._static && 'static', filters?.animated && 'animated'].filter(Boolean).join(','),
        }).toString();
    };
    const SGDBContext = React.createContext({});
    const SGDBProvider = ({ serverApi, children }) => {
        const [appId, setAppId] = React.useState(null);
        const [appOverview, setAppOverview] = React.useState(null);
        const clearAsset = React.useCallback(async (assetType) => {
            assetType = getAmbiguousAssetType(assetType);
            if (assetType === ASSET_TYPE.icon) {
                if (appOverview?.BIsShortcut()) {
                    const res = await serverApi.callPluginMethod('set_shortcut_icon', {
                        path: null,
                        owner_id: getCurrentSteamUserId(),
                        appid: appId,
                    });
                    if (!res.success)
                        throw new Error(res.result);
                    if (res.result !== 'icon_is_same_path')
                        showRestartConfirm();
                }
                else {
                    if (appOverview) {
                        // Redownload the icon from Steam
                        const res = await serverApi.callPluginMethod('set_steam_icon_from_url', {
                            appid: appId,
                            url: window.appStore.GetIconURLForApp(appOverview),
                        });
                        if (!res.success)
                            throw new Error(res.result);
                    }
                }
            }
            else {
                await SteamClient.Apps.ClearCustomArtworkForApp(appId, assetType);
                // ClearCustomArtworkForApp() resolves instantly instead of after clearing, so we need to wait a bit.
                await new Promise((resolve) => setTimeout(resolve, 500));
            }
        }, [appId, appOverview, serverApi]);
        const changeAsset = React.useCallback(async (data, assetType) => {
            assetType = getAmbiguousAssetType(assetType);
            try {
                await clearAsset(assetType);
                await SteamClient.Apps.SetCustomArtworkForApp(appId, data, 'png', assetType);
            }
            catch (error) {
            }
        }, [appId, clearAsset]);
        const apiRequest = React.useCallback((url, signal) => {
            return new Promise((resolve, reject) => {
                if (signal?.aborted)
                    return reject(new DOMException('Aborted', 'AbortError'));
                const abortHandler = () => {
                    reject(new DOMException('Aborted', 'AbortError'));
                };
                signal?.addEventListener('abort', abortHandler);
                serverApi.fetchNoCors(`${API_BASE}${url}`, {
                    method: 'GET',
                    headers: {
                        Accept: 'application/json',
                        Authorization: `Bearer ${SGDB_API_KEY}`,
                    },
                }).then((res) => {
                    if (!res.success) {
                        return reject(new Error('SGDB API request failed'));
                    }
                    try {
                        const assetRes = JSON.parse(res.result.body);
                        if (!assetRes.success) {
                            const apiErr = new Error(assetRes.errors.join(', '));
                            apiErr.status = res.result.status;
                            return reject(apiErr);
                        }
                        return resolve(assetRes.data);
                    }
                    catch (err) {
                        return reject(new Error(err.message));
                    }
                }).finally(() => {
                    signal?.removeEventListener('abort', abortHandler);
                });
            });
        }, [serverApi]);
        const getImageAsB64 = React.useCallback(async (location, path = false) => {
            let download;
            if (path) {
                download = await serverApi.callPluginMethod('read_file_as_base64', { path: location });
            }
            else {
                download = await serverApi.callPluginMethod('download_as_base64', { url: location });
            }
            if (!download.success) {
                return null;
            }
            return download.result;
        }, [serverApi]);
        const changeAssetFromUrl = React.useCallback(async (url, assetType, path = false) => {
            assetType = getAmbiguousAssetType(assetType);
            if (assetType === ASSET_TYPE.icon) {
                if (appOverview?.BIsShortcut()) {
                    const res = await serverApi.callPluginMethod(path ? 'set_shortcut_icon_from_path' : 'set_shortcut_icon_from_url', {
                        owner_id: getCurrentSteamUserId(),
                        appid: appId,
                        ...(path ? { path: url } : { url }),
                    });
                    if (!res.success)
                        throw new Error(res.result);
                    log('set_shortcut_icon result', res.result);
                    if (res.result === 'icon_is_same_path') {
                        // If the path is already the same as the current icon, we can force an icon re-read by setting the name to itself
                        SteamClient.Apps.SetShortcutName(appOverview.appid, appOverview.display_name);
                    }
                    else if (res.result === true) {
                        // shortcuts.vdf was modified, can't figure out how to make Steam re-read it so just ask user to reboot
                        showRestartConfirm();
                    }
                }
                else {
                    // Change default Steam icon by poisoning the cache like Boop does it
                    const res = await serverApi.callPluginMethod(path ? 'set_steam_icon_from_path' : 'set_steam_icon_from_url', {
                        appid: appId,
                        ...(path ? { path: url } : { url }),
                    });
                    log('set_steam_icon result', res.result);
                }
            }
            else {
                const data = await getImageAsB64(url, path);
                if (!data) {
                    throw new Error('Failed to retrieve asset');
                }
                await changeAsset(data, assetType);
            }
        }, [appId, appOverview, changeAsset, getImageAsB64, serverApi]);
        const searchGames = React.useCallback(async (term) => {
            try {
                const res = await apiRequest(`/search/autocomplete/${encodeURIComponent(term)}`);
                log('search games', res);
                return res;
            }
            catch (err) {
                serverApi.toaster.toast({
                    title: 'SteamGridDB API Error',
                    body: err.message,
                    icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                });
                return [];
            }
        }, [apiRequest, serverApi.toaster]);
        const searchAssets = React.useCallback(async (assetType, { gameId, filters = null, page = 0, signal }) => {
            let type = '';
            switch (assetType) {
                case 'grid_p':
                case 'grid_l':
                    type = 'grids';
                    break;
                case 'hero':
                    type = 'heroes';
                    break;
                case 'icon':
                    type = 'icons';
                    break;
                case 'logo':
                    type = 'logos';
                    break;
            }
            const qs = getApiParams(assetType, filters, page);
            return await apiRequest(`/${type}/${gameId ? 'game' : 'steam'}/${gameId ?? appId}?${qs}`, signal);
        }, [apiRequest, appId]);
        const getSgdbGame = React.useCallback(async (game) => {
            try {
                const gameRes = await apiRequest(`/games/id/${game.id}`);
                log('sgdb game', gameRes);
                return gameRes;
            }
            catch (err) {
                serverApi.toaster.toast({
                    title: 'SteamGridDB API Error',
                    body: err.message,
                    icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                });
                return [];
            }
        }, [apiRequest, serverApi.toaster]);
        React.useEffect(() => {
            if (appId) {
                (async () => {
                    // Get details before overview or some games will be null.
                    await getAppDetails(appId);
                    const overview = await getAppOverview(appId);
                    setAppOverview(overview);
                })();
            }
        }, [appId]);
        const value = React.useMemo(() => ({
            appId,
            serverApi,
            appOverview,
            setAppId,
            searchAssets,
            searchGames,
            getSgdbGame,
            changeAsset,
            changeAssetFromUrl,
            clearAsset,
        }), [appId, serverApi, appOverview, searchAssets, searchGames, getSgdbGame, changeAsset, changeAssetFromUrl, clearAsset]);
        return (window.SP_REACT.createElement(SGDBContext.Provider, { value: value }, children));
    };
    const useSGDB = () => React.useContext(SGDBContext);

    var Spinner = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/spinner-667847d4.svg';

    // @todo: find a better way to get this
    const ErrorIcon = Object.values(IconsModule).find((mod) => mod?.toString().includes('M27.7974 10L26.6274 2H33.3674L32.2374 10H27.7974Z'));
    const LazyImage = ({ isVideo = false, unloadWhenOutside = false, marginOffset, scrollContainer, src, wrapperProps, ...props }) => {
        const [inViewport, setInViewport] = React.useState(false);
        const [loading, setLoading] = React.useState(true);
        const [error, setError] = React.useState(false);
        const imgRef = React.useRef(null);
        const intersectRef = React.useRef(null);
        React.useEffect(() => {
            if (!imgRef.current)
                return;
            const img = imgRef.current;
            const onLoad = () => {
                if (isVideo) {
                    img.play();
                }
                setLoading(false);
            };
            const onError = () => setError(true);
            if (isVideo) {
                img.addEventListener('canplaythrough', onLoad);
            }
            else {
                img.addEventListener('load', onLoad);
            }
            img.addEventListener('error', onError);
            return () => {
                if (isVideo) {
                    img.removeEventListener('canplaythrough', onLoad);
                }
                else {
                    img.removeEventListener('load', onLoad);
                }
                img.removeEventListener('error', onError);
            };
        }, [src, isVideo, inViewport]);
        React.useEffect(() => {
            if (!intersectRef.current)
                return;
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting && entry.intersectionRatio >= .5) {
                        setInViewport(true);
                        if (!unloadWhenOutside) {
                            observer.unobserve(entry.target);
                        }
                    }
                    else if (unloadWhenOutside && !loading && entry.intersectionRatio === 0) {
                        /* If completely out of view and already loaded, reset state.
                           images/videos should be cached by CEF so when back to view they will load instantly */
                        setInViewport(false);
                        setLoading(true);
                    }
                });
            }, { threshold: [.5, 0], rootMargin: marginOffset, root: scrollContainer });
            observer.observe(intersectRef.current);
            return () => {
                observer.disconnect();
            };
        }, [loading, marginOffset, unloadWhenOutside, scrollContainer]);
        return (window.SP_REACT.createElement("div", { ref: intersectRef, style: {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
            }, ...wrapperProps },
            error ?
                window.SP_REACT.createElement(ErrorIcon, { style: { height: '2em' } }) : (window.SP_REACT.createElement(Spinner$1, { className: "preload-spinner", "data-loaded": loading ? 'false' : 'true' })),
            (inViewport && !isVideo && error !== true) && (window.SP_REACT.createElement("img", { ref: imgRef, "data-loaded": loading ? 'false' : 'true', src: src, ...props })),
            (inViewport && isVideo && error !== true) && (window.SP_REACT.createElement("video", { ref: imgRef, "data-loaded": loading ? 'false' : 'true', src: src, autoPlay: false, muted: true, loop: true, playsInline: true, ...props }))));
    };

    const Chips = ({ children }) => {
        const chipsRef = React.useRef(null);
        const [leftAlign, setLeftAlign] = React.useState(false);
        const isCutOff = React.useCallback(() => {
            const el = chipsRef.current;
            if (!el)
                return false;
            const sizeEl = el.parentElement; // element we can check size aginst
            if (sizeEl) {
                return sizeEl.getBoundingClientRect().right + el.clientWidth + 10 > findSP().innerWidth;
            }
            return false;
        }, []);
        // Check if should switch to left aligned every time size is changed
        React.useLayoutEffect(() => {
            const el = chipsRef.current;
            if (!el)
                return;
            const observer = new MutationObserver(justDebounce((mutations) => {
                if (mutations[0].attributeName === 'style') {
                    if (el.parentElement) {
                        setLeftAlign(isCutOff());
                    }
                }
            }, 500));
            const assetContainer = el.closest('#images-container');
            if (assetContainer) {
                observer.observe(assetContainer, { attributes: true });
            }
            // Inital
            setLeftAlign(isCutOff());
            return () => {
                observer.disconnect();
            };
        }, [isCutOff]);
        return window.SP_REACT.createElement("ul", { ref: chipsRef, className: joinClassNames('chips', leftAlign ? 'chips-left' : '') }, children);
    };

    const Chip = ({ color, children }) => (window.SP_REACT.createElement("li", { className: "chip", style: {
            ['--chip-color']: color,
        } }, children));

    const Asset = ({ assetType, width, height, src, author, isAnimated, onActivate, isDownloading = false, scrollContainer, notes = null, nsfw, humor, epilepsy, ...rest }) => (window.SP_REACT.createElement("div", { className: "asset-box-wrap" },
        window.SP_REACT.createElement(Focusable, { onActivate: onActivate, className: joinClassNames('image-wrap', `type-${assetType}`), style: { paddingBottom: `${(width === height) ? 100 : (height / width * 100)}%` }, ...rest },
            window.SP_REACT.createElement("div", { className: joinClassNames('dload-overlay', isDownloading ? 'downloading' : '') },
                window.SP_REACT.createElement("img", { src: Spinner })),
            window.SP_REACT.createElement(Chips, null,
                notes && (window.SP_REACT.createElement(Chip, { color: "#8a8a8a" },
                    window.SP_REACT.createElement(FooterGlyph, { button: 11, type: 0, size: 0, style: { width: '1em' } }),
                    " ",
                    trans_string('LABEL_NOTES', 'Notes'))),
                isAnimated && (window.SP_REACT.createElement(Chip, { color: "#e2a256" }, trans_string('LABEL_ANIMATED', 'Animated'))),
                nsfw && (window.SP_REACT.createElement(Chip, { color: "#e5344c" }, trans_string('LABEL_NSFW', 'Adult Content'))),
                humor && (window.SP_REACT.createElement(Chip, { color: "#eec314" }, trans_string('LABEL_HUMOR', 'Humor'))),
                epilepsy && (window.SP_REACT.createElement(Chip, { color: "#735f9f" }, trans_string('LABEL_EPILEPSY', 'Epilepsy')))),
            window.SP_REACT.createElement(LazyImage, { src: src, isVideo: isAnimated, scrollContainer: scrollContainer, wrapperProps: {
                    className: 'thumb',
                }, marginOffset: "100px", unloadWhenOutside: true })),
        author && (window.SP_REACT.createElement("div", { className: "author" },
            window.SP_REACT.createElement(LazyImage, { src: author.avatar, alt: "" }),
            window.SP_REACT.createElement("span", null, author.name)))));

    /* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

    var hasElementType = typeof Element !== 'undefined';
    var hasMap = typeof Map === 'function';
    var hasSet = typeof Set === 'function';
    var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

    // Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

    function equal(a, b) {
      // START: fast-deep-equal es6/index.js 3.1.3
      if (a === b) return true;

      if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;

        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0;)
            if (!equal(a[i], b[i])) return false;
          return true;
        }

        // START: Modifications:
        // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
        //    to co-exist with es5.
        // 2. Replace `for of` with es5 compliant iteration using `for`.
        //    Basically, take:
        //
        //    ```js
        //    for (i of a.entries())
        //      if (!b.has(i[0])) return false;
        //    ```
        //
        //    ... and convert to:
        //
        //    ```js
        //    it = a.entries();
        //    while (!(i = it.next()).done)
        //      if (!b.has(i.value[0])) return false;
        //    ```
        //
        //    **Note**: `i` access switches to `i.value`.
        var it;
        if (hasMap && (a instanceof Map) && (b instanceof Map)) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b.get(i.value[0]))) return false;
          return true;
        }

        if (hasSet && (a instanceof Set) && (b instanceof Set)) {
          if (a.size !== b.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b.has(i.value[0])) return false;
          return true;
        }
        // END: Modifications

        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0;)
            if (a[i] !== b[i]) return false;
          return true;
        }

        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        // START: Modifications:
        // Apply guards for `Object.create(null)` handling. See:
        // - https://github.com/FormidableLabs/react-fast-compare/issues/64
        // - https://github.com/epoberezkin/fast-deep-equal/issues/49
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
        // END: Modifications

        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;)
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        // END: fast-deep-equal

        // START: react-fast-compare
        // custom handling for DOM elements
        if (hasElementType && a instanceof Element) return false;

        // custom handling for React/Preact
        for (i = length; i-- !== 0;) {
          if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
            // React-specific: avoid traversing React elements' _owner
            // Preact-specific: avoid traversing Preact elements' __v and __o
            //    __v = $_original / $_vnode
            //    __o = $_owner
            // These properties contain circular references and are not needed when
            // comparing the actual elements (and not their owners)
            // .$$typeof and ._store on just reasonable markers of elements

            continue;
          }

          // all other properties should be traversed as usual
          if (!equal(a[keys[i]], b[keys[i]])) return false;
        }
        // END: react-fast-compare

        // START: fast-deep-equal
        return true;
      }

      return a !== a && b !== b;
    }
    // end fast-deep-equal

    var reactFastCompare = function isEqual(a, b) {
      try {
        return equal(a, b);
      } catch (error) {
        if (((error.message || '').match(/stack|recursion/i))) {
          // warn on circular references, don't crash
          // browsers give this different errors name and messages:
          // chrome/safari: "RangeError", "Maximum call stack size exceeded"
          // firefox: "InternalError", too much recursion"
          // edge: "Error", "Out of stack space"
          console.warn('react-fast-compare cannot handle circular refs');
          return false;
        }
        // some other error. we should definitely know about these
        throw error;
      }
    };

    const compareFilterWithDefaults = (assetType, filters) => {
        if (!filters)
            return false;
        // simply cannot be fucked to do this in a better way
        return ((filters?.styles ? !reactFastCompare([...filters.styles].sort(), [...STYLES[assetType].default].sort()) : false) ||
            (filters?.dimensions ? !reactFastCompare([...filters.dimensions].sort(), [...DIMENSIONS[assetType].default].sort()) : false) ||
            (filters?.mimes ? !reactFastCompare([...filters.mimes].sort(), [...MIMES[assetType].default].sort()) : false) ||
            filters?.animated !== true ||
            filters?._static !== true ||
            filters?.humor !== true ||
            filters?.epilepsy !== true ||
            filters?.untagged !== true);
    };

    const FlashpointIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 477 448", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
        window.SP_REACT.createElement("path", { d: "M139.19 366.067l337.498-104.006-451.406-262.053 351.057 259.302-213.405 62.468z" }),
        window.SP_REACT.createElement("path", { d: "M0 17.563l159.080 197.89-114.814 232.561 75.495-23.266c30.089-69.179 60.177-138.354 90.265-207.532l3.925 54.457 93.498-24.157z" })));

    const EshopIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 11 14", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
        window.SP_REACT.createElement("path", { d: "M9.901 1.281c-0.006-0.009-0.017-0.015-0.028-0.015s-0.022 0.006-0.028 0.015l-0 0-1.814 2.508c-0.003 0.004-0.005 0.010-0.005 0.016 0 0.016 0.013 0.028 0.028 0.028 0.004 0 0.008-0.001 0.011-0.002l-0 0 2.683-1.545c0.011-0.007 0.018-0.019 0.018-0.033 0-0.010-0.003-0.018-0.009-0.025l0 0zM7.736 9.492c-0.123 1.192-1.116 2.186-2.517 2.186-0.685 0-1.46-0.283-1.86-0.78l4.941-2.869c1.059-0.613 1.549-1.146 1.091-1.937-0.708-1.12-2.495-2.303-4.425-2.303-2.734 0-4.966 2.422-4.966 5.105 0 2.884 2.527 5.107 5.303 5.107 2.563 0 4.851-1.84 4.977-4.508zM5.137 5.985c0.686 0 1.227 0.245 1.725 0.71l-4.445 2.562c-0.030-0.152-0.047-0.327-0.047-0.505 0-1.528 1.239-2.766 2.766-2.766v0zM7.222 3.244l1.648-2.618c0.003-0.005 0.005-0.011 0.005-0.018 0-0.016-0.010-0.029-0.024-0.035l-0-0-1.201-0.439c-0.004-0.001-0.008-0.002-0.012-0.002-0.018 0-0.033 0.014-0.035 0.032l-0 0-0.426 3.067c-0 0.001-0 0.002-0 0.004 0 0.012 0.008 0.022 0.018 0.026l0 0c0.002 0.001 0.005 0.001 0.007 0.001 0.010 0 0.018-0.007 0.021-0.016l0-0zM6.188 3.153c0.012-0.003 0.021-0.013 0.022-0.026v-0l0.223-3.088c-0.001-0.022-0.018-0.040-0.040-0.040-0.002 0-0.003 0-0.005 0l0-0-1.261 0.179c-0.019 0.001-0.034 0.016-0.034 0.036 0 0.005 0.001 0.010 0.003 0.015l-0-0 1.062 2.904c0.004 0.012 0.014 0.020 0.027 0.020 0.001 0 0.002-0 0.003-0l-0 0z" })));

    const GogIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 14 14", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
        window.SP_REACT.createElement("path", { d: "M12.764 13.382h-11.529c-0.682 0-1.235-0.553-1.235-1.235v0-10.293c0-0.682 0.553-1.235 1.235-1.235v0h11.529c0.682 0 1.235 0.553 1.235 1.235v0 10.293c0 0.682-0.553 1.235-1.235 1.235v0zM1.647 10.706c0 0.341 0.276 0.618 0.618 0.618v0h2.265v-0.824h-1.853c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.853v-0.824h-2.265c-0.341 0-0.618 0.276-0.618 0.618v0zM4.941 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h1.441v-0.824h-1.029c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 2.47c0 0.114-0.092 0.206-0.206 0.206v0h-2.265v0.824h2.676c0.341 0 0.618-0.276 0.618-0.618v0zM4.941 8.647v2.059c0 0.341 0.276 0.618 0.618 0.618v0h2.059c0.341 0 0.618-0.276 0.618-0.618v0-2.059c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0zM8.647 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h2.059c0.341 0 0.618-0.276 0.618-0.618v0zM12.353 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h1.441v-0.824h-1.029c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 2.47c0 0.114-0.092 0.206-0.206 0.206v0h-2.265v0.824h2.676c0.341 0 0.618-0.276 0.618-0.618v0zM12.353 8.029h-3.088c-0.341 0-0.618 0.276-0.618 0.618v0 2.676h0.824v-2.265c0-0.114 0.092-0.206 0.206-0.206v0h0.412v2.47h0.824v-2.47h0.618v2.47h0.824zM7.618 5.147h-1.235c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 1.235c0 0.114-0.092 0.206-0.206 0.206v0zM5.971 8.853h1.235c0.114 0 0.206 0.092 0.206 0.206v0 1.235c0 0.114-0.092 0.206-0.206 0.206v0h-1.235c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0z" })));

    // @todo: find a better way to get this
    const SearchIcon = Object.values(IconsModule).find((mod) => mod?.toString().includes('M27.5 24C29.4972 21.1283 30.3471'));
    const utcYear = (date) => new Date(date * 1000).toLocaleString('en-US', { year: 'numeric', timeZone: 'UTC' });
    const platformTypeMap = {
        steam: SiSteam,
        egs: SiEpicgames,
        origin: SiOrigin,
        uplay: SiUbisoft,
        gog: GogIcon,
        bnet: SiBattledotnet,
        flashpoint: FlashpointIcon,
        eshop: EshopIcon,
    };
    const GameLabel = ({ game }) => (window.SP_REACT.createElement("span", { className: "gamelabel" },
        window.SP_REACT.createElement(Marquee, null, game.name),
        game.release_date && window.SP_REACT.createElement("span", { className: "release-date" },
            "(",
            utcYear(game.release_date),
            ")"),
        (game.types.length > 0) && (window.SP_REACT.createElement("span", { className: "platform-types" }, game.types.map((x) => {
            const PlatformLogo = platformTypeMap[x];
            return window.SP_REACT.createElement(PlatformLogo, { key: x });
        })))));
    const SearchTextField = (props) => {
        const fieldRef = React.useRef();
        const focusableRef = React.useRef();
        const focusTextField = () => {
            const input = fieldRef.current?.m_elInput;
            input?.focus();
            input?.click();
        };
        // Activate <Focusable /> when pressing back on text box
        React.useEffect(() => {
            if (!fieldRef.current)
                return;
            const onCancel = (evt) => {
                evt.stopPropagation(); // stop bubbling or else modal will close
                focusableRef.current?.focus();
            };
            const input = fieldRef.current?.m_elInput;
            input.addEventListener('vgp_oncancel', onCancel);
            input.addEventListener('vgp_onok', onCancel);
            return () => {
                input.removeEventListener('vgp_oncancel', onCancel);
                input.removeEventListener('vgp_onok', onCancel);
            };
        }, [fieldRef]);
        return (window.SP_REACT.createElement(Field, { bottomSeparator: "thick", icon: window.SP_REACT.createElement(SearchIcon, null), label: trans_string('LABEL_GAME_SEARCH_TITLE', 'Search for a Game...'), childrenLayout: "below" },
            window.SP_REACT.createElement(Focusable, { ref: focusableRef, onActivate: focusTextField, noFocusRing: true },
                window.SP_REACT.createElement(TextField
                // @ts-ignore: ref hack to get underlying <input>
                , { 
                    // @ts-ignore: ref hack to get underlying <input>
                    ref: fieldRef, focusOnMount: false, spellcheck: "false", ...props }))));
    };
    const GameSelectionModal = ({ closeModal, onSelect, searchGames, defaultTerm }) => {
        const [value, setValue] = React.useState(defaultTerm);
        const [games, setGames] = React.useState([]);
        const [loading, setLoading] = React.useState(false);
        const handleGameSelect = (game) => {
            onSelect?.(game);
            closeModal?.();
        };
        const handleSearch = React.useMemo(() => justDebounce(async (term) => {
            if (!term) {
                setLoading(false);
                return;
            }
            const resp = await searchGames(term);
            setGames(resp);
            setLoading(false);
        }, 600), [searchGames]);
        React.useEffect(() => {
            setLoading(true);
            handleSearch(value);
        }, [handleSearch, value]);
        return (window.SP_REACT.createElement(ModalRoot, { className: "sgdb-modal sgdb-modal-gameselect", closeModal: closeModal },
            window.SP_REACT.createElement(DialogBody, null,
                window.SP_REACT.createElement(DialogControlsSection, null,
                    window.SP_REACT.createElement(SearchTextField, { value: value, onChange: (evt) => {
                            setValue(evt.target.value);
                        } }),
                    loading && (window.SP_REACT.createElement("div", { className: "spinner" },
                        window.SP_REACT.createElement(Spinner$1, null))),
                    !loading && games.map((game) => (window.SP_REACT.createElement(Field, { key: game.id, bottomSeparator: "none", icon: null, label: null, childrenLayout: "below", inlineWrap: "keep-inline", spacingBetweenLabelAndChild: "none", childrenContainerWidth: "max" },
                        window.SP_REACT.createElement(DialogButton, { onClick: () => handleGameSelect(game) },
                            window.SP_REACT.createElement(GameLabel, { game: game })))))))));
    };

    const FiltersModal = ({ closeModal, assetType, isNonsteam, onSave, defaultFilters, defaultSelectedGame, defaultSearchTerm, searchGames, }) => {
        const [styles, setStyles] = React.useState(defaultFilters?.styles ?? STYLES[assetType].default);
        const [mimes, setMimes] = React.useState(defaultFilters?.mimes ?? MIMES[assetType].default);
        const [dimensions, setDimensions] = React.useState(defaultFilters?.dimensions ?? DIMENSIONS[assetType].default);
        const [animated, setAnimated] = React.useState(defaultFilters?.animated ?? true);
        const [_static, setStatic] = React.useState(defaultFilters?._static ?? true);
        const [adult, setAdult] = React.useState(defaultFilters?.adult ?? false);
        const [humor, setHumor] = React.useState(defaultFilters?.humor ?? true);
        const [epilepsy, setEpilepsy] = React.useState(defaultFilters?.epilepsy ?? true);
        const [untagged, setUntagged] = React.useState(defaultFilters?.untagged ?? true);
        const filters = React.useMemo(() => ({
            styles, dimensions, mimes, animated, _static, adult, humor, epilepsy, untagged,
        }), [styles, dimensions, mimes, animated, _static, adult, humor, epilepsy, untagged]);
        const [selectedGame, setSelectedGame] = React.useState(defaultSelectedGame);
        /* Controls if the adult content desc shows, only want it to show when it gets toggled and not just when `adult` is true. */
        const [adultActivated, setAdultActivated] = React.useState(false);
        const handleStyleSelect = React.useCallback((items) => {
            setStyles(items);
        }, []);
        const handleMimeSelect = React.useCallback((items) => {
            setMimes(items);
        }, []);
        const handleDimensionsSelect = React.useCallback((items) => {
            setDimensions(items);
        }, []);
        const handleClose = () => {
            onSave(assetType, filters, selectedGame);
            closeModal?.();
        };
        const resetFilters = () => {
            setStyles(STYLES[assetType].default);
            setMimes(MIMES[assetType].default);
            setDimensions(DIMENSIONS[assetType].default);
            setAnimated(true);
            setStatic(true);
            setHumor(true);
            setEpilepsy(true);
            setUntagged(true);
        };
        return (window.SP_REACT.createElement(ModalRoot, { className: "sgdb-modal sgdb-modal-filters", closeModal: handleClose },
            window.SP_REACT.createElement(DialogHeader, null, trans_string('LABEL_FILTER_MODAL_TITLE', '{assetType} Filter').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
            window.SP_REACT.createElement(DialogBody, null,
                window.SP_REACT.createElement(DialogControlsSection, null,
                    window.SP_REACT.createElement(Field, { label: trans_string('LABEL_FILTER_GAME', 'Game') },
                        window.SP_REACT.createElement(Focusable, { className: "game-filter-content" },
                            window.SP_REACT.createElement(DialogButton, { className: "custom-game-value", onClick: () => {
                                    showModal(window.SP_REACT.createElement(GameSelectionModal, { defaultTerm: selectedGame?.name || defaultSearchTerm, searchGames: searchGames, onSelect: (game) => {
                                            setSelectedGame(game);
                                        } }));
                                } },
                                window.SP_REACT.createElement(Marquee, null, selectedGame?.name || trans_string('LABEL_GAME_SEARCH_TITLE', 'Search for a Game...'))),
                            (selectedGame && !isNonsteam) && (window.SP_REACT.createElement(DialogButton, { className: "clear-custom-game", onClick: () => setSelectedGame(undefined) },
                                window.SP_REACT.createElement(HiXMark, { strokeWidth: 1.5 }))))),
                    (DIMENSIONS[assetType].options.length > 0) && (window.SP_REACT.createElement(Field, { label: trans_string('LABEL_FILTER_DIMENSIONS', 'Dimensions') },
                        window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_DIMENSIONS', 'Dimensions'), items: DIMENSIONS[assetType].options, selected: dimensions, onSelect: handleDimensionsSelect }))),
                    window.SP_REACT.createElement(Field, { label: trans_string('LABEL_FILTER_STYLES', 'Styles') },
                        window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_STYLES', 'Styles'), items: STYLES[assetType].options, selected: styles, onSelect: handleStyleSelect })),
                    window.SP_REACT.createElement(Field, { label: trans_string('LABEL_FILTER_FILE_TYPES', 'File Types') },
                        window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_FILE_TYPES', 'File Types'), items: MIMES[assetType].options, selected: mimes, onSelect: handleMimeSelect }))),
                window.SP_REACT.createElement(DialogControlsSection, null,
                    window.SP_REACT.createElement(DialogControlsSectionHeader, null, trans_string('LABEL_FILTER_ANIMATION_TYPE_TITLE', 'Types')),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TYPE_ANIMATED', 'Animated'), checked: animated, onChange: (checked) => {
                            if (!_static && !checked) {
                                setStatic(true);
                                setAnimated(false);
                            }
                            else {
                                setAnimated(checked);
                            }
                        } }),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TYPE_STATIC', 'Static'), checked: _static, onChange: (checked) => {
                            if (!animated && !checked) {
                                setAnimated(true);
                                setStatic(false);
                            }
                            else {
                                setStatic(checked);
                            }
                        } })),
                window.SP_REACT.createElement(DialogControlsSection, null,
                    window.SP_REACT.createElement(DialogControlsSectionHeader, null, trans_string('LABEL_FILTER_TAGS_TITLE', 'Tags')),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TAG_NSFW', 'Adult Content'), description: adultActivated ? trans_string('MSG_FILTER_TAG_NSFW_ENABLED', 'Might wanna do a quick shoulder check.') : undefined, checked: adult, onChange: (checked) => {
                            setAdult(checked);
                            setAdultActivated(checked);
                        } }),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TAG_HUMOR', 'Humor'), checked: humor, onChange: setHumor }),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TAG_EPILEPSY', 'Epilepsy'), checked: epilepsy, onChange: setEpilepsy }),
                    window.SP_REACT.createElement(ToggleField, { label: trans_string('LABEL_FILTER_TAG_UNTAGGED', 'Untagged'), checked: untagged, onChange: setUntagged }))),
            compareFilterWithDefaults(assetType, filters) && (window.SP_REACT.createElement(DialogFooter, null,
                window.SP_REACT.createElement(DialogButton, { onClick: resetFilters }, trans_string('ACTION_FILTER_RESET', 'Reset Filters'))))));
    };

    const SearchContext = React.createContext({});
    let abortCont = null;
    const AssetSearchContext = ({ children }) => {
        const { set, get } = useSettings();
        const { appId, searchAssets, searchGames, getSgdbGame, appOverview, serverApi } = useSGDB();
        const [assets, setAssets] = React.useState([]);
        const [currentFilters, setCurrentFilters] = React.useState();
        const [isFilterActive, setIsFilterActive] = React.useState(false);
        const [loading, setLoading] = React.useState(false);
        const [selectedGame, setSelectedGame] = React.useState();
        const [externalSgdbData, setExternalSgdbData] = React.useState(null);
        const [page, setPage] = React.useState(0);
        const showGameSelection = React.useCallback(() => {
            showModal(window.SP_REACT.createElement(GameSelectionModal, { defaultTerm: appOverview.display_name, searchGames: searchGames, onSelect: (game) => {
                    setSelectedGame(game);
                    set(`nonsteam_${appId}`, game);
                } }));
        }, [appId, appOverview.display_name, searchGames, set]);
        const searchAndSetAssets = React.useMemo(() => justDebounce(async (assetType, filters, onSuccess) => {
            if (appOverview?.BIsModOrShortcut() && !selectedGame)
                return;
            if (abortCont)
                abortCont?.abort();
            abortCont = new AbortController();
            try {
                setCurrentFilters(filters);
                setIsFilterActive(compareFilterWithDefaults(assetType, filters));
                const resp = await searchAssets(assetType, {
                    gameId: selectedGame?.id,
                    filters,
                    signal: abortCont.signal,
                });
                log('search resp', assetType, resp);
                setAssets(resp);
                onSuccess?.();
            }
            catch (err) {
                if (err.name === 'AbortError') ;
                else if (err?.status === 404) {
                    showGameSelection();
                }
                else {
                    serverApi.toaster.toast({
                        title: 'SteamGridDB API Error',
                        body: err.message,
                        icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                    });
                    if (selectedGame) {
                        set(`nonsteam_${appId}`, false);
                    }
                }
            }
        }, 500), [appId, appOverview, searchAssets, showGameSelection, selectedGame, serverApi.toaster, set]);
        const loadMore = React.useMemo(() => justDebounce(async (assetType, onSuccess) => {
            if (appOverview?.BIsModOrShortcut() && !selectedGame)
                return;
            if (abortCont)
                abortCont?.abort();
            abortCont = new AbortController();
            if (assets.length === 0)
                return;
            try {
                const resp = await searchAssets(assetType, {
                    page: page + 1,
                    gameId: selectedGame?.id,
                    filters: currentFilters,
                    signal: abortCont.signal,
                });
                log('search load more resp', resp);
                setAssets((assets) => [...assets, ...resp]);
                onSuccess?.(resp);
                setPage((x) => x + 1);
            }
            catch (err) {
                if (err.name === 'AbortError') ;
                else {
                    serverApi.toaster.toast({
                        title: 'SteamGridDB API Error',
                        body: err.message,
                        icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                    });
                }
            }
        }, 500), [appOverview, assets.length, currentFilters, page, searchAssets, selectedGame, serverApi.toaster]);
        const handleFiltersSave = React.useCallback(async (assetType, filters, game) => {
            if (!reactFastCompare(filters, currentFilters)) {
                setLoading(true);
                searchAndSetAssets(assetType, filters, () => {
                    setLoading(false);
                });
                set(`filters_${assetType}`, filters, true);
                setCurrentFilters(filters);
            }
            if (game?.id !== selectedGame?.id) {
                setSelectedGame(game);
                // save selected game to reuse for this shortcut
                set(`nonsteam_${appId}`, game);
            }
            setIsFilterActive(compareFilterWithDefaults(assetType, filters));
        }, [currentFilters, selectedGame, searchAndSetAssets, set, appId]);
        const openFilters = React.useCallback(async (assetType) => {
            const defaultFilters = await get(`filters_${assetType}`, null);
            showModal((window.SP_REACT.createElement(FiltersModal, { assetType: assetType, onSave: handleFiltersSave, defaultFilters: defaultFilters, defaultSelectedGame: selectedGame, defaultSearchTerm: selectedGame?.name || appOverview.display_name, isNonsteam: appOverview.BIsModOrShortcut(), searchGames: searchGames })), window);
        }, [appOverview, get, handleFiltersSave, searchGames, selectedGame]);
        React.useEffect(() => {
            if (!appOverview)
                return;
            (async () => {
                setLoading(true);
                const game = await get(`nonsteam_${appId}`, false);
                if (game) {
                    setSelectedGame(game);
                }
                else {
                    if (appOverview.BIsModOrShortcut()) {
                        const gameRes = await searchGames(appOverview.display_name);
                        if (gameRes.length) {
                            setSelectedGame(gameRes[0]);
                        }
                        else {
                            showGameSelection();
                        }
                    }
                }
                setLoading(false);
            })();
        }, [appOverview, appId, get, searchGames, set, showGameSelection]);
        React.useEffect(() => {
            if (!selectedGame)
                return;
            (async () => {
                const sgdbGame = await getSgdbGame(selectedGame);
                setExternalSgdbData(sgdbGame.external_platform_data);
            })();
        }, [getSgdbGame, selectedGame]);
        const value = React.useMemo(() => ({
            loading,
            assets,
            searchAndSetAssets,
            loadMore,
            selectedGame,
            externalSgdbData,
            openFilters,
            isFilterActive,
        }), [loading, assets, searchAndSetAssets, loadMore, selectedGame, externalSgdbData, openFilters, isFilterActive]);
        return (window.SP_REACT.createElement(SearchContext.Provider, { value: value }, children));
    };
    const useAssetSearch = () => React.useContext(SearchContext);

    const sliderProps = {
        grid_p: {
            min: 100,
            max: 200,
            step: 5,
        },
        grid_l: {
            min: 160,
            max: 280,
            step: 5,
        },
        hero: {
            min: 2,
            max: 4,
            step: 1,
            notchCount: 3,
            notchTicksVisible: true,
        },
        logo: {
            min: 2,
            max: 6,
            step: 1,
            notchCount: 5,
            notchTicksVisible: true,
        },
        icon: {
            min: 100,
            max: 200,
            step: 5,
        },
    };
    const defaultSliderSizes = {
        grid_p: 150,
        grid_l: 200,
        hero: 3,
        logo: 4,
        icon: 120,
    };
    // map SGDBAssetType to steam response
    const defaultAssetMap = {
        grid_p: 'library_capsule',
        grid_l: 'header_image',
        hero: 'library_hero',
        logo: 'library_logo',
    };
    const Toolbar = React.forwardRef(({ assetType, onSizeChange, onFilterClick, onOfficialAssetsClick, onLogoPosClick, disabled = false, noFocusRing, }, ref) => {
        const { externalSgdbData } = useAssetSearch();
        const { set, get } = useSettings();
        const [sliderValue, setSliderValue] = React.useState(120);
        const toolbarFocusRef = React.useRef(null);
        const handleSliderChange = (size) => {
            setSliderValue(size);
            set(`zoomlevel_${assetType}`, size);
        };
        const assetSizeStyleAttr = React.useMemo(() => {
            if (['hero', 'logo'].includes(assetType)) {
                const percent = 100 / (sliderProps[assetType].max - sliderValue + sliderProps[assetType].min);
                return {
                    gridTemplateColumns: `repeat(auto-fill, minmax(calc(${percent}% - .65em), 1fr))`,
                };
            }
            return {
                ['--asset-size']: `${sliderValue}px`,
            };
        }, [assetType, sliderValue]);
        React.useImperativeHandle(ref, () => ({
            focus: () => {
                toolbarFocusRef.current?.focus();
            },
            assetSizeStyleAttr,
        }), [assetSizeStyleAttr]);
        React.useEffect(() => {
            onSizeChange?.(assetSizeStyleAttr);
        }, [assetSizeStyleAttr, onSizeChange]);
        // Set initial slider value from config or default
        React.useEffect(() => {
            (async () => {
                const defSize = await get(`zoomlevel_${assetType}`, defaultSliderSizes[assetType]);
                setSliderValue(defSize);
            })();
        }, [assetType, get]);
        if (disabled)
            return null;
        return (window.SP_REACT.createElement(Focusable, { noFocusRing: noFocusRing, className: "settings-container", focusClassName: "force-show", focusWithinClassName: "force-show", onSecondaryActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onOKActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onSecondaryButton: onFilterClick, onActivate: () => toolbarFocusRef.current?.focus(), onClick: (evt) => evt.preventDefault() },
            window.SP_REACT.createElement(Focusable, { className: "sgdb-asset-toolbar" },
                window.SP_REACT.createElement(Focusable, { className: "filter-buttons" },
                    window.SP_REACT.createElement(DialogButton, { ref: toolbarFocusRef, style: { flex: 0 }, noFocusRing: true, onOKActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onClick: onFilterClick }, trans_string('ACTION_OPEN_FILTER', 'Filter')),
                    (externalSgdbData &&
                        externalSgdbData.length > 0 &&
                        externalSgdbData[0].metadata[defaultAssetMap[assetType]]) && (window.SP_REACT.createElement(DialogButton, { noFocusRing: true, onOKActionDescription: trans_string('ACTION_OPEN_OFFICIAL_ASSETS', 'Official {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]), onClick: onOfficialAssetsClick }, trans_string('ACTION_OPEN_OFFICIAL_ASSETS', 'Official {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]))),
                    assetType === 'logo' && (window.SP_REACT.createElement(DialogButton, { noFocusRing: true, onOKActionDescription: trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true), onClick: onLogoPosClick }, trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true)))),
                window.SP_REACT.createElement(SliderField, { className: "size-slider", onChange: handleSliderChange, value: sliderValue, layout: "below", bottomSeparator: "none", ...sliderProps[assetType] }))));
    });
    Toolbar.displayName = 'Toolbar';

    const protocols = ['http', 'https', 'mailto', 'tel'];

    /**
     * @param {string} uri
     * @returns {string}
     */
    function uriTransformer(uri) {
      const url = (uri || '').trim();
      const first = url.charAt(0);

      if (first === '#' || first === '/') {
        return url
      }

      const colon = url.indexOf(':');
      if (colon === -1) {
        return url
      }

      let index = -1;

      while (++index < protocols.length) {
        const protocol = protocols[index];

        if (
          colon === protocol.length &&
          url.slice(0, protocol.length).toLowerCase() === protocol
        ) {
          return url
        }
      }

      index = url.indexOf('?');
      if (index !== -1 && colon > index) {
        return url
      }

      index = url.indexOf('#');
      if (index !== -1 && colon > index) {
        return url
      }

      // eslint-disable-next-line no-script-url
      return 'javascript:void(0)'
    }

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    var isBuffer = function isBuffer (obj) {
      return obj != null && obj.constructor != null &&
        typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    };

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Point} Point
     * @typedef {import('unist').Position} Position
     */

    /**
     * @typedef NodeLike
     * @property {string} type
     * @property {PositionLike | null | undefined} [position]
     *
     * @typedef PositionLike
     * @property {PointLike | null | undefined} [start]
     * @property {PointLike | null | undefined} [end]
     *
     * @typedef PointLike
     * @property {number | null | undefined} [line]
     * @property {number | null | undefined} [column]
     * @property {number | null | undefined} [offset]
     */

    /**
     * Serialize the positional info of a point, position (start and end points),
     * or node.
     *
     * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]
     *   Node, position, or point.
     * @returns {string}
     *   Pretty printed positional info of a node (`string`).
     *
     *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)
     *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for
     *   column, `s` for `start`, and `e` for end.
     *   An empty string (`''`) is returned if the given value is neither `node`,
     *   `position`, nor `point`.
     */
    function stringifyPosition(value) {
      // Nothing.
      if (!value || typeof value !== 'object') {
        return ''
      }

      // Node.
      if ('position' in value || 'type' in value) {
        return position$1(value.position)
      }

      // Position.
      if ('start' in value || 'end' in value) {
        return position$1(value)
      }

      // Point.
      if ('line' in value || 'column' in value) {
        return point$2(value)
      }

      // ?
      return ''
    }

    /**
     * @param {Point | PointLike | null | undefined} point
     * @returns {string}
     */
    function point$2(point) {
      return index$1(point && point.line) + ':' + index$1(point && point.column)
    }

    /**
     * @param {Position | PositionLike | null | undefined} pos
     * @returns {string}
     */
    function position$1(pos) {
      return point$2(pos && pos.start) + '-' + point$2(pos && pos.end)
    }

    /**
     * @param {number | null | undefined} value
     * @returns {number}
     */
    function index$1(value) {
      return value && typeof value === 'number' ? value : 1
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Position} Position
     * @typedef {import('unist').Point} Point
     * @typedef {object & {type: string, position?: Position | undefined}} NodeLike
     */

    /**
     * Message.
     */
    class VFileMessage extends Error {
      /**
       * Create a message for `reason` at `place` from `origin`.
       *
       * When an error is passed in as `reason`, the `stack` is copied.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       *
       *   >  **Note**: you should use markdown.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns
       *   Instance of `VFileMessage`.
       */
      // To do: next major: expose `undefined` everywhere instead of `null`.
      constructor(reason, place, origin) {
        /** @type {[string | null, string | null]} */
        const parts = [null, null];
        /** @type {Position} */
        let position = {
          // @ts-expect-error: we always follows the structure of `position`.
          start: {line: null, column: null},
          // @ts-expect-error: "
          end: {line: null, column: null}
        };

        super();

        if (typeof place === 'string') {
          origin = place;
          place = undefined;
        }

        if (typeof origin === 'string') {
          const index = origin.indexOf(':');

          if (index === -1) {
            parts[1] = origin;
          } else {
            parts[0] = origin.slice(0, index);
            parts[1] = origin.slice(index + 1);
          }
        }

        if (place) {
          // Node.
          if ('type' in place || 'position' in place) {
            if (place.position) {
              // To do: next major: deep clone.
              // @ts-expect-error: looks like a position.
              position = place.position;
            }
          }
          // Position.
          else if ('start' in place || 'end' in place) {
            // @ts-expect-error: looks like a position.
            // To do: next major: deep clone.
            position = place;
          }
          // Point.
          else if ('line' in place || 'column' in place) {
            // To do: next major: deep clone.
            position.start = place;
          }
        }

        // Fields from `Error`.
        /**
         * Serialized positional info of error.
         *
         * On normal errors, this would be something like `ParseError`, buit in
         * `VFile` messages we use this space to show where an error happened.
         */
        this.name = stringifyPosition(place) || '1:1';

        /**
         * Reason for message.
         *
         * @type {string}
         */
        this.message = typeof reason === 'object' ? reason.message : reason;

        /**
         * Stack of message.
         *
         * This is used by normal errors to show where something happened in
         * programming code, irrelevant for `VFile` messages,
         *
         * @type {string}
         */
        this.stack = '';

        if (typeof reason === 'object' && reason.stack) {
          this.stack = reason.stack;
        }

        /**
         * Reason for message.
         *
         * >  **Note**: you should use markdown.
         *
         * @type {string}
         */
        this.reason = this.message;

        /* eslint-disable no-unused-expressions */
        /**
         * State of problem.
         *
         * * `true`  marks associated file as no longer processable (error)
         * * `false`  necessitates a (potential) change (warning)
         * * `null | undefined`  for things that might not need changing (info)
         *
         * @type {boolean | null | undefined}
         */
        this.fatal;

        /**
         * Starting line of error.
         *
         * @type {number | null}
         */
        this.line = position.start.line;

        /**
         * Starting column of error.
         *
         * @type {number | null}
         */
        this.column = position.start.column;

        /**
         * Full unist position.
         *
         * @type {Position | null}
         */
        this.position = position;

        /**
         * Namespace of message (example: `'my-package'`).
         *
         * @type {string | null}
         */
        this.source = parts[0];

        /**
         * Category of message (example: `'my-rule'`).
         *
         * @type {string | null}
         */
        this.ruleId = parts[1];

        /**
         * Path of a file (used throughout the `VFile` ecosystem).
         *
         * @type {string | null}
         */
        this.file;

        // The following fields are well known.
        // Not standard.
        // Feel free to add other non-standard fields to your messages.

        /**
         * Specify the source value thats being reported, which is deemed
         * incorrect.
         *
         * @type {string | null}
         */
        this.actual;

        /**
         * Suggest acceptable values that can be used instead of `actual`.
         *
         * @type {Array<string> | null}
         */
        this.expected;

        /**
         * Link to docs for the message.
         *
         * >  **Note**: this must be an absolute URL that can be passed as `x`
         * > to `new URL(x)`.
         *
         * @type {string | null}
         */
        this.url;

        /**
         * Long form description of the message (you should use markdown).
         *
         * @type {string | null}
         */
        this.note;
        /* eslint-enable no-unused-expressions */
      }
    }

    VFileMessage.prototype.file = '';
    VFileMessage.prototype.name = '';
    VFileMessage.prototype.reason = '';
    VFileMessage.prototype.message = '';
    VFileMessage.prototype.stack = '';
    VFileMessage.prototype.fatal = null;
    VFileMessage.prototype.column = null;
    VFileMessage.prototype.line = null;
    VFileMessage.prototype.source = null;
    VFileMessage.prototype.ruleId = null;
    VFileMessage.prototype.position = null;

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };

    // path.resolve([from ...], to)
    // posix version
    function resolve() {
      var resolvedPath = '',
          resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : '/';

        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');

      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    }
    // path.normalize(path)
    // posix version
    function normalize$1(path) {
      var isPathAbsolute = isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';

      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isPathAbsolute).join('/');

      if (!path && !isPathAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }

      return (isPathAbsolute ? '/' : '') + path;
    }
    // posix version
    function isAbsolute(path) {
      return path.charAt(0) === '/';
    }

    // posix version
    function join() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return normalize$1(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    }


    // path.relative(from, to)
    // posix version
    function relative(from, to) {
      from = resolve(from).substr(1);
      to = resolve(to).substr(1);

      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));

      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));

      return outputParts.join('/');
    }

    var sep = '/';
    var delimiter$1 = ':';

    function dirname(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];

      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }

      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }

      return root + dir;
    }

    function basename(path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    }


    function extname(path) {
      return splitPath(path)[3];
    }
    var path$1 = {
      extname: extname,
      basename: basename,
      dirname: dirname,
      sep: sep,
      delimiter: delimiter$1,
      relative: relative,
      join: join,
      isAbsolute: isAbsolute,
      normalize: normalize$1,
      resolve: resolve
    };
    function filter (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }

    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b' ?
        function (str, start, len) { return str.substr(start, len) } :
        function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;

    /*! https://mths.be/punycode v1.4.1 by @mathias */


    /** Highest positive signed 32-bit float value */
    var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    var base$1 = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'
    var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    var errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    var baseMinusTMin = base$1 - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
      throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map$2(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';
      if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        string = parts[1];
      }
      // Avoid `split(regex)` for IE8 compatibility. See #17.
      string = string.replace(regexSeparators, '\x2E');
      var labels = string.split('.');
      var encoded = map$2(labels, fn).join('.');
      return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
      var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xFC00) == 0xDC00) { // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
      //  0..25 map to ASCII a..z or A..Z
      // 26..35 map to ASCII 0..9
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base$1) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
      var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength,
        /** Cached calculation results */
        handledCPCountPlusOne,
        baseMinusT,
        qMinusT;

      // Convert the input in UCS-2 to Unicode
      input = ucs2decode(input);

      // Cache the length
      inputLength = input.length;

      // Initialize the state
      n = initialN;
      delta = 0;
      bias = initialBias;

      // Handle the basic code points
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }

      handledCPCount = basicLength = output.length;

      // `handledCPCount` is the number of code points that have been handled;
      // `basicLength` is the number of basic code points.

      // Finish the basic string - if it is not empty - with a delimiter
      if (basicLength) {
        output.push(delimiter);
      }

      // Main encoding loop:
      while (handledCPCount < inputLength) {

        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }

          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer
            for (q = delta, k = base$1; /* no condition */ ; k += base$1) {
              t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base$1 - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }

        ++delta;
        ++n;

      }
      return output.join('');
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ?
          'xn--' + encode(string) :
          string;
      });
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.


    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty$1(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var isArray$1 = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function stringifyPrimitive(v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    }

    function stringify$2 (obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return map$1(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray$1(obj[k])) {
            return map$1(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);

      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    }
    function map$1 (xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }

    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };

    function parse$3(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty$1(obj, k)) {
          obj[k] = v;
        } else if (isArray$1(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    }

    // WHATWG API
    global$1.URL;
    global$1.URLSearchParams;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

      // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      };

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && isObject(url) && url instanceof Url) return url;

      var u = new Url;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      return parse$2(this, url, parseQueryString, slashesDenoteHost);
    };

    function parse$2(self, url, parseQueryString, slashesDenoteHost) {
      if (!isString(url)) {
        throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
        splitter =
        (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          self.path = rest;
          self.href = rest;
          self.pathname = simplePath[1];
          if (simplePath[2]) {
            self.search = simplePath[2];
            if (parseQueryString) {
              self.query = parse$3(self.search.substr(1));
            } else {
              self.query = self.search.substr(1);
            }
          } else if (parseQueryString) {
            self.search = '';
            self.query = {};
          }
          return self;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        self.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          self.slashes = true;
        }
      }
      var i, hec, l, p;
      if (!hostlessProtocol[proto] &&
        (slashes || (proto && !slashedProtocol[proto]))) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          self.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;

        self.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        parseHost(self);

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        self.hostname = self.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = self.hostname[0] === '[' &&
          self.hostname[self.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = self.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                self.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (self.hostname.length > hostnameMaxLen) {
          self.hostname = '';
        } else {
          // hostnames are always lower case.
          self.hostname = self.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          self.hostname = toASCII(self.hostname);
        }

        p = self.port ? ':' + self.port : '';
        var h = self.hostname || '';
        self.host = h + p;
        self.href += self.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          self.hostname = self.hostname.substr(1, self.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }


      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        self.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        self.search = rest.substr(qm);
        self.query = rest.substr(qm + 1);
        if (parseQueryString) {
          self.query = parse$3(self.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        self.search = '';
        self.query = {};
      }
      if (rest) self.pathname = rest;
      if (slashedProtocol[lowerProto] &&
        self.hostname && !self.pathname) {
        self.pathname = '/';
      }

      //to support http.request
      if (self.pathname || self.search) {
        p = self.pathname || '';
        var s = self.search || '';
        self.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      self.href = format(self);
      return self;
    }

    function urlFileURLToPath(path) {
      if (typeof path === 'string')
        path = new Url().parse(path);
      else if (!(path instanceof Url))
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + (typeof path) + String(path));
      if (path.protocol !== 'file:')
        throw new TypeError('The URL must be of scheme file');
      return getPathFromURLPosix(path);
    }

    function getPathFromURLPosix(url) {
      const pathname = url.pathname;
      for (let n = 0; n < pathname.length; n++) {
        if (pathname[n] === '%') {
          const third = pathname.codePointAt(n + 2) | 0x20;
          if (pathname[n + 1] === '2' && third === 102) {
            throw new TypeError(
              'must not include encoded / characters'
            );
          }
        }
      }
      return decodeURIComponent(pathname);
    }

    function format(self) {
      var auth = self.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = self.protocol || '',
        pathname = self.pathname || '',
        hash = self.hash || '',
        host = false,
        query = '';

      if (self.host) {
        host = auth + self.host;
      } else if (self.hostname) {
        host = auth + (self.hostname.indexOf(':') === -1 ?
          self.hostname :
          '[' + this.hostname + ']');
        if (self.port) {
          host += ':' + self.port;
        }
      }

      if (self.query &&
        isObject(self.query) &&
        Object.keys(self.query).length) {
        query = stringify$2(self.query);
      }

      var search = self.search || (query && ('?' + query)) || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (self.slashes ||
        (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    }

    Url.prototype.format = function() {
      return format(this);
    };

    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
          result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
        ),
        mustEndAbs = (isRelAbs || isSourceAbs ||
          (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split('/') || [];
      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }
      var authInHost;
      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
          relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          authInHost = result.host && result.host.indexOf('@') > 0 ?
            result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
            (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
        (result.host || relative.host || srcPath.length > 1) &&
        (last === '.' || last === '..') || last === '');

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' &&
        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' ||
        (srcPath[0] && srcPath[0].charAt(0) === '/');

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
          srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || (result.host && srcPath.length);

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
          (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function() {
      return parseHost(this);
    };

    function parseHost(self) {
      var host = self.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          self.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) self.hostname = host;
    }

    /**
     * @typedef URL
     * @property {string} hash
     * @property {string} host
     * @property {string} hostname
     * @property {string} href
     * @property {string} origin
     * @property {string} password
     * @property {string} pathname
     * @property {string} port
     * @property {string} protocol
     * @property {string} search
     * @property {any} searchParams
     * @property {string} username
     * @property {() => string} toString
     * @property {() => string} toJSON
     */

    /**
     * Check if `fileUrlOrPath` looks like a URL.
     *
     * @param {unknown} fileUrlOrPath
     *   File path or URL.
     * @returns {fileUrlOrPath is URL}
     *   Whether its a URL.
     */
    // From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>
    function isUrl(fileUrlOrPath) {
      return (
        fileUrlOrPath !== null &&
        typeof fileUrlOrPath === 'object' &&
        // @ts-expect-error: indexable.
        fileUrlOrPath.href &&
        // @ts-expect-error: indexable.
        fileUrlOrPath.origin
      )
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Position} Position
     * @typedef {import('unist').Point} Point
     * @typedef {import('./minurl.shared.js').URL} URL
     * @typedef {import('../index.js').Data} Data
     * @typedef {import('../index.js').Value} Value
     */

    /**
     * Order of setting (least specific to most), we need this because otherwise
     * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
     * stem can be set.
     *
     * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}
     */
    const order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];

    class VFile {
      /**
       * Create a new virtual file.
       *
       * `options` is treated as:
       *
       * *   `string` or `Buffer`  `{value: options}`
       * *   `URL`  `{path: options}`
       * *   `VFile`  shallow copies its data over to the new file
       * *   `object`  all fields are shallow copied over to the new file
       *
       * Path related fields are set in the following order (least specific to
       * most specific): `history`, `path`, `basename`, `stem`, `extname`,
       * `dirname`.
       *
       * You cannot set `dirname` or `extname` without setting either `history`,
       * `path`, `basename`, or `stem` too.
       *
       * @param {Compatible | null | undefined} [value]
       *   File value.
       * @returns
       *   New instance.
       */
      constructor(value) {
        /** @type {Options | VFile} */
        let options;

        if (!value) {
          options = {};
        } else if (typeof value === 'string' || buffer(value)) {
          options = {value};
        } else if (isUrl(value)) {
          options = {path: value};
        } else {
          options = value;
        }

        /**
         * Place to store custom information (default: `{}`).
         *
         * Its OK to store custom data directly on the file but moving it to
         * `data` is recommended.
         *
         * @type {Data}
         */
        this.data = {};

        /**
         * List of messages associated with the file.
         *
         * @type {Array<VFileMessage>}
         */
        this.messages = [];

        /**
         * List of filepaths the file moved between.
         *
         * The first is the original path and the last is the current path.
         *
         * @type {Array<string>}
         */
        this.history = [];

        /**
         * Base of `path` (default: `process.cwd()` or `'/'` in browsers).
         *
         * @type {string}
         */
        this.cwd = browser$1.cwd();

        /* eslint-disable no-unused-expressions */
        /**
         * Raw value.
         *
         * @type {Value}
         */
        this.value;

        // The below are non-standard, they are well-known.
        // As in, used in several tools.

        /**
         * Whether a file was saved to disk.
         *
         * This is used by vfile reporters.
         *
         * @type {boolean}
         */
        this.stored;

        /**
         * Custom, non-string, compiled, representation.
         *
         * This is used by unified to store non-string results.
         * One example is when turning markdown into React nodes.
         *
         * @type {unknown}
         */
        this.result;

        /**
         * Source map.
         *
         * This type is equivalent to the `RawSourceMap` type from the `source-map`
         * module.
         *
         * @type {Map | null | undefined}
         */
        this.map;
        /* eslint-enable no-unused-expressions */

        // Set path related properties in the correct order.
        let index = -1;

        while (++index < order.length) {
          const prop = order[index];

          // Note: we specifically use `in` instead of `hasOwnProperty` to accept
          // `vfile`s too.
          if (
            prop in options &&
            options[prop] !== undefined &&
            options[prop] !== null
          ) {
            // @ts-expect-error: TS doesnt understand basic reality.
            this[prop] = prop === 'history' ? [...options[prop]] : options[prop];
          }
        }

        /** @type {string} */
        let prop;

        // Set non-path related properties.
        for (prop in options) {
          // @ts-expect-error: fine to set other things.
          if (!order.includes(prop)) {
            // @ts-expect-error: fine to set other things.
            this[prop] = options[prop];
          }
        }
      }

      /**
       * Get the full path (example: `'~/index.min.js'`).
       *
       * @returns {string}
       */
      get path() {
        return this.history[this.history.length - 1]
      }

      /**
       * Set the full path (example: `'~/index.min.js'`).
       *
       * Cannot be nullified.
       * You can set a file URL (a `URL` object with a `file:` protocol) which will
       * be turned into a path with `url.fileURLToPath`.
       *
       * @param {string | URL} path
       */
      set path(path) {
        if (isUrl(path)) {
          path = urlFileURLToPath(path);
        }

        assertNonEmpty(path, 'path');

        if (this.path !== path) {
          this.history.push(path);
        }
      }

      /**
       * Get the parent path (example: `'~'`).
       */
      get dirname() {
        return typeof this.path === 'string' ? path$1.dirname(this.path) : undefined
      }

      /**
       * Set the parent path (example: `'~'`).
       *
       * Cannot be set if theres no `path` yet.
       */
      set dirname(dirname) {
        assertPath(this.basename, 'dirname');
        this.path = path$1.join(dirname || '', this.basename);
      }

      /**
       * Get the basename (including extname) (example: `'index.min.js'`).
       */
      get basename() {
        return typeof this.path === 'string' ? path$1.basename(this.path) : undefined
      }

      /**
       * Set basename (including extname) (`'index.min.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       */
      set basename(basename) {
        assertNonEmpty(basename, 'basename');
        assertPart(basename, 'basename');
        this.path = path$1.join(this.dirname || '', basename);
      }

      /**
       * Get the extname (including dot) (example: `'.js'`).
       */
      get extname() {
        return typeof this.path === 'string' ? path$1.extname(this.path) : undefined
      }

      /**
       * Set the extname (including dot) (example: `'.js'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be set if theres no `path` yet.
       */
      set extname(extname) {
        assertPart(extname, 'extname');
        assertPath(this.dirname, 'extname');

        if (extname) {
          if (extname.charCodeAt(0) !== 46 /* `.` */) {
            throw new Error('`extname` must start with `.`')
          }

          if (extname.includes('.', 1)) {
            throw new Error('`extname` cannot contain multiple dots')
          }
        }

        this.path = path$1.join(this.dirname, this.stem + (extname || ''));
      }

      /**
       * Get the stem (basename w/o extname) (example: `'index.min'`).
       */
      get stem() {
        return typeof this.path === 'string'
          ? path$1.basename(this.path, this.extname)
          : undefined
      }

      /**
       * Set the stem (basename w/o extname) (example: `'index.min'`).
       *
       * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
       * on windows).
       * Cannot be nullified (use `file.path = file.dirname` instead).
       */
      set stem(stem) {
        assertNonEmpty(stem, 'stem');
        assertPart(stem, 'stem');
        this.path = path$1.join(this.dirname || '', stem + (this.extname || ''));
      }

      /**
       * Serialize the file.
       *
       * @param {BufferEncoding | null | undefined} [encoding='utf8']
       *   Character encoding to understand `value` as when its a `Buffer`
       *   (default: `'utf8'`).
       * @returns {string}
       *   Serialized file.
       */
      toString(encoding) {
        return (this.value || '').toString(encoding || undefined)
      }

      /**
       * Create a warning message associated with the file.
       *
       * Its `fatal` is set to `false` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      message(reason, place, origin) {
        const message = new VFileMessage(reason, place, origin);

        if (this.path) {
          message.name = this.path + ':' + message.name;
          message.file = this.path;
        }

        message.fatal = false;

        this.messages.push(message);

        return message
      }

      /**
       * Create an info message associated with the file.
       *
       * Its `fatal` is set to `null` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {VFileMessage}
       *   Message.
       */
      info(reason, place, origin) {
        const message = this.message(reason, place, origin);

        message.fatal = null;

        return message
      }

      /**
       * Create a fatal error associated with the file.
       *
       * Its `fatal` is set to `true` and `file` is set to the current file path.
       * Its added to `file.messages`.
       *
       * >  **Note**: a fatal error means that a file is no longer processable.
       *
       * @param {string | Error | VFileMessage} reason
       *   Reason for message, uses the stack and message of the error if given.
       * @param {Node | NodeLike | Position | Point | null | undefined} [place]
       *   Place in file where the message occurred.
       * @param {string | null | undefined} [origin]
       *   Place in code where the message originates (example:
       *   `'my-package:my-rule'` or `'my-rule'`).
       * @returns {never}
       *   Message.
       * @throws {VFileMessage}
       *   Message.
       */
      fail(reason, place, origin) {
        const message = this.message(reason, place, origin);

        message.fatal = true;

        throw message
      }
    }

    /**
     * Assert that `part` is not a path (as in, does not contain `path.sep`).
     *
     * @param {string | null | undefined} part
     *   File path part.
     * @param {string} name
     *   Part name.
     * @returns {void}
     *   Nothing.
     */
    function assertPart(part, name) {
      if (part && part.includes(path$1.sep)) {
        throw new Error(
          '`' + name + '` cannot be a path: did not expect `' + path$1.sep + '`'
        )
      }
    }

    /**
     * Assert that `part` is not empty.
     *
     * @param {string | undefined} part
     *   Thing.
     * @param {string} name
     *   Part name.
     * @returns {asserts part is string}
     *   Nothing.
     */
    function assertNonEmpty(part, name) {
      if (!part) {
        throw new Error('`' + name + '` cannot be empty')
      }
    }

    /**
     * Assert `path` exists.
     *
     * @param {string | undefined} path
     *   Path.
     * @param {string} name
     *   Dependency name.
     * @returns {asserts path is string}
     *   Nothing.
     */
    function assertPath(path, name) {
      if (!path) {
        throw new Error('Setting `' + name + '` requires `path` to be set too')
      }
    }

    /**
     * Assert `value` is a buffer.
     *
     * @param {unknown} value
     *   thing.
     * @returns {value is Buffer}
     *   Whether `value` is a Node.js buffer.
     */
    function buffer(value) {
      return isBuffer(value)
    }

    /**
     * Throw a given error.
     *
     * @param {Error|null|undefined} [error]
     *   Maybe error.
     * @returns {asserts error is null|undefined}
     */
    function bail(error) {
      if (error) {
        throw error
      }
    }

    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;

    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}

    	return toStr.call(arr) === '[object Array]';
    };

    var isPlainObject$1 = function isPlainObject(obj) {
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}

    	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    		return false;
    	}

    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) { /**/ }

    	return typeof key === 'undefined' || hasOwn.call(obj, key);
    };

    // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
    var setProperty = function setProperty(target, options) {
    	if (defineProperty && options.name === '__proto__') {
    		defineProperty(target, options.name, {
    			enumerable: true,
    			configurable: true,
    			value: options.newValue,
    			writable: true
    		});
    	} else {
    		target[options.name] = options.newValue;
    	}
    };

    // Return undefined instead of __proto__ if '__proto__' is not an own property
    var getProperty = function getProperty(obj, name) {
    	if (name === '__proto__') {
    		if (!hasOwn.call(obj, name)) {
    			return void 0;
    		} else if (gOPD) {
    			// In early versions of node, obj['__proto__'] is buggy when obj has
    			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
    			return gOPD(obj, name).value;
    		}
    	}

    	return obj[name];
    };

    var extend = function extend() {
    	var options, name, src, copy, copyIsArray, clone;
    	var target = arguments[0];
    	var i = 1;
    	var length = arguments.length;
    	var deep = false;

    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	}
    	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
    		target = {};
    	}

    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = getProperty(target, name);
    				copy = getProperty(options, name);

    				// Prevent never-ending loop
    				if (target !== copy) {
    					// Recurse if we're merging plain objects or arrays
    					if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
    						if (copyIsArray) {
    							copyIsArray = false;
    							clone = src && isArray(src) ? src : [];
    						} else {
    							clone = src && isPlainObject$1(src) ? src : {};
    						}

    						// Never move original objects, clone them
    						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

    					// Don't bring in undefined values
    					} else if (typeof copy !== 'undefined') {
    						setProperty(target, { name: name, newValue: copy });
    					}
    				}
    			}
    		}
    	}

    	// Return the modified object
    	return target;
    };

    function isPlainObject(value) {
    	if (typeof value !== 'object' || value === null) {
    		return false;
    	}

    	const prototype = Object.getPrototypeOf(value);
    	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }

    /**
     * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback
     * @typedef {(...input: Array<any>) => any} Middleware
     *
     * @typedef {(...input: Array<any>) => void} Run
     *   Call all middleware.
     * @typedef {(fn: Middleware) => Pipeline} Use
     *   Add `fn` (middleware) to the list.
     * @typedef {{run: Run, use: Use}} Pipeline
     *   Middleware.
     */

    /**
     * Create new middleware.
     *
     * @returns {Pipeline}
     */
    function trough() {
      /** @type {Array<Middleware>} */
      const fns = [];
      /** @type {Pipeline} */
      const pipeline = {run, use};

      return pipeline

      /** @type {Run} */
      function run(...values) {
        let middlewareIndex = -1;
        /** @type {Callback} */
        const callback = values.pop();

        if (typeof callback !== 'function') {
          throw new TypeError('Expected function as last argument, not ' + callback)
        }

        next(null, ...values);

        /**
         * Run the next `fn`, or were done.
         *
         * @param {Error|null|undefined} error
         * @param {Array<any>} output
         */
        function next(error, ...output) {
          const fn = fns[++middlewareIndex];
          let index = -1;

          if (error) {
            callback(error);
            return
          }

          // Copy non-nullish input into values.
          while (++index < values.length) {
            if (output[index] === null || output[index] === undefined) {
              output[index] = values[index];
            }
          }

          // Save the newly created `output` for the next call.
          values = output;

          // Next or done.
          if (fn) {
            wrap$1(fn, next)(...output);
          } else {
            callback(null, ...output);
          }
        }
      }

      /** @type {Use} */
      function use(middelware) {
        if (typeof middelware !== 'function') {
          throw new TypeError(
            'Expected `middelware` to be a function, not ' + middelware
          )
        }

        fns.push(middelware);
        return pipeline
      }
    }

    /**
     * Wrap `middleware`.
     * Can be sync or async; return a promise, receive a callback, or return new
     * values and errors.
     *
     * @param {Middleware} middleware
     * @param {Callback} callback
     */
    function wrap$1(middleware, callback) {
      /** @type {boolean} */
      let called;

      return wrapped

      /**
       * Call `middleware`.
       * @this {any}
       * @param {Array<any>} parameters
       * @returns {void}
       */
      function wrapped(...parameters) {
        const fnExpectsCallback = middleware.length > parameters.length;
        /** @type {any} */
        let result;

        if (fnExpectsCallback) {
          parameters.push(done);
        }

        try {
          result = middleware.apply(this, parameters);
        } catch (error) {
          const exception = /** @type {Error} */ (error);

          // Well, this is quite the pickle.
          // `middleware` received a callback and called it synchronously, but that
          // threw an error.
          // The only thing left to do is to throw the thing instead.
          if (fnExpectsCallback && called) {
            throw exception
          }

          return done(exception)
        }

        if (!fnExpectsCallback) {
          if (result instanceof Promise) {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }

      /**
       * Call `callback`, only once.
       * @type {Callback}
       */
      function done(error, ...output) {
        if (!called) {
          called = true;
          callback(error, ...output);
        }
      }

      /**
       * Call `done` with one value.
       *
       * @param {any} [value]
       */
      function then(value) {
        done(null, value);
      }
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('vfile').VFileCompatible} VFileCompatible
     * @typedef {import('vfile').VFileValue} VFileValue
     * @typedef {import('..').Processor} Processor
     * @typedef {import('..').Plugin} Plugin
     * @typedef {import('..').Preset} Preset
     * @typedef {import('..').Pluggable} Pluggable
     * @typedef {import('..').PluggableList} PluggableList
     * @typedef {import('..').Transformer} Transformer
     * @typedef {import('..').Parser} Parser
     * @typedef {import('..').Compiler} Compiler
     * @typedef {import('..').RunCallback} RunCallback
     * @typedef {import('..').ProcessCallback} ProcessCallback
     *
     * @typedef Context
     * @property {Node} tree
     * @property {VFile} file
     */

    // Expose a frozen processor.
    const unified = base().freeze();

    const own$8 = {}.hasOwnProperty;

    // Function to create the first processor.
    /**
     * @returns {Processor}
     */
    function base() {
      const transformers = trough();
      /** @type {Processor['attachers']} */
      const attachers = [];
      /** @type {Record<string, unknown>} */
      let namespace = {};
      /** @type {boolean|undefined} */
      let frozen;
      let freezeIndex = -1;

      // Data management.
      // @ts-expect-error: overloads are handled.
      processor.data = data;
      processor.Parser = undefined;
      processor.Compiler = undefined;

      // Lock.
      processor.freeze = freeze;

      // Plugins.
      processor.attachers = attachers;
      // @ts-expect-error: overloads are handled.
      processor.use = use;

      // API.
      processor.parse = parse;
      processor.stringify = stringify;
      // @ts-expect-error: overloads are handled.
      processor.run = run;
      processor.runSync = runSync;
      // @ts-expect-error: overloads are handled.
      processor.process = process;
      processor.processSync = processSync;

      // Expose.
      return processor

      // Create a new processor based on the processor in the current scope.
      /** @type {Processor} */
      function processor() {
        const destination = base();
        let index = -1;

        while (++index < attachers.length) {
          destination.use(...attachers[index]);
        }

        destination.data(extend(true, {}, namespace));

        return destination
      }

      /**
       * @param {string|Record<string, unknown>} [key]
       * @param {unknown} [value]
       * @returns {unknown}
       */
      function data(key, value) {
        if (typeof key === 'string') {
          // Set `key`.
          if (arguments.length === 2) {
            assertUnfrozen('data', frozen);
            namespace[key] = value;
            return processor
          }

          // Get `key`.
          return (own$8.call(namespace, key) && namespace[key]) || null
        }

        // Set space.
        if (key) {
          assertUnfrozen('data', frozen);
          namespace = key;
          return processor
        }

        // Get space.
        return namespace
      }

      /** @type {Processor['freeze']} */
      function freeze() {
        if (frozen) {
          return processor
        }

        while (++freezeIndex < attachers.length) {
          const [attacher, ...options] = attachers[freezeIndex];

          if (options[0] === false) {
            continue
          }

          if (options[0] === true) {
            options[0] = undefined;
          }

          /** @type {Transformer|void} */
          const transformer = attacher.call(processor, ...options);

          if (typeof transformer === 'function') {
            transformers.use(transformer);
          }
        }

        frozen = true;
        freezeIndex = Number.POSITIVE_INFINITY;

        return processor
      }

      /**
       * @param {Pluggable|null|undefined} [value]
       * @param {...unknown} options
       * @returns {Processor}
       */
      function use(value, ...options) {
        /** @type {Record<string, unknown>|undefined} */
        let settings;

        assertUnfrozen('use', frozen);

        if (value === null || value === undefined) ; else if (typeof value === 'function') {
          addPlugin(value, ...options);
        } else if (typeof value === 'object') {
          if (Array.isArray(value)) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new TypeError('Expected usable value, not `' + value + '`')
        }

        if (settings) {
          namespace.settings = Object.assign(namespace.settings || {}, settings);
        }

        return processor

        /**
         * @param {import('..').Pluggable<unknown[]>} value
         * @returns {void}
         */
        function add(value) {
          if (typeof value === 'function') {
            addPlugin(value);
          } else if (typeof value === 'object') {
            if (Array.isArray(value)) {
              const [plugin, ...options] = value;
              addPlugin(plugin, ...options);
            } else {
              addPreset(value);
            }
          } else {
            throw new TypeError('Expected usable value, not `' + value + '`')
          }
        }

        /**
         * @param {Preset} result
         * @returns {void}
         */
        function addPreset(result) {
          addList(result.plugins);

          if (result.settings) {
            settings = Object.assign(settings || {}, result.settings);
          }
        }

        /**
         * @param {PluggableList|null|undefined} [plugins]
         * @returns {void}
         */
        function addList(plugins) {
          let index = -1;

          if (plugins === null || plugins === undefined) ; else if (Array.isArray(plugins)) {
            while (++index < plugins.length) {
              const thing = plugins[index];
              add(thing);
            }
          } else {
            throw new TypeError('Expected a list of plugins, not `' + plugins + '`')
          }
        }

        /**
         * @param {Plugin} plugin
         * @param {...unknown} [value]
         * @returns {void}
         */
        function addPlugin(plugin, value) {
          let index = -1;
          /** @type {Processor['attachers'][number]|undefined} */
          let entry;

          while (++index < attachers.length) {
            if (attachers[index][0] === plugin) {
              entry = attachers[index];
              break
            }
          }

          if (entry) {
            if (isPlainObject(entry[1]) && isPlainObject(value)) {
              value = extend(true, entry[1], value);
            }

            entry[1] = value;
          } else {
            // @ts-expect-error: fine.
            attachers.push([...arguments]);
          }
        }
      }

      /** @type {Processor['parse']} */
      function parse(doc) {
        processor.freeze();
        const file = vfile(doc);
        const Parser = processor.Parser;
        assertParser('parse', Parser);

        if (newable(Parser, 'parse')) {
          // @ts-expect-error: `newable` checks this.
          return new Parser(String(file), file).parse()
        }

        // @ts-expect-error: `newable` checks this.
        return Parser(String(file), file) // eslint-disable-line new-cap
      }

      /** @type {Processor['stringify']} */
      function stringify(node, doc) {
        processor.freeze();
        const file = vfile(doc);
        const Compiler = processor.Compiler;
        assertCompiler('stringify', Compiler);
        assertNode(node);

        if (newable(Compiler, 'compile')) {
          // @ts-expect-error: `newable` checks this.
          return new Compiler(node, file).compile()
        }

        // @ts-expect-error: `newable` checks this.
        return Compiler(node, file) // eslint-disable-line new-cap
      }

      /**
       * @param {Node} node
       * @param {VFileCompatible|RunCallback} [doc]
       * @param {RunCallback} [callback]
       * @returns {Promise<Node>|void}
       */
      function run(node, doc, callback) {
        assertNode(node);
        processor.freeze();

        if (!callback && typeof doc === 'function') {
          callback = doc;
          doc = undefined;
        }

        if (!callback) {
          return new Promise(executor)
        }

        executor(null, callback);

        /**
         * @param {null|((node: Node) => void)} resolve
         * @param {(error: Error) => void} reject
         * @returns {void}
         */
        function executor(resolve, reject) {
          // @ts-expect-error: `doc` cant be a callback anymore, we checked.
          transformers.run(node, vfile(doc), done);

          /**
           * @param {Error|null} error
           * @param {Node} tree
           * @param {VFile} file
           * @returns {void}
           */
          function done(error, tree, file) {
            tree = tree || node;
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(tree);
            } else {
              // @ts-expect-error: `callback` is defined if `resolve` is not.
              callback(null, tree, file);
            }
          }
        }
      }

      /** @type {Processor['runSync']} */
      function runSync(node, file) {
        /** @type {Node|undefined} */
        let result;
        /** @type {boolean|undefined} */
        let complete;

        processor.run(node, file, done);

        assertDone('runSync', 'run', complete);

        // @ts-expect-error: we either bailed on an error or have a tree.
        return result

        /**
         * @param {Error|null} [error]
         * @param {Node} [tree]
         * @returns {void}
         */
        function done(error, tree) {
          bail(error);
          result = tree;
          complete = true;
        }
      }

      /**
       * @param {VFileCompatible} doc
       * @param {ProcessCallback} [callback]
       * @returns {Promise<VFile>|undefined}
       */
      function process(doc, callback) {
        processor.freeze();
        assertParser('process', processor.Parser);
        assertCompiler('process', processor.Compiler);

        if (!callback) {
          return new Promise(executor)
        }

        executor(null, callback);

        /**
         * @param {null|((file: VFile) => void)} resolve
         * @param {(error?: Error|null|undefined) => void} reject
         * @returns {void}
         */
        function executor(resolve, reject) {
          const file = vfile(doc);

          processor.run(processor.parse(file), file, (error, tree, file) => {
            if (error || !tree || !file) {
              done(error);
            } else {
              /** @type {unknown} */
              const result = processor.stringify(tree, file);

              if (result === undefined || result === null) ; else if (looksLikeAVFileValue(result)) {
                file.value = result;
              } else {
                file.result = result;
              }

              done(error, file);
            }
          });

          /**
           * @param {Error|null|undefined} [error]
           * @param {VFile|undefined} [file]
           * @returns {void}
           */
          function done(error, file) {
            if (error || !file) {
              reject(error);
            } else if (resolve) {
              resolve(file);
            } else {
              // @ts-expect-error: `callback` is defined if `resolve` is not.
              callback(null, file);
            }
          }
        }
      }

      /** @type {Processor['processSync']} */
      function processSync(doc) {
        /** @type {boolean|undefined} */
        let complete;

        processor.freeze();
        assertParser('processSync', processor.Parser);
        assertCompiler('processSync', processor.Compiler);

        const file = vfile(doc);

        processor.process(file, done);

        assertDone('processSync', 'process', complete);

        return file

        /**
         * @param {Error|null|undefined} [error]
         * @returns {void}
         */
        function done(error) {
          complete = true;
          bail(error);
        }
      }
    }

    /**
     * Check if `value` is a constructor.
     *
     * @param {unknown} value
     * @param {string} name
     * @returns {boolean}
     */
    function newable(value, name) {
      return (
        typeof value === 'function' &&
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        value.prototype &&
        // A function with keys in its prototype is probably a constructor.
        // Classes prototype methods are not enumerable, so we check if some value
        // exists in the prototype.
        // type-coverage:ignore-next-line
        (keys(value.prototype) || name in value.prototype)
      )
    }

    /**
     * Check if `value` is an object with keys.
     *
     * @param {Record<string, unknown>} value
     * @returns {boolean}
     */
    function keys(value) {
      /** @type {string} */
      let key;

      for (key in value) {
        if (own$8.call(value, key)) {
          return true
        }
      }

      return false
    }

    /**
     * Assert a parser is available.
     *
     * @param {string} name
     * @param {unknown} value
     * @returns {asserts value is Parser}
     */
    function assertParser(name, value) {
      if (typeof value !== 'function') {
        throw new TypeError('Cannot `' + name + '` without `Parser`')
      }
    }

    /**
     * Assert a compiler is available.
     *
     * @param {string} name
     * @param {unknown} value
     * @returns {asserts value is Compiler}
     */
    function assertCompiler(name, value) {
      if (typeof value !== 'function') {
        throw new TypeError('Cannot `' + name + '` without `Compiler`')
      }
    }

    /**
     * Assert the processor is not frozen.
     *
     * @param {string} name
     * @param {unknown} frozen
     * @returns {asserts frozen is false}
     */
    function assertUnfrozen(name, frozen) {
      if (frozen) {
        throw new Error(
          'Cannot call `' +
            name +
            '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
        )
      }
    }

    /**
     * Assert `node` is a unist node.
     *
     * @param {unknown} node
     * @returns {asserts node is Node}
     */
    function assertNode(node) {
      // `isPlainObj` unfortunately uses `any` instead of `unknown`.
      // type-coverage:ignore-next-line
      if (!isPlainObject(node) || typeof node.type !== 'string') {
        throw new TypeError('Expected node, got `' + node + '`')
        // Fine.
      }
    }

    /**
     * Assert that `complete` is `true`.
     *
     * @param {string} name
     * @param {string} asyncName
     * @param {unknown} complete
     * @returns {asserts complete is true}
     */
    function assertDone(name, asyncName, complete) {
      if (!complete) {
        throw new Error(
          '`' + name + '` finished async. Use `' + asyncName + '` instead'
        )
      }
    }

    /**
     * @param {VFileCompatible} [value]
     * @returns {VFile}
     */
    function vfile(value) {
      return looksLikeAVFile(value) ? value : new VFile(value)
    }

    /**
     * @param {VFileCompatible} [value]
     * @returns {value is VFile}
     */
    function looksLikeAVFile(value) {
      return Boolean(
        value &&
          typeof value === 'object' &&
          'message' in value &&
          'messages' in value
      )
    }

    /**
     * @param {unknown} [value]
     * @returns {value is VFileValue}
     */
    function looksLikeAVFileValue(value) {
      return typeof value === 'string' || isBuffer(value)
    }

    /**
     * @typedef {import('mdast').Root|import('mdast').Content} Node
     *
     * @typedef Options
     *   Configuration (optional).
     * @property {boolean | null | undefined} [includeImageAlt=true]
     *   Whether to use `alt` for `image`s.
     */

    /**
     * Get the text content of a node or list of nodes.
     *
     * Prefers the nodes plain-text fields, otherwise serializes its children,
     * and if the given value is an array, serialize the nodes in it.
     *
     * @param {unknown} value
     *   Thing to serialize, typically `Node`.
     * @param {Options | null | undefined} [options]
     *   Configuration (optional).
     * @returns {string}
     *   Serialized `value`.
     */
    function toString(value, options) {
      const includeImageAlt = (options || {}).includeImageAlt;
      return one$1(
        value,
        typeof includeImageAlt === 'boolean' ? includeImageAlt : true
      )
    }

    /**
     * One node or several nodes.
     *
     * @param {unknown} value
     *   Thing to serialize.
     * @param {boolean} includeImageAlt
     *   Include image `alt`s.
     * @returns {string}
     *   Serialized node.
     */
    function one$1(value, includeImageAlt) {
      return (
        (node(value) &&
          (('value' in value && value.value) ||
            (includeImageAlt && 'alt' in value && value.alt) ||
            ('children' in value && all$1(value.children, includeImageAlt)))) ||
        (Array.isArray(value) && all$1(value, includeImageAlt)) ||
        ''
      )
    }

    /**
     * Serialize a list of nodes.
     *
     * @param {Array<unknown>} values
     *   Thing to serialize.
     * @param {boolean} includeImageAlt
     *   Include image `alt`s.
     * @returns {string}
     *   Serialized nodes.
     */
    function all$1(values, includeImageAlt) {
      /** @type {Array<string>} */
      const result = [];
      let index = -1;

      while (++index < values.length) {
        result[index] = one$1(values[index], includeImageAlt);
      }

      return result.join('')
    }

    /**
     * Check if `value` looks like a node.
     *
     * @param {unknown} value
     *   Thing.
     * @returns {value is Node}
     *   Whether `value` is a node.
     */
    function node(value) {
      return Boolean(value && typeof value === 'object')
    }

    /**
     * Like `Array#splice`, but smarter for giant arrays.
     *
     * `Array#splice` takes all items to be inserted as individual argument which
     * causes a stack overflow in V8 when trying to insert 100k items for instance.
     *
     * Otherwise, this does not return the removed items, and takes `items` as an
     * array instead of rest parameters.
     *
     * @template {unknown} T
     * @param {T[]} list
     * @param {number} start
     * @param {number} remove
     * @param {T[]} items
     * @returns {void}
     */
    function splice(list, start, remove, items) {
      const end = list.length;
      let chunkStart = 0;
      /** @type {unknown[]} */

      let parameters; // Make start between zero and `end` (included).

      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }

      remove = remove > 0 ? remove : 0; // No need to chunk the items if theres only a couple (10k) items.

      if (items.length < 10000) {
        parameters = Array.from(items);
        parameters.unshift(start, remove) // @ts-expect-error Hush, its fine.
        ;[].splice.apply(list, parameters);
      } else {
        // Delete `remove` items starting from `start`
        if (remove) [].splice.apply(list, [start, remove]); // Insert the items in chunks to not cause stack overflows.

        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 10000);
          parameters.unshift(start, 0) // @ts-expect-error Hush, its fine.
          ;[].splice.apply(list, parameters);
          chunkStart += 10000;
          start += 10000;
        }
      }
    }
    /**
     * Append `items` (an array) at the end of `list` (another array).
     * When `list` was empty, returns `items` instead.
     *
     * This prevents a potentially expensive operation when `list` is empty,
     * and adds items in batches to prevent V8 from hanging.
     *
     * @template {unknown} T
     * @param {T[]} list
     * @param {T[]} items
     * @returns {T[]}
     */

    function push(list, items) {
      if (list.length > 0) {
        splice(list, list.length, 0, items);
        return list
      }

      return items
    }

    /**
     * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
     */

    const hasOwnProperty = {}.hasOwnProperty;

    /**
     * Combine several syntax extensions into one.
     *
     * @param {Extension[]} extensions List of syntax extensions.
     * @returns {NormalizedExtension} A single combined extension.
     */
    function combineExtensions(extensions) {
      /** @type {NormalizedExtension} */
      const all = {};
      let index = -1;

      while (++index < extensions.length) {
        syntaxExtension(all, extensions[index]);
      }

      return all
    }

    /**
     * Merge `extension` into `all`.
     *
     * @param {NormalizedExtension} all Extension to merge into.
     * @param {Extension} extension Extension to merge.
     * @returns {void}
     */
    function syntaxExtension(all, extension) {
      /** @type {string} */
      let hook;

      for (hook in extension) {
        const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;
        const left = maybe || (all[hook] = {});
        const right = extension[hook];
        /** @type {string} */
        let code;

        for (code in right) {
          if (!hasOwnProperty.call(left, code)) left[code] = [];
          const value = right[code];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }

    /**
     * Merge `list` into `existing` (both lists of constructs).
     * Mutates `existing`.
     *
     * @param {unknown[]} existing
     * @param {unknown[]} list
     * @returns {void}
     */
    function constructs(existing, list) {
      let index = -1;
      /** @type {unknown[]} */
      const before = [];

      while (++index < list.length) {
    (list[index].add === 'after' ? existing : before).push(list[index]);
      }

      splice(existing, 0, 0, before);
    }

    // This module is generated by `script/`.
    //
    // CommonMark handles attention (emphasis, strong) markers based on what comes
    // before or after them.
    // One such difference is if those characters are Unicode punctuation.
    // This script is generated from the Unicode data.
    const unicodePunctuationRegex =
      /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

    /**
     * @typedef {import('micromark-util-types').Code} Code
     */
    /**
     * Check whether the character code represents an ASCII alpha (`a` through `z`,
     * case insensitive).
     *
     * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
     *
     * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
     * to U+005A (`Z`).
     *
     * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
     * to U+007A (`z`).
     */

    const asciiAlpha = regexCheck(/[A-Za-z]/);
    /**
     * Check whether the character code represents an ASCII digit (`0` through `9`).
     *
     * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
     * U+0039 (`9`).
     */

    const asciiDigit = regexCheck(/\d/);
    /**
     * Check whether the character code represents an ASCII hex digit (`a` through
     * `f`, case insensitive, or `0` through `9`).
     *
     * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
     * digit, or an ASCII lower hex digit.
     *
     * An **ASCII upper hex digit** is a character in the inclusive range U+0041
     * (`A`) to U+0046 (`F`).
     *
     * An **ASCII lower hex digit** is a character in the inclusive range U+0061
     * (`a`) to U+0066 (`f`).
     */

    const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    /**
     * Check whether the character code represents an ASCII alphanumeric (`a`
     * through `z`, case insensitive, or `0` through `9`).
     *
     * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
     * (see `asciiAlpha`).
     */

    const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    /**
     * Check whether the character code represents ASCII punctuation.
     *
     * An **ASCII punctuation** is a character in the inclusive ranges U+0021
     * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
     * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
     * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
     */

    const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    /**
     * Check whether the character code represents an ASCII atext.
     *
     * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
     * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
     * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
     * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
     * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
     * (`{`) to U+007E TILDE (`~`).
     *
     * See:
     * **\[RFC5322]**:
     * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
     * P. Resnick.
     * IETF.
     */

    const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    /**
     * Check whether a character code is an ASCII control character.
     *
     * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
     * to U+001F (US), or U+007F (DEL).
     *
     * @param {Code} code
     * @returns {code is number}
     */

    function asciiControl(code) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code !== null && (code < 32 || code === 127)
      )
    }
    /**
     * Check whether a character code is a markdown line ending (see
     * `markdownLineEnding`) or markdown space (see `markdownSpace`).
     *
     * @param {Code} code
     * @returns {code is number}
     */

    function markdownLineEndingOrSpace(code) {
      return code !== null && (code < 0 || code === 32)
    }
    /**
     * Check whether a character code is a markdown line ending.
     *
     * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
     * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
     *
     * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
     * RETURN (CR) are replaced by these virtual characters depending on whether
     * they occurred together.
     *
     * @param {Code} code
     * @returns {code is number}
     */

    function markdownLineEnding(code) {
      return code !== null && code < -2
    }
    /**
     * Check whether a character code is a markdown space.
     *
     * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
     * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
     *
     * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
     * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
     * SPACE (VS) characters, depending on the column at which the tab occurred.
     *
     * @param {Code} code
     * @returns {code is number}
     */

    function markdownSpace(code) {
      return code === -2 || code === -1 || code === 32
    }
    /**
     * Check whether the character code represents Unicode whitespace.
     *
     * Note that this does handle micromark specific markdown whitespace characters.
     * See `markdownLineEndingOrSpace` to check that.
     *
     * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
     * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
     * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
     *
     * See:
     * **\[UNICODE]**:
     * [The Unicode Standard](https://www.unicode.org/versions/).
     * Unicode Consortium.
     */

    const unicodeWhitespace = regexCheck(/\s/);
    /**
     * Check whether the character code represents Unicode punctuation.
     *
     * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
     * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
     * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
     * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
     * punctuation (see `asciiPunctuation`).
     *
     * See:
     * **\[UNICODE]**:
     * [The Unicode Standard](https://www.unicode.org/versions/).
     * Unicode Consortium.
     */
    // Size note: removing ASCII from the regex and using `asciiPunctuation` here
    // In fact adds to the bundle size.

    const unicodePunctuation = regexCheck(unicodePunctuationRegex);
    /**
     * Create a code check from a regex.
     *
     * @param {RegExp} regex
     * @returns {(code: Code) => code is number}
     */

    function regexCheck(regex) {
      return check
      /**
       * Check whether a code matches the bound regex.
       *
       * @param {Code} code Character code
       * @returns {code is number} Whether the character code matches the bound regex
       */

      function check(code) {
        return code !== null && regex.test(String.fromCharCode(code))
      }
    }

    /**
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').State} State
     */
    /**
     * @param {Effects} effects
     * @param {State} ok
     * @param {string} type
     * @param {number} [max=Infinity]
     * @returns {State}
     */

    function factorySpace(effects, ok, type, max) {
      const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
      let size = 0;
      return start
      /** @type {State} */

      function start(code) {
        if (markdownSpace(code)) {
          effects.enter(type);
          return prefix(code)
        }

        return ok(code)
      }
      /** @type {State} */

      function prefix(code) {
        if (markdownSpace(code) && size++ < limit) {
          effects.consume(code);
          return prefix
        }

        effects.exit(type);
        return ok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').Initializer} Initializer
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {InitialConstruct} */
    const content$1 = {
      tokenize: initializeContent
    };
    /** @type {Initializer} */

    function initializeContent(effects) {
      const contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      /** @type {Token} */

      let previous;
      return contentStart
      /** @type {State} */

      function afterContentStartConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return
        }

        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        return factorySpace(effects, contentStart, 'linePrefix')
      }
      /** @type {State} */

      function paragraphInitial(code) {
        effects.enter('paragraph');
        return lineStart(code)
      }
      /** @type {State} */

      function lineStart(code) {
        const token = effects.enter('chunkText', {
          contentType: 'text',
          previous
        });

        if (previous) {
          previous.next = token;
        }

        previous = token;
        return data(code)
      }
      /** @type {State} */

      function data(code) {
        if (code === null) {
          effects.exit('chunkText');
          effects.exit('paragraph');
          effects.consume(code);
          return
        }

        if (markdownLineEnding(code)) {
          effects.consume(code);
          effects.exit('chunkText');
          return lineStart
        } // Data.

        effects.consume(code);
        return data
      }
    }

    /**
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').Initializer} Initializer
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Point} Point
     */
    /** @type {InitialConstruct} */

    const document$2 = {
      tokenize: initializeDocument
    };
    /** @type {Construct} */

    const containerConstruct = {
      tokenize: tokenizeContainer
    };
    /** @type {Initializer} */

    function initializeDocument(effects) {
      const self = this;
      /** @type {Array<StackItem>} */

      const stack = [];
      let continued = 0;
      /** @type {TokenizeContext|undefined} */

      let childFlow;
      /** @type {Token|undefined} */

      let childToken;
      /** @type {number} */

      let lineStartOffset;
      return start
      /** @type {State} */

      function start(code) {
        // First we iterate through the open blocks, starting with the root
        // document, and descending through last children down to the last open
        // block.
        // Each block imposes a condition that the line must satisfy if the block is
        // to remain open.
        // For example, a block quote requires a `>` character.
        // A paragraph requires a non-blank line.
        // In this phase we may match all or just some of the open blocks.
        // But we cannot close unmatched blocks yet, because we may have a lazy
        // continuation line.
        if (continued < stack.length) {
          const item = stack[continued];
          self.containerState = item[1];
          return effects.attempt(
            item[0].continuation,
            documentContinue,
            checkNewContainers
          )(code)
        } // Done.

        return checkNewContainers(code)
      }
      /** @type {State} */

      function documentContinue(code) {
        continued++; // Note: this field is called `_closeFlow` but it also closes containers.
        // Perhaps a good idea to rename it but its already used in the wild by
        // extensions.

        if (self.containerState._closeFlow) {
          self.containerState._closeFlow = undefined;

          if (childFlow) {
            closeFlow();
          } // Note: this algorithm for moving events around is similar to the
          // algorithm when dealing with lazy lines in `writeToChild`.

          const indexBeforeExits = self.events.length;
          let indexBeforeFlow = indexBeforeExits;
          /** @type {Point|undefined} */

          let point; // Find the flow chunk.

          while (indexBeforeFlow--) {
            if (
              self.events[indexBeforeFlow][0] === 'exit' &&
              self.events[indexBeforeFlow][1].type === 'chunkFlow'
            ) {
              point = self.events[indexBeforeFlow][1].end;
              break
            }
          }

          exitContainers(continued); // Fix positions.

          let index = indexBeforeExits;

          while (index < self.events.length) {
            self.events[index][1].end = Object.assign({}, point);
            index++;
          } // Inject the exits earlier (theyre still also at the end).

          splice(
            self.events,
            indexBeforeFlow + 1,
            0,
            self.events.slice(indexBeforeExits)
          ); // Discard the duplicate exits.

          self.events.length = index;
          return checkNewContainers(code)
        }

        return start(code)
      }
      /** @type {State} */

      function checkNewContainers(code) {
        // Next, after consuming the continuation markers for existing blocks, we
        // look for new block starts (e.g. `>` for a block quote).
        // If we encounter a new block start, we close any blocks unmatched in
        // step 1 before creating the new block as a child of the last matched
        // block.
        if (continued === stack.length) {
          // No need to `check` whether theres a container, of `exitContainers`
          // would be moot.
          // We can instead immediately `attempt` to parse one.
          if (!childFlow) {
            return documentContinued(code)
          } // If we have concrete content, such as block HTML or fenced code,
          // we cant have containers pierce into them, so we can immediately
          // start.

          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            return flowStart(code)
          } // If we do have flow, it could still be a blank line,
          // but wed be interrupting it w/ a new container if theres a current
          // construct.

          self.interrupt = Boolean(
            childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
          );
        } // Check if there is a new container.

        self.containerState = {};
        return effects.check(
          containerConstruct,
          thereIsANewContainer,
          thereIsNoNewContainer
        )(code)
      }
      /** @type {State} */

      function thereIsANewContainer(code) {
        if (childFlow) closeFlow();
        exitContainers(continued);
        return documentContinued(code)
      }
      /** @type {State} */

      function thereIsNoNewContainer(code) {
        self.parser.lazy[self.now().line] = continued !== stack.length;
        lineStartOffset = self.now().offset;
        return flowStart(code)
      }
      /** @type {State} */

      function documentContinued(code) {
        // Try new containers.
        self.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code)
      }
      /** @type {State} */

      function containerContinue(code) {
        continued++;
        stack.push([self.currentConstruct, self.containerState]); // Try another.

        return documentContinued(code)
      }
      /** @type {State} */

      function flowStart(code) {
        if (code === null) {
          if (childFlow) closeFlow();
          exitContainers(0);
          effects.consume(code);
          return
        }

        childFlow = childFlow || self.parser.flow(self.now());
        effects.enter('chunkFlow', {
          contentType: 'flow',
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code)
      }
      /** @type {State} */

      function flowContinue(code) {
        if (code === null) {
          writeToChild(effects.exit('chunkFlow'), true);
          exitContainers(0);
          effects.consume(code);
          return
        }

        if (markdownLineEnding(code)) {
          effects.consume(code);
          writeToChild(effects.exit('chunkFlow')); // Get ready for the next line.

          continued = 0;
          self.interrupt = undefined;
          return start
        }

        effects.consume(code);
        return flowContinue
      }
      /**
       * @param {Token} token
       * @param {boolean} [eof]
       * @returns {void}
       */

      function writeToChild(token, eof) {
        const stream = self.sliceStream(token);
        if (eof) stream.push(null);
        token.previous = childToken;
        if (childToken) childToken.next = token;
        childToken = token;
        childFlow.defineSkip(token.start);
        childFlow.write(stream); // Alright, so we just added a lazy line:
        //
        // ```markdown
        // > a
        // b.
        //
        // Or:
        //
        // > ~~~c
        // d
        //
        // Or:
        //
        // > | e |
        // f
        // ```
        //
        // The construct in the second example (fenced code) does not accept lazy
        // lines, so it marked itself as done at the end of its first line, and
        // then the content construct parses `d`.
        // Most constructs in markdown match on the first line: if the first line
        // forms a construct, a non-lazy line cant unmake it.
        //
        // The construct in the third example is potentially a GFM table, and
        // those are *weird*.
        // It *could* be a table, from the first line, if the following line
        // matches a condition.
        // In this case, that second line is lazy, which unmakes the first line
        // and turns the whole into one content block.
        //
        // Weve now parsed the non-lazy and the lazy line, and can figure out
        // whether the lazy line started a new flow block.
        // If it did, we exit the current containers between the two flow blocks.

        if (self.parser.lazy[token.start.line]) {
          let index = childFlow.events.length;

          while (index--) {
            if (
              // The token starts before the line ending
              childFlow.events[index][1].start.offset < lineStartOffset && // and either is not ended yet
              (!childFlow.events[index][1].end || // or ends after it.
                childFlow.events[index][1].end.offset > lineStartOffset)
            ) {
              // Exit: theres still something open, which means its a lazy line
              // part of something.
              return
            }
          } // Note: this algorithm for moving events around is similar to the
          // algorithm when closing flow in `documentContinue`.

          const indexBeforeExits = self.events.length;
          let indexBeforeFlow = indexBeforeExits;
          /** @type {boolean|undefined} */

          let seen;
          /** @type {Point|undefined} */

          let point; // Find the previous chunk (the one before the lazy line).

          while (indexBeforeFlow--) {
            if (
              self.events[indexBeforeFlow][0] === 'exit' &&
              self.events[indexBeforeFlow][1].type === 'chunkFlow'
            ) {
              if (seen) {
                point = self.events[indexBeforeFlow][1].end;
                break
              }

              seen = true;
            }
          }

          exitContainers(continued); // Fix positions.

          index = indexBeforeExits;

          while (index < self.events.length) {
            self.events[index][1].end = Object.assign({}, point);
            index++;
          } // Inject the exits earlier (theyre still also at the end).

          splice(
            self.events,
            indexBeforeFlow + 1,
            0,
            self.events.slice(indexBeforeExits)
          ); // Discard the duplicate exits.

          self.events.length = index;
        }
      }
      /**
       * @param {number} size
       * @returns {void}
       */

      function exitContainers(size) {
        let index = stack.length; // Exit open containers.

        while (index-- > size) {
          const entry = stack[index];
          self.containerState = entry[1];
          entry[0].exit.call(self, effects);
        }

        stack.length = size;
      }

      function closeFlow() {
        childFlow.write([null]);
        childToken = undefined;
        childFlow = undefined;
        self.containerState._closeFlow = undefined;
      }
    }
    /** @type {Tokenizer} */

    function tokenizeContainer(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(this.parser.constructs.document, ok, nok),
        'linePrefix',
        this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4
      )
    }

    /**
     * @typedef {import('micromark-util-types').Code} Code
     */

    /**
     * Classify whether a character code represents whitespace, punctuation, or
     * something else.
     *
     * Used for attention (emphasis, strong), whose sequences can open or close
     * based on the class of surrounding characters.
     *
     * Note that eof (`null`) is seen as whitespace.
     *
     * @param {Code} code
     * @returns {number|undefined}
     */
    function classifyCharacter(code) {
      if (
        code === null ||
        markdownLineEndingOrSpace(code) ||
        unicodeWhitespace(code)
      ) {
        return 1
      }

      if (unicodePunctuation(code)) {
        return 2
      }
    }

    /**
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').Resolver} Resolver
     */

    /**
     * Call all `resolveAll`s.
     *
     * @param {{resolveAll?: Resolver}[]} constructs
     * @param {Event[]} events
     * @param {TokenizeContext} context
     * @returns {Event[]}
     */
    function resolveAll(constructs, events, context) {
      /** @type {Resolver[]} */
      const called = [];
      let index = -1;

      while (++index < constructs.length) {
        const resolve = constructs[index].resolveAll;

        if (resolve && !called.includes(resolve)) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }

      return events
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').Code} Code
     * @typedef {import('micromark-util-types').Point} Point
     */

    /** @type {Construct} */
    const attention = {
      name: 'attention',
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    /**
     * Take all events and resolve attention to emphasis or strong.
     *
     * @type {Resolver}
     */

    function resolveAllAttention(events, context) {
      let index = -1;
      /** @type {number} */

      let open;
      /** @type {Token} */

      let group;
      /** @type {Token} */

      let text;
      /** @type {Token} */

      let openingSequence;
      /** @type {Token} */

      let closingSequence;
      /** @type {number} */

      let use;
      /** @type {Event[]} */

      let nextEvents;
      /** @type {number} */

      let offset; // Walk through all events.
      //
      // Note: performance of this is fine on an mb of normal markdown, but its
      // a bottleneck for malicious stuff.

      while (++index < events.length) {
        // Find a token that can close.
        if (
          events[index][0] === 'enter' &&
          events[index][1].type === 'attentionSequence' &&
          events[index][1]._close
        ) {
          open = index; // Now walk back to find an opener.

          while (open--) {
            // Find a token that can open the closer.
            if (
              events[open][0] === 'exit' &&
              events[open][1].type === 'attentionSequence' &&
              events[open][1]._open && // If the markers are the same:
              context.sliceSerialize(events[open][1]).charCodeAt(0) ===
                context.sliceSerialize(events[index][1]).charCodeAt(0)
            ) {
              // If the opening can close or the closing can open,
              // and the close size *is not* a multiple of three,
              // but the sum of the opening and closing size *is* multiple of three,
              // then dont match.
              if (
                (events[open][1]._close || events[index][1]._open) &&
                (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
                !(
                  (events[open][1].end.offset -
                    events[open][1].start.offset +
                    events[index][1].end.offset -
                    events[index][1].start.offset) %
                  3
                )
              ) {
                continue
              } // Number of markers to use from the sequence.

              use =
                events[open][1].end.offset - events[open][1].start.offset > 1 &&
                events[index][1].end.offset - events[index][1].start.offset > 1
                  ? 2
                  : 1;
              const start = Object.assign({}, events[open][1].end);
              const end = Object.assign({}, events[index][1].start);
              movePoint(start, -use);
              movePoint(end, use);
              openingSequence = {
                type: use > 1 ? 'strongSequence' : 'emphasisSequence',
                start,
                end: Object.assign({}, events[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? 'strongSequence' : 'emphasisSequence',
                start: Object.assign({}, events[index][1].start),
                end
              };
              text = {
                type: use > 1 ? 'strongText' : 'emphasisText',
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index][1].start)
              };
              group = {
                type: use > 1 ? 'strong' : 'emphasis',
                start: Object.assign({}, openingSequence.start),
                end: Object.assign({}, closingSequence.end)
              };
              events[open][1].end = Object.assign({}, openingSequence.start);
              events[index][1].start = Object.assign({}, closingSequence.end);
              nextEvents = []; // If there are more markers in the opening, add them before.

              if (events[open][1].end.offset - events[open][1].start.offset) {
                nextEvents = push(nextEvents, [
                  ['enter', events[open][1], context],
                  ['exit', events[open][1], context]
                ]);
              } // Opening.

              nextEvents = push(nextEvents, [
                ['enter', group, context],
                ['enter', openingSequence, context],
                ['exit', openingSequence, context],
                ['enter', text, context]
              ]); // Between.

              nextEvents = push(
                nextEvents,
                resolveAll(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open + 1, index),
                  context
                )
              ); // Closing.

              nextEvents = push(nextEvents, [
                ['exit', text, context],
                ['enter', closingSequence, context],
                ['exit', closingSequence, context],
                ['exit', group, context]
              ]); // If there are more markers in the closing, add them after.

              if (events[index][1].end.offset - events[index][1].start.offset) {
                offset = 2;
                nextEvents = push(nextEvents, [
                  ['enter', events[index][1], context],
                  ['exit', events[index][1], context]
                ]);
              } else {
                offset = 0;
              }

              splice(events, open - 1, index - open + 3, nextEvents);
              index = open + nextEvents.length - offset - 2;
              break
            }
          }
        }
      } // Remove remaining sequences.

      index = -1;

      while (++index < events.length) {
        if (events[index][1].type === 'attentionSequence') {
          events[index][1].type = 'data';
        }
      }

      return events
    }
    /** @type {Tokenizer} */

    function tokenizeAttention(effects, ok) {
      const attentionMarkers = this.parser.constructs.attentionMarkers.null;
      const previous = this.previous;
      const before = classifyCharacter(previous);
      /** @type {NonNullable<Code>} */

      let marker;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('attentionSequence');
        marker = code;
        return sequence(code)
      }
      /** @type {State} */

      function sequence(code) {
        if (code === marker) {
          effects.consume(code);
          return sequence
        }

        const token = effects.exit('attentionSequence');
        const after = classifyCharacter(code);
        const open =
          !after || (after === 2 && before) || attentionMarkers.includes(code);
        const close =
          !before || (before === 2 && after) || attentionMarkers.includes(previous);
        token._open = Boolean(marker === 42 ? open : open && (before || !close));
        token._close = Boolean(marker === 42 ? close : close && (after || !open));
        return ok(code)
      }
    }
    /**
     * Move a point a bit.
     *
     * Note: `move` only works inside lines! Its not possible to move past other
     * chunks (replacement characters, tabs, or line endings).
     *
     * @param {Point} point
     * @param {number} offset
     * @returns {void}
     */

    function movePoint(point, offset) {
      point.column += offset;
      point.offset += offset;
      point._bufferIndex += offset;
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const autolink = {
      name: 'autolink',
      tokenize: tokenizeAutolink
    };
    /** @type {Tokenizer} */

    function tokenizeAutolink(effects, ok, nok) {
      let size = 1;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('autolink');
        effects.enter('autolinkMarker');
        effects.consume(code);
        effects.exit('autolinkMarker');
        effects.enter('autolinkProtocol');
        return open
      }
      /** @type {State} */

      function open(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return schemeOrEmailAtext
        }

        return asciiAtext(code) ? emailAtext(code) : nok(code)
      }
      /** @type {State} */

      function schemeOrEmailAtext(code) {
        return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)
          ? schemeInsideOrEmailAtext(code)
          : emailAtext(code)
      }
      /** @type {State} */

      function schemeInsideOrEmailAtext(code) {
        if (code === 58) {
          effects.consume(code);
          return urlInside
        }

        if (
          (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
          size++ < 32
        ) {
          effects.consume(code);
          return schemeInsideOrEmailAtext
        }

        return emailAtext(code)
      }
      /** @type {State} */

      function urlInside(code) {
        if (code === 62) {
          effects.exit('autolinkProtocol');
          return end(code)
        }

        if (code === null || code === 32 || code === 60 || asciiControl(code)) {
          return nok(code)
        }

        effects.consume(code);
        return urlInside
      }
      /** @type {State} */

      function emailAtext(code) {
        if (code === 64) {
          effects.consume(code);
          size = 0;
          return emailAtSignOrDot
        }

        if (asciiAtext(code)) {
          effects.consume(code);
          return emailAtext
        }

        return nok(code)
      }
      /** @type {State} */

      function emailAtSignOrDot(code) {
        return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
      }
      /** @type {State} */

      function emailLabel(code) {
        if (code === 46) {
          effects.consume(code);
          size = 0;
          return emailAtSignOrDot
        }

        if (code === 62) {
          // Exit, then change the type.
          effects.exit('autolinkProtocol').type = 'autolinkEmail';
          return end(code)
        }

        return emailValue(code)
      }
      /** @type {State} */

      function emailValue(code) {
        if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
          effects.consume(code);
          return code === 45 ? emailValue : emailLabel
        }

        return nok(code)
      }
      /** @type {State} */

      function end(code) {
        effects.enter('autolinkMarker');
        effects.consume(code);
        effects.exit('autolinkMarker');
        effects.exit('autolink');
        return ok
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const blankLine = {
      tokenize: tokenizeBlankLine,
      partial: true
    };
    /** @type {Tokenizer} */

    function tokenizeBlankLine(effects, ok, nok) {
      return factorySpace(effects, afterWhitespace, 'linePrefix')
      /** @type {State} */

      function afterWhitespace(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Exiter} Exiter
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const blockQuote = {
      name: 'blockQuote',
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit: exit$1
    };
    /** @type {Tokenizer} */

    function tokenizeBlockQuoteStart(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        if (code === 62) {
          const state = self.containerState;

          if (!state.open) {
            effects.enter('blockQuote', {
              _container: true
            });
            state.open = true;
          }

          effects.enter('blockQuotePrefix');
          effects.enter('blockQuoteMarker');
          effects.consume(code);
          effects.exit('blockQuoteMarker');
          return after
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        if (markdownSpace(code)) {
          effects.enter('blockQuotePrefixWhitespace');
          effects.consume(code);
          effects.exit('blockQuotePrefixWhitespace');
          effects.exit('blockQuotePrefix');
          return ok
        }

        effects.exit('blockQuotePrefix');
        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeBlockQuoteContinuation(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(blockQuote, ok, nok),
        'linePrefix',
        this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4
      )
    }
    /** @type {Exiter} */

    function exit$1(effects) {
      effects.exit('blockQuote');
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const characterEscape = {
      name: 'characterEscape',
      tokenize: tokenizeCharacterEscape
    };
    /** @type {Tokenizer} */

    function tokenizeCharacterEscape(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('characterEscape');
        effects.enter('escapeMarker');
        effects.consume(code);
        effects.exit('escapeMarker');
        return open
      }
      /** @type {State} */

      function open(code) {
        if (asciiPunctuation(code)) {
          effects.enter('characterEscapeValue');
          effects.consume(code);
          effects.exit('characterEscapeValue');
          effects.exit('characterEscape');
          return ok
        }

        return nok(code)
      }
    }

    /**
     * Map of named character references.
     *
     * @type {Record<string, string>}
     */
    const characterEntities = {
      AElig: '',
      AMP: '&',
      Aacute: '',
      Abreve: '',
      Acirc: '',
      Acy: '',
      Afr: '',
      Agrave: '',
      Alpha: '',
      Amacr: '',
      And: '',
      Aogon: '',
      Aopf: '',
      ApplyFunction: '',
      Aring: '',
      Ascr: '',
      Assign: '',
      Atilde: '',
      Auml: '',
      Backslash: '',
      Barv: '',
      Barwed: '',
      Bcy: '',
      Because: '',
      Bernoullis: '',
      Beta: '',
      Bfr: '',
      Bopf: '',
      Breve: '',
      Bscr: '',
      Bumpeq: '',
      CHcy: '',
      COPY: '',
      Cacute: '',
      Cap: '',
      CapitalDifferentialD: '',
      Cayleys: '',
      Ccaron: '',
      Ccedil: '',
      Ccirc: '',
      Cconint: '',
      Cdot: '',
      Cedilla: '',
      CenterDot: '',
      Cfr: '',
      Chi: '',
      CircleDot: '',
      CircleMinus: '',
      CirclePlus: '',
      CircleTimes: '',
      ClockwiseContourIntegral: '',
      CloseCurlyDoubleQuote: '',
      CloseCurlyQuote: '',
      Colon: '',
      Colone: '',
      Congruent: '',
      Conint: '',
      ContourIntegral: '',
      Copf: '',
      Coproduct: '',
      CounterClockwiseContourIntegral: '',
      Cross: '',
      Cscr: '',
      Cup: '',
      CupCap: '',
      DD: '',
      DDotrahd: '',
      DJcy: '',
      DScy: '',
      DZcy: '',
      Dagger: '',
      Darr: '',
      Dashv: '',
      Dcaron: '',
      Dcy: '',
      Del: '',
      Delta: '',
      Dfr: '',
      DiacriticalAcute: '',
      DiacriticalDot: '',
      DiacriticalDoubleAcute: '',
      DiacriticalGrave: '`',
      DiacriticalTilde: '',
      Diamond: '',
      DifferentialD: '',
      Dopf: '',
      Dot: '',
      DotDot: '',
      DotEqual: '',
      DoubleContourIntegral: '',
      DoubleDot: '',
      DoubleDownArrow: '',
      DoubleLeftArrow: '',
      DoubleLeftRightArrow: '',
      DoubleLeftTee: '',
      DoubleLongLeftArrow: '',
      DoubleLongLeftRightArrow: '',
      DoubleLongRightArrow: '',
      DoubleRightArrow: '',
      DoubleRightTee: '',
      DoubleUpArrow: '',
      DoubleUpDownArrow: '',
      DoubleVerticalBar: '',
      DownArrow: '',
      DownArrowBar: '',
      DownArrowUpArrow: '',
      DownBreve: '',
      DownLeftRightVector: '',
      DownLeftTeeVector: '',
      DownLeftVector: '',
      DownLeftVectorBar: '',
      DownRightTeeVector: '',
      DownRightVector: '',
      DownRightVectorBar: '',
      DownTee: '',
      DownTeeArrow: '',
      Downarrow: '',
      Dscr: '',
      Dstrok: '',
      ENG: '',
      ETH: '',
      Eacute: '',
      Ecaron: '',
      Ecirc: '',
      Ecy: '',
      Edot: '',
      Efr: '',
      Egrave: '',
      Element: '',
      Emacr: '',
      EmptySmallSquare: '',
      EmptyVerySmallSquare: '',
      Eogon: '',
      Eopf: '',
      Epsilon: '',
      Equal: '',
      EqualTilde: '',
      Equilibrium: '',
      Escr: '',
      Esim: '',
      Eta: '',
      Euml: '',
      Exists: '',
      ExponentialE: '',
      Fcy: '',
      Ffr: '',
      FilledSmallSquare: '',
      FilledVerySmallSquare: '',
      Fopf: '',
      ForAll: '',
      Fouriertrf: '',
      Fscr: '',
      GJcy: '',
      GT: '>',
      Gamma: '',
      Gammad: '',
      Gbreve: '',
      Gcedil: '',
      Gcirc: '',
      Gcy: '',
      Gdot: '',
      Gfr: '',
      Gg: '',
      Gopf: '',
      GreaterEqual: '',
      GreaterEqualLess: '',
      GreaterFullEqual: '',
      GreaterGreater: '',
      GreaterLess: '',
      GreaterSlantEqual: '',
      GreaterTilde: '',
      Gscr: '',
      Gt: '',
      HARDcy: '',
      Hacek: '',
      Hat: '^',
      Hcirc: '',
      Hfr: '',
      HilbertSpace: '',
      Hopf: '',
      HorizontalLine: '',
      Hscr: '',
      Hstrok: '',
      HumpDownHump: '',
      HumpEqual: '',
      IEcy: '',
      IJlig: '',
      IOcy: '',
      Iacute: '',
      Icirc: '',
      Icy: '',
      Idot: '',
      Ifr: '',
      Igrave: '',
      Im: '',
      Imacr: '',
      ImaginaryI: '',
      Implies: '',
      Int: '',
      Integral: '',
      Intersection: '',
      InvisibleComma: '',
      InvisibleTimes: '',
      Iogon: '',
      Iopf: '',
      Iota: '',
      Iscr: '',
      Itilde: '',
      Iukcy: '',
      Iuml: '',
      Jcirc: '',
      Jcy: '',
      Jfr: '',
      Jopf: '',
      Jscr: '',
      Jsercy: '',
      Jukcy: '',
      KHcy: '',
      KJcy: '',
      Kappa: '',
      Kcedil: '',
      Kcy: '',
      Kfr: '',
      Kopf: '',
      Kscr: '',
      LJcy: '',
      LT: '<',
      Lacute: '',
      Lambda: '',
      Lang: '',
      Laplacetrf: '',
      Larr: '',
      Lcaron: '',
      Lcedil: '',
      Lcy: '',
      LeftAngleBracket: '',
      LeftArrow: '',
      LeftArrowBar: '',
      LeftArrowRightArrow: '',
      LeftCeiling: '',
      LeftDoubleBracket: '',
      LeftDownTeeVector: '',
      LeftDownVector: '',
      LeftDownVectorBar: '',
      LeftFloor: '',
      LeftRightArrow: '',
      LeftRightVector: '',
      LeftTee: '',
      LeftTeeArrow: '',
      LeftTeeVector: '',
      LeftTriangle: '',
      LeftTriangleBar: '',
      LeftTriangleEqual: '',
      LeftUpDownVector: '',
      LeftUpTeeVector: '',
      LeftUpVector: '',
      LeftUpVectorBar: '',
      LeftVector: '',
      LeftVectorBar: '',
      Leftarrow: '',
      Leftrightarrow: '',
      LessEqualGreater: '',
      LessFullEqual: '',
      LessGreater: '',
      LessLess: '',
      LessSlantEqual: '',
      LessTilde: '',
      Lfr: '',
      Ll: '',
      Lleftarrow: '',
      Lmidot: '',
      LongLeftArrow: '',
      LongLeftRightArrow: '',
      LongRightArrow: '',
      Longleftarrow: '',
      Longleftrightarrow: '',
      Longrightarrow: '',
      Lopf: '',
      LowerLeftArrow: '',
      LowerRightArrow: '',
      Lscr: '',
      Lsh: '',
      Lstrok: '',
      Lt: '',
      Map: '',
      Mcy: '',
      MediumSpace: '',
      Mellintrf: '',
      Mfr: '',
      MinusPlus: '',
      Mopf: '',
      Mscr: '',
      Mu: '',
      NJcy: '',
      Nacute: '',
      Ncaron: '',
      Ncedil: '',
      Ncy: '',
      NegativeMediumSpace: '',
      NegativeThickSpace: '',
      NegativeThinSpace: '',
      NegativeVeryThinSpace: '',
      NestedGreaterGreater: '',
      NestedLessLess: '',
      NewLine: '\n',
      Nfr: '',
      NoBreak: '',
      NonBreakingSpace: '',
      Nopf: '',
      Not: '',
      NotCongruent: '',
      NotCupCap: '',
      NotDoubleVerticalBar: '',
      NotElement: '',
      NotEqual: '',
      NotEqualTilde: '',
      NotExists: '',
      NotGreater: '',
      NotGreaterEqual: '',
      NotGreaterFullEqual: '',
      NotGreaterGreater: '',
      NotGreaterLess: '',
      NotGreaterSlantEqual: '',
      NotGreaterTilde: '',
      NotHumpDownHump: '',
      NotHumpEqual: '',
      NotLeftTriangle: '',
      NotLeftTriangleBar: '',
      NotLeftTriangleEqual: '',
      NotLess: '',
      NotLessEqual: '',
      NotLessGreater: '',
      NotLessLess: '',
      NotLessSlantEqual: '',
      NotLessTilde: '',
      NotNestedGreaterGreater: '',
      NotNestedLessLess: '',
      NotPrecedes: '',
      NotPrecedesEqual: '',
      NotPrecedesSlantEqual: '',
      NotReverseElement: '',
      NotRightTriangle: '',
      NotRightTriangleBar: '',
      NotRightTriangleEqual: '',
      NotSquareSubset: '',
      NotSquareSubsetEqual: '',
      NotSquareSuperset: '',
      NotSquareSupersetEqual: '',
      NotSubset: '',
      NotSubsetEqual: '',
      NotSucceeds: '',
      NotSucceedsEqual: '',
      NotSucceedsSlantEqual: '',
      NotSucceedsTilde: '',
      NotSuperset: '',
      NotSupersetEqual: '',
      NotTilde: '',
      NotTildeEqual: '',
      NotTildeFullEqual: '',
      NotTildeTilde: '',
      NotVerticalBar: '',
      Nscr: '',
      Ntilde: '',
      Nu: '',
      OElig: '',
      Oacute: '',
      Ocirc: '',
      Ocy: '',
      Odblac: '',
      Ofr: '',
      Ograve: '',
      Omacr: '',
      Omega: '',
      Omicron: '',
      Oopf: '',
      OpenCurlyDoubleQuote: '',
      OpenCurlyQuote: '',
      Or: '',
      Oscr: '',
      Oslash: '',
      Otilde: '',
      Otimes: '',
      Ouml: '',
      OverBar: '',
      OverBrace: '',
      OverBracket: '',
      OverParenthesis: '',
      PartialD: '',
      Pcy: '',
      Pfr: '',
      Phi: '',
      Pi: '',
      PlusMinus: '',
      Poincareplane: '',
      Popf: '',
      Pr: '',
      Precedes: '',
      PrecedesEqual: '',
      PrecedesSlantEqual: '',
      PrecedesTilde: '',
      Prime: '',
      Product: '',
      Proportion: '',
      Proportional: '',
      Pscr: '',
      Psi: '',
      QUOT: '"',
      Qfr: '',
      Qopf: '',
      Qscr: '',
      RBarr: '',
      REG: '',
      Racute: '',
      Rang: '',
      Rarr: '',
      Rarrtl: '',
      Rcaron: '',
      Rcedil: '',
      Rcy: '',
      Re: '',
      ReverseElement: '',
      ReverseEquilibrium: '',
      ReverseUpEquilibrium: '',
      Rfr: '',
      Rho: '',
      RightAngleBracket: '',
      RightArrow: '',
      RightArrowBar: '',
      RightArrowLeftArrow: '',
      RightCeiling: '',
      RightDoubleBracket: '',
      RightDownTeeVector: '',
      RightDownVector: '',
      RightDownVectorBar: '',
      RightFloor: '',
      RightTee: '',
      RightTeeArrow: '',
      RightTeeVector: '',
      RightTriangle: '',
      RightTriangleBar: '',
      RightTriangleEqual: '',
      RightUpDownVector: '',
      RightUpTeeVector: '',
      RightUpVector: '',
      RightUpVectorBar: '',
      RightVector: '',
      RightVectorBar: '',
      Rightarrow: '',
      Ropf: '',
      RoundImplies: '',
      Rrightarrow: '',
      Rscr: '',
      Rsh: '',
      RuleDelayed: '',
      SHCHcy: '',
      SHcy: '',
      SOFTcy: '',
      Sacute: '',
      Sc: '',
      Scaron: '',
      Scedil: '',
      Scirc: '',
      Scy: '',
      Sfr: '',
      ShortDownArrow: '',
      ShortLeftArrow: '',
      ShortRightArrow: '',
      ShortUpArrow: '',
      Sigma: '',
      SmallCircle: '',
      Sopf: '',
      Sqrt: '',
      Square: '',
      SquareIntersection: '',
      SquareSubset: '',
      SquareSubsetEqual: '',
      SquareSuperset: '',
      SquareSupersetEqual: '',
      SquareUnion: '',
      Sscr: '',
      Star: '',
      Sub: '',
      Subset: '',
      SubsetEqual: '',
      Succeeds: '',
      SucceedsEqual: '',
      SucceedsSlantEqual: '',
      SucceedsTilde: '',
      SuchThat: '',
      Sum: '',
      Sup: '',
      Superset: '',
      SupersetEqual: '',
      Supset: '',
      THORN: '',
      TRADE: '',
      TSHcy: '',
      TScy: '',
      Tab: '\t',
      Tau: '',
      Tcaron: '',
      Tcedil: '',
      Tcy: '',
      Tfr: '',
      Therefore: '',
      Theta: '',
      ThickSpace: '',
      ThinSpace: '',
      Tilde: '',
      TildeEqual: '',
      TildeFullEqual: '',
      TildeTilde: '',
      Topf: '',
      TripleDot: '',
      Tscr: '',
      Tstrok: '',
      Uacute: '',
      Uarr: '',
      Uarrocir: '',
      Ubrcy: '',
      Ubreve: '',
      Ucirc: '',
      Ucy: '',
      Udblac: '',
      Ufr: '',
      Ugrave: '',
      Umacr: '',
      UnderBar: '_',
      UnderBrace: '',
      UnderBracket: '',
      UnderParenthesis: '',
      Union: '',
      UnionPlus: '',
      Uogon: '',
      Uopf: '',
      UpArrow: '',
      UpArrowBar: '',
      UpArrowDownArrow: '',
      UpDownArrow: '',
      UpEquilibrium: '',
      UpTee: '',
      UpTeeArrow: '',
      Uparrow: '',
      Updownarrow: '',
      UpperLeftArrow: '',
      UpperRightArrow: '',
      Upsi: '',
      Upsilon: '',
      Uring: '',
      Uscr: '',
      Utilde: '',
      Uuml: '',
      VDash: '',
      Vbar: '',
      Vcy: '',
      Vdash: '',
      Vdashl: '',
      Vee: '',
      Verbar: '',
      Vert: '',
      VerticalBar: '',
      VerticalLine: '|',
      VerticalSeparator: '',
      VerticalTilde: '',
      VeryThinSpace: '',
      Vfr: '',
      Vopf: '',
      Vscr: '',
      Vvdash: '',
      Wcirc: '',
      Wedge: '',
      Wfr: '',
      Wopf: '',
      Wscr: '',
      Xfr: '',
      Xi: '',
      Xopf: '',
      Xscr: '',
      YAcy: '',
      YIcy: '',
      YUcy: '',
      Yacute: '',
      Ycirc: '',
      Ycy: '',
      Yfr: '',
      Yopf: '',
      Yscr: '',
      Yuml: '',
      ZHcy: '',
      Zacute: '',
      Zcaron: '',
      Zcy: '',
      Zdot: '',
      ZeroWidthSpace: '',
      Zeta: '',
      Zfr: '',
      Zopf: '',
      Zscr: '',
      aacute: '',
      abreve: '',
      ac: '',
      acE: '',
      acd: '',
      acirc: '',
      acute: '',
      acy: '',
      aelig: '',
      af: '',
      afr: '',
      agrave: '',
      alefsym: '',
      aleph: '',
      alpha: '',
      amacr: '',
      amalg: '',
      amp: '&',
      and: '',
      andand: '',
      andd: '',
      andslope: '',
      andv: '',
      ang: '',
      ange: '',
      angle: '',
      angmsd: '',
      angmsdaa: '',
      angmsdab: '',
      angmsdac: '',
      angmsdad: '',
      angmsdae: '',
      angmsdaf: '',
      angmsdag: '',
      angmsdah: '',
      angrt: '',
      angrtvb: '',
      angrtvbd: '',
      angsph: '',
      angst: '',
      angzarr: '',
      aogon: '',
      aopf: '',
      ap: '',
      apE: '',
      apacir: '',
      ape: '',
      apid: '',
      apos: "'",
      approx: '',
      approxeq: '',
      aring: '',
      ascr: '',
      ast: '*',
      asymp: '',
      asympeq: '',
      atilde: '',
      auml: '',
      awconint: '',
      awint: '',
      bNot: '',
      backcong: '',
      backepsilon: '',
      backprime: '',
      backsim: '',
      backsimeq: '',
      barvee: '',
      barwed: '',
      barwedge: '',
      bbrk: '',
      bbrktbrk: '',
      bcong: '',
      bcy: '',
      bdquo: '',
      becaus: '',
      because: '',
      bemptyv: '',
      bepsi: '',
      bernou: '',
      beta: '',
      beth: '',
      between: '',
      bfr: '',
      bigcap: '',
      bigcirc: '',
      bigcup: '',
      bigodot: '',
      bigoplus: '',
      bigotimes: '',
      bigsqcup: '',
      bigstar: '',
      bigtriangledown: '',
      bigtriangleup: '',
      biguplus: '',
      bigvee: '',
      bigwedge: '',
      bkarow: '',
      blacklozenge: '',
      blacksquare: '',
      blacktriangle: '',
      blacktriangledown: '',
      blacktriangleleft: '',
      blacktriangleright: '',
      blank: '',
      blk12: '',
      blk14: '',
      blk34: '',
      block: '',
      bne: '=',
      bnequiv: '',
      bnot: '',
      bopf: '',
      bot: '',
      bottom: '',
      bowtie: '',
      boxDL: '',
      boxDR: '',
      boxDl: '',
      boxDr: '',
      boxH: '',
      boxHD: '',
      boxHU: '',
      boxHd: '',
      boxHu: '',
      boxUL: '',
      boxUR: '',
      boxUl: '',
      boxUr: '',
      boxV: '',
      boxVH: '',
      boxVL: '',
      boxVR: '',
      boxVh: '',
      boxVl: '',
      boxVr: '',
      boxbox: '',
      boxdL: '',
      boxdR: '',
      boxdl: '',
      boxdr: '',
      boxh: '',
      boxhD: '',
      boxhU: '',
      boxhd: '',
      boxhu: '',
      boxminus: '',
      boxplus: '',
      boxtimes: '',
      boxuL: '',
      boxuR: '',
      boxul: '',
      boxur: '',
      boxv: '',
      boxvH: '',
      boxvL: '',
      boxvR: '',
      boxvh: '',
      boxvl: '',
      boxvr: '',
      bprime: '',
      breve: '',
      brvbar: '',
      bscr: '',
      bsemi: '',
      bsim: '',
      bsime: '',
      bsol: '\\',
      bsolb: '',
      bsolhsub: '',
      bull: '',
      bullet: '',
      bump: '',
      bumpE: '',
      bumpe: '',
      bumpeq: '',
      cacute: '',
      cap: '',
      capand: '',
      capbrcup: '',
      capcap: '',
      capcup: '',
      capdot: '',
      caps: '',
      caret: '',
      caron: '',
      ccaps: '',
      ccaron: '',
      ccedil: '',
      ccirc: '',
      ccups: '',
      ccupssm: '',
      cdot: '',
      cedil: '',
      cemptyv: '',
      cent: '',
      centerdot: '',
      cfr: '',
      chcy: '',
      check: '',
      checkmark: '',
      chi: '',
      cir: '',
      cirE: '',
      circ: '',
      circeq: '',
      circlearrowleft: '',
      circlearrowright: '',
      circledR: '',
      circledS: '',
      circledast: '',
      circledcirc: '',
      circleddash: '',
      cire: '',
      cirfnint: '',
      cirmid: '',
      cirscir: '',
      clubs: '',
      clubsuit: '',
      colon: ':',
      colone: '',
      coloneq: '',
      comma: ',',
      commat: '@',
      comp: '',
      compfn: '',
      complement: '',
      complexes: '',
      cong: '',
      congdot: '',
      conint: '',
      copf: '',
      coprod: '',
      copy: '',
      copysr: '',
      crarr: '',
      cross: '',
      cscr: '',
      csub: '',
      csube: '',
      csup: '',
      csupe: '',
      ctdot: '',
      cudarrl: '',
      cudarrr: '',
      cuepr: '',
      cuesc: '',
      cularr: '',
      cularrp: '',
      cup: '',
      cupbrcap: '',
      cupcap: '',
      cupcup: '',
      cupdot: '',
      cupor: '',
      cups: '',
      curarr: '',
      curarrm: '',
      curlyeqprec: '',
      curlyeqsucc: '',
      curlyvee: '',
      curlywedge: '',
      curren: '',
      curvearrowleft: '',
      curvearrowright: '',
      cuvee: '',
      cuwed: '',
      cwconint: '',
      cwint: '',
      cylcty: '',
      dArr: '',
      dHar: '',
      dagger: '',
      daleth: '',
      darr: '',
      dash: '',
      dashv: '',
      dbkarow: '',
      dblac: '',
      dcaron: '',
      dcy: '',
      dd: '',
      ddagger: '',
      ddarr: '',
      ddotseq: '',
      deg: '',
      delta: '',
      demptyv: '',
      dfisht: '',
      dfr: '',
      dharl: '',
      dharr: '',
      diam: '',
      diamond: '',
      diamondsuit: '',
      diams: '',
      die: '',
      digamma: '',
      disin: '',
      div: '',
      divide: '',
      divideontimes: '',
      divonx: '',
      djcy: '',
      dlcorn: '',
      dlcrop: '',
      dollar: '$',
      dopf: '',
      dot: '',
      doteq: '',
      doteqdot: '',
      dotminus: '',
      dotplus: '',
      dotsquare: '',
      doublebarwedge: '',
      downarrow: '',
      downdownarrows: '',
      downharpoonleft: '',
      downharpoonright: '',
      drbkarow: '',
      drcorn: '',
      drcrop: '',
      dscr: '',
      dscy: '',
      dsol: '',
      dstrok: '',
      dtdot: '',
      dtri: '',
      dtrif: '',
      duarr: '',
      duhar: '',
      dwangle: '',
      dzcy: '',
      dzigrarr: '',
      eDDot: '',
      eDot: '',
      eacute: '',
      easter: '',
      ecaron: '',
      ecir: '',
      ecirc: '',
      ecolon: '',
      ecy: '',
      edot: '',
      ee: '',
      efDot: '',
      efr: '',
      eg: '',
      egrave: '',
      egs: '',
      egsdot: '',
      el: '',
      elinters: '',
      ell: '',
      els: '',
      elsdot: '',
      emacr: '',
      empty: '',
      emptyset: '',
      emptyv: '',
      emsp13: '',
      emsp14: '',
      emsp: '',
      eng: '',
      ensp: '',
      eogon: '',
      eopf: '',
      epar: '',
      eparsl: '',
      eplus: '',
      epsi: '',
      epsilon: '',
      epsiv: '',
      eqcirc: '',
      eqcolon: '',
      eqsim: '',
      eqslantgtr: '',
      eqslantless: '',
      equals: '=',
      equest: '',
      equiv: '',
      equivDD: '',
      eqvparsl: '',
      erDot: '',
      erarr: '',
      escr: '',
      esdot: '',
      esim: '',
      eta: '',
      eth: '',
      euml: '',
      euro: '',
      excl: '!',
      exist: '',
      expectation: '',
      exponentiale: '',
      fallingdotseq: '',
      fcy: '',
      female: '',
      ffilig: '',
      fflig: '',
      ffllig: '',
      ffr: '',
      filig: '',
      fjlig: 'fj',
      flat: '',
      fllig: '',
      fltns: '',
      fnof: '',
      fopf: '',
      forall: '',
      fork: '',
      forkv: '',
      fpartint: '',
      frac12: '',
      frac13: '',
      frac14: '',
      frac15: '',
      frac16: '',
      frac18: '',
      frac23: '',
      frac25: '',
      frac34: '',
      frac35: '',
      frac38: '',
      frac45: '',
      frac56: '',
      frac58: '',
      frac78: '',
      frasl: '',
      frown: '',
      fscr: '',
      gE: '',
      gEl: '',
      gacute: '',
      gamma: '',
      gammad: '',
      gap: '',
      gbreve: '',
      gcirc: '',
      gcy: '',
      gdot: '',
      ge: '',
      gel: '',
      geq: '',
      geqq: '',
      geqslant: '',
      ges: '',
      gescc: '',
      gesdot: '',
      gesdoto: '',
      gesdotol: '',
      gesl: '',
      gesles: '',
      gfr: '',
      gg: '',
      ggg: '',
      gimel: '',
      gjcy: '',
      gl: '',
      glE: '',
      gla: '',
      glj: '',
      gnE: '',
      gnap: '',
      gnapprox: '',
      gne: '',
      gneq: '',
      gneqq: '',
      gnsim: '',
      gopf: '',
      grave: '`',
      gscr: '',
      gsim: '',
      gsime: '',
      gsiml: '',
      gt: '>',
      gtcc: '',
      gtcir: '',
      gtdot: '',
      gtlPar: '',
      gtquest: '',
      gtrapprox: '',
      gtrarr: '',
      gtrdot: '',
      gtreqless: '',
      gtreqqless: '',
      gtrless: '',
      gtrsim: '',
      gvertneqq: '',
      gvnE: '',
      hArr: '',
      hairsp: '',
      half: '',
      hamilt: '',
      hardcy: '',
      harr: '',
      harrcir: '',
      harrw: '',
      hbar: '',
      hcirc: '',
      hearts: '',
      heartsuit: '',
      hellip: '',
      hercon: '',
      hfr: '',
      hksearow: '',
      hkswarow: '',
      hoarr: '',
      homtht: '',
      hookleftarrow: '',
      hookrightarrow: '',
      hopf: '',
      horbar: '',
      hscr: '',
      hslash: '',
      hstrok: '',
      hybull: '',
      hyphen: '',
      iacute: '',
      ic: '',
      icirc: '',
      icy: '',
      iecy: '',
      iexcl: '',
      iff: '',
      ifr: '',
      igrave: '',
      ii: '',
      iiiint: '',
      iiint: '',
      iinfin: '',
      iiota: '',
      ijlig: '',
      imacr: '',
      image: '',
      imagline: '',
      imagpart: '',
      imath: '',
      imof: '',
      imped: '',
      in: '',
      incare: '',
      infin: '',
      infintie: '',
      inodot: '',
      int: '',
      intcal: '',
      integers: '',
      intercal: '',
      intlarhk: '',
      intprod: '',
      iocy: '',
      iogon: '',
      iopf: '',
      iota: '',
      iprod: '',
      iquest: '',
      iscr: '',
      isin: '',
      isinE: '',
      isindot: '',
      isins: '',
      isinsv: '',
      isinv: '',
      it: '',
      itilde: '',
      iukcy: '',
      iuml: '',
      jcirc: '',
      jcy: '',
      jfr: '',
      jmath: '',
      jopf: '',
      jscr: '',
      jsercy: '',
      jukcy: '',
      kappa: '',
      kappav: '',
      kcedil: '',
      kcy: '',
      kfr: '',
      kgreen: '',
      khcy: '',
      kjcy: '',
      kopf: '',
      kscr: '',
      lAarr: '',
      lArr: '',
      lAtail: '',
      lBarr: '',
      lE: '',
      lEg: '',
      lHar: '',
      lacute: '',
      laemptyv: '',
      lagran: '',
      lambda: '',
      lang: '',
      langd: '',
      langle: '',
      lap: '',
      laquo: '',
      larr: '',
      larrb: '',
      larrbfs: '',
      larrfs: '',
      larrhk: '',
      larrlp: '',
      larrpl: '',
      larrsim: '',
      larrtl: '',
      lat: '',
      latail: '',
      late: '',
      lates: '',
      lbarr: '',
      lbbrk: '',
      lbrace: '{',
      lbrack: '[',
      lbrke: '',
      lbrksld: '',
      lbrkslu: '',
      lcaron: '',
      lcedil: '',
      lceil: '',
      lcub: '{',
      lcy: '',
      ldca: '',
      ldquo: '',
      ldquor: '',
      ldrdhar: '',
      ldrushar: '',
      ldsh: '',
      le: '',
      leftarrow: '',
      leftarrowtail: '',
      leftharpoondown: '',
      leftharpoonup: '',
      leftleftarrows: '',
      leftrightarrow: '',
      leftrightarrows: '',
      leftrightharpoons: '',
      leftrightsquigarrow: '',
      leftthreetimes: '',
      leg: '',
      leq: '',
      leqq: '',
      leqslant: '',
      les: '',
      lescc: '',
      lesdot: '',
      lesdoto: '',
      lesdotor: '',
      lesg: '',
      lesges: '',
      lessapprox: '',
      lessdot: '',
      lesseqgtr: '',
      lesseqqgtr: '',
      lessgtr: '',
      lesssim: '',
      lfisht: '',
      lfloor: '',
      lfr: '',
      lg: '',
      lgE: '',
      lhard: '',
      lharu: '',
      lharul: '',
      lhblk: '',
      ljcy: '',
      ll: '',
      llarr: '',
      llcorner: '',
      llhard: '',
      lltri: '',
      lmidot: '',
      lmoust: '',
      lmoustache: '',
      lnE: '',
      lnap: '',
      lnapprox: '',
      lne: '',
      lneq: '',
      lneqq: '',
      lnsim: '',
      loang: '',
      loarr: '',
      lobrk: '',
      longleftarrow: '',
      longleftrightarrow: '',
      longmapsto: '',
      longrightarrow: '',
      looparrowleft: '',
      looparrowright: '',
      lopar: '',
      lopf: '',
      loplus: '',
      lotimes: '',
      lowast: '',
      lowbar: '_',
      loz: '',
      lozenge: '',
      lozf: '',
      lpar: '(',
      lparlt: '',
      lrarr: '',
      lrcorner: '',
      lrhar: '',
      lrhard: '',
      lrm: '',
      lrtri: '',
      lsaquo: '',
      lscr: '',
      lsh: '',
      lsim: '',
      lsime: '',
      lsimg: '',
      lsqb: '[',
      lsquo: '',
      lsquor: '',
      lstrok: '',
      lt: '<',
      ltcc: '',
      ltcir: '',
      ltdot: '',
      lthree: '',
      ltimes: '',
      ltlarr: '',
      ltquest: '',
      ltrPar: '',
      ltri: '',
      ltrie: '',
      ltrif: '',
      lurdshar: '',
      luruhar: '',
      lvertneqq: '',
      lvnE: '',
      mDDot: '',
      macr: '',
      male: '',
      malt: '',
      maltese: '',
      map: '',
      mapsto: '',
      mapstodown: '',
      mapstoleft: '',
      mapstoup: '',
      marker: '',
      mcomma: '',
      mcy: '',
      mdash: '',
      measuredangle: '',
      mfr: '',
      mho: '',
      micro: '',
      mid: '',
      midast: '*',
      midcir: '',
      middot: '',
      minus: '',
      minusb: '',
      minusd: '',
      minusdu: '',
      mlcp: '',
      mldr: '',
      mnplus: '',
      models: '',
      mopf: '',
      mp: '',
      mscr: '',
      mstpos: '',
      mu: '',
      multimap: '',
      mumap: '',
      nGg: '',
      nGt: '',
      nGtv: '',
      nLeftarrow: '',
      nLeftrightarrow: '',
      nLl: '',
      nLt: '',
      nLtv: '',
      nRightarrow: '',
      nVDash: '',
      nVdash: '',
      nabla: '',
      nacute: '',
      nang: '',
      nap: '',
      napE: '',
      napid: '',
      napos: '',
      napprox: '',
      natur: '',
      natural: '',
      naturals: '',
      nbsp: '',
      nbump: '',
      nbumpe: '',
      ncap: '',
      ncaron: '',
      ncedil: '',
      ncong: '',
      ncongdot: '',
      ncup: '',
      ncy: '',
      ndash: '',
      ne: '',
      neArr: '',
      nearhk: '',
      nearr: '',
      nearrow: '',
      nedot: '',
      nequiv: '',
      nesear: '',
      nesim: '',
      nexist: '',
      nexists: '',
      nfr: '',
      ngE: '',
      nge: '',
      ngeq: '',
      ngeqq: '',
      ngeqslant: '',
      nges: '',
      ngsim: '',
      ngt: '',
      ngtr: '',
      nhArr: '',
      nharr: '',
      nhpar: '',
      ni: '',
      nis: '',
      nisd: '',
      niv: '',
      njcy: '',
      nlArr: '',
      nlE: '',
      nlarr: '',
      nldr: '',
      nle: '',
      nleftarrow: '',
      nleftrightarrow: '',
      nleq: '',
      nleqq: '',
      nleqslant: '',
      nles: '',
      nless: '',
      nlsim: '',
      nlt: '',
      nltri: '',
      nltrie: '',
      nmid: '',
      nopf: '',
      not: '',
      notin: '',
      notinE: '',
      notindot: '',
      notinva: '',
      notinvb: '',
      notinvc: '',
      notni: '',
      notniva: '',
      notnivb: '',
      notnivc: '',
      npar: '',
      nparallel: '',
      nparsl: '',
      npart: '',
      npolint: '',
      npr: '',
      nprcue: '',
      npre: '',
      nprec: '',
      npreceq: '',
      nrArr: '',
      nrarr: '',
      nrarrc: '',
      nrarrw: '',
      nrightarrow: '',
      nrtri: '',
      nrtrie: '',
      nsc: '',
      nsccue: '',
      nsce: '',
      nscr: '',
      nshortmid: '',
      nshortparallel: '',
      nsim: '',
      nsime: '',
      nsimeq: '',
      nsmid: '',
      nspar: '',
      nsqsube: '',
      nsqsupe: '',
      nsub: '',
      nsubE: '',
      nsube: '',
      nsubset: '',
      nsubseteq: '',
      nsubseteqq: '',
      nsucc: '',
      nsucceq: '',
      nsup: '',
      nsupE: '',
      nsupe: '',
      nsupset: '',
      nsupseteq: '',
      nsupseteqq: '',
      ntgl: '',
      ntilde: '',
      ntlg: '',
      ntriangleleft: '',
      ntrianglelefteq: '',
      ntriangleright: '',
      ntrianglerighteq: '',
      nu: '',
      num: '#',
      numero: '',
      numsp: '',
      nvDash: '',
      nvHarr: '',
      nvap: '',
      nvdash: '',
      nvge: '',
      nvgt: '>',
      nvinfin: '',
      nvlArr: '',
      nvle: '',
      nvlt: '<',
      nvltrie: '',
      nvrArr: '',
      nvrtrie: '',
      nvsim: '',
      nwArr: '',
      nwarhk: '',
      nwarr: '',
      nwarrow: '',
      nwnear: '',
      oS: '',
      oacute: '',
      oast: '',
      ocir: '',
      ocirc: '',
      ocy: '',
      odash: '',
      odblac: '',
      odiv: '',
      odot: '',
      odsold: '',
      oelig: '',
      ofcir: '',
      ofr: '',
      ogon: '',
      ograve: '',
      ogt: '',
      ohbar: '',
      ohm: '',
      oint: '',
      olarr: '',
      olcir: '',
      olcross: '',
      oline: '',
      olt: '',
      omacr: '',
      omega: '',
      omicron: '',
      omid: '',
      ominus: '',
      oopf: '',
      opar: '',
      operp: '',
      oplus: '',
      or: '',
      orarr: '',
      ord: '',
      order: '',
      orderof: '',
      ordf: '',
      ordm: '',
      origof: '',
      oror: '',
      orslope: '',
      orv: '',
      oscr: '',
      oslash: '',
      osol: '',
      otilde: '',
      otimes: '',
      otimesas: '',
      ouml: '',
      ovbar: '',
      par: '',
      para: '',
      parallel: '',
      parsim: '',
      parsl: '',
      part: '',
      pcy: '',
      percnt: '%',
      period: '.',
      permil: '',
      perp: '',
      pertenk: '',
      pfr: '',
      phi: '',
      phiv: '',
      phmmat: '',
      phone: '',
      pi: '',
      pitchfork: '',
      piv: '',
      planck: '',
      planckh: '',
      plankv: '',
      plus: '+',
      plusacir: '',
      plusb: '',
      pluscir: '',
      plusdo: '',
      plusdu: '',
      pluse: '',
      plusmn: '',
      plussim: '',
      plustwo: '',
      pm: '',
      pointint: '',
      popf: '',
      pound: '',
      pr: '',
      prE: '',
      prap: '',
      prcue: '',
      pre: '',
      prec: '',
      precapprox: '',
      preccurlyeq: '',
      preceq: '',
      precnapprox: '',
      precneqq: '',
      precnsim: '',
      precsim: '',
      prime: '',
      primes: '',
      prnE: '',
      prnap: '',
      prnsim: '',
      prod: '',
      profalar: '',
      profline: '',
      profsurf: '',
      prop: '',
      propto: '',
      prsim: '',
      prurel: '',
      pscr: '',
      psi: '',
      puncsp: '',
      qfr: '',
      qint: '',
      qopf: '',
      qprime: '',
      qscr: '',
      quaternions: '',
      quatint: '',
      quest: '?',
      questeq: '',
      quot: '"',
      rAarr: '',
      rArr: '',
      rAtail: '',
      rBarr: '',
      rHar: '',
      race: '',
      racute: '',
      radic: '',
      raemptyv: '',
      rang: '',
      rangd: '',
      range: '',
      rangle: '',
      raquo: '',
      rarr: '',
      rarrap: '',
      rarrb: '',
      rarrbfs: '',
      rarrc: '',
      rarrfs: '',
      rarrhk: '',
      rarrlp: '',
      rarrpl: '',
      rarrsim: '',
      rarrtl: '',
      rarrw: '',
      ratail: '',
      ratio: '',
      rationals: '',
      rbarr: '',
      rbbrk: '',
      rbrace: '}',
      rbrack: ']',
      rbrke: '',
      rbrksld: '',
      rbrkslu: '',
      rcaron: '',
      rcedil: '',
      rceil: '',
      rcub: '}',
      rcy: '',
      rdca: '',
      rdldhar: '',
      rdquo: '',
      rdquor: '',
      rdsh: '',
      real: '',
      realine: '',
      realpart: '',
      reals: '',
      rect: '',
      reg: '',
      rfisht: '',
      rfloor: '',
      rfr: '',
      rhard: '',
      rharu: '',
      rharul: '',
      rho: '',
      rhov: '',
      rightarrow: '',
      rightarrowtail: '',
      rightharpoondown: '',
      rightharpoonup: '',
      rightleftarrows: '',
      rightleftharpoons: '',
      rightrightarrows: '',
      rightsquigarrow: '',
      rightthreetimes: '',
      ring: '',
      risingdotseq: '',
      rlarr: '',
      rlhar: '',
      rlm: '',
      rmoust: '',
      rmoustache: '',
      rnmid: '',
      roang: '',
      roarr: '',
      robrk: '',
      ropar: '',
      ropf: '',
      roplus: '',
      rotimes: '',
      rpar: ')',
      rpargt: '',
      rppolint: '',
      rrarr: '',
      rsaquo: '',
      rscr: '',
      rsh: '',
      rsqb: ']',
      rsquo: '',
      rsquor: '',
      rthree: '',
      rtimes: '',
      rtri: '',
      rtrie: '',
      rtrif: '',
      rtriltri: '',
      ruluhar: '',
      rx: '',
      sacute: '',
      sbquo: '',
      sc: '',
      scE: '',
      scap: '',
      scaron: '',
      sccue: '',
      sce: '',
      scedil: '',
      scirc: '',
      scnE: '',
      scnap: '',
      scnsim: '',
      scpolint: '',
      scsim: '',
      scy: '',
      sdot: '',
      sdotb: '',
      sdote: '',
      seArr: '',
      searhk: '',
      searr: '',
      searrow: '',
      sect: '',
      semi: ';',
      seswar: '',
      setminus: '',
      setmn: '',
      sext: '',
      sfr: '',
      sfrown: '',
      sharp: '',
      shchcy: '',
      shcy: '',
      shortmid: '',
      shortparallel: '',
      shy: '',
      sigma: '',
      sigmaf: '',
      sigmav: '',
      sim: '',
      simdot: '',
      sime: '',
      simeq: '',
      simg: '',
      simgE: '',
      siml: '',
      simlE: '',
      simne: '',
      simplus: '',
      simrarr: '',
      slarr: '',
      smallsetminus: '',
      smashp: '',
      smeparsl: '',
      smid: '',
      smile: '',
      smt: '',
      smte: '',
      smtes: '',
      softcy: '',
      sol: '/',
      solb: '',
      solbar: '',
      sopf: '',
      spades: '',
      spadesuit: '',
      spar: '',
      sqcap: '',
      sqcaps: '',
      sqcup: '',
      sqcups: '',
      sqsub: '',
      sqsube: '',
      sqsubset: '',
      sqsubseteq: '',
      sqsup: '',
      sqsupe: '',
      sqsupset: '',
      sqsupseteq: '',
      squ: '',
      square: '',
      squarf: '',
      squf: '',
      srarr: '',
      sscr: '',
      ssetmn: '',
      ssmile: '',
      sstarf: '',
      star: '',
      starf: '',
      straightepsilon: '',
      straightphi: '',
      strns: '',
      sub: '',
      subE: '',
      subdot: '',
      sube: '',
      subedot: '',
      submult: '',
      subnE: '',
      subne: '',
      subplus: '',
      subrarr: '',
      subset: '',
      subseteq: '',
      subseteqq: '',
      subsetneq: '',
      subsetneqq: '',
      subsim: '',
      subsub: '',
      subsup: '',
      succ: '',
      succapprox: '',
      succcurlyeq: '',
      succeq: '',
      succnapprox: '',
      succneqq: '',
      succnsim: '',
      succsim: '',
      sum: '',
      sung: '',
      sup1: '',
      sup2: '',
      sup3: '',
      sup: '',
      supE: '',
      supdot: '',
      supdsub: '',
      supe: '',
      supedot: '',
      suphsol: '',
      suphsub: '',
      suplarr: '',
      supmult: '',
      supnE: '',
      supne: '',
      supplus: '',
      supset: '',
      supseteq: '',
      supseteqq: '',
      supsetneq: '',
      supsetneqq: '',
      supsim: '',
      supsub: '',
      supsup: '',
      swArr: '',
      swarhk: '',
      swarr: '',
      swarrow: '',
      swnwar: '',
      szlig: '',
      target: '',
      tau: '',
      tbrk: '',
      tcaron: '',
      tcedil: '',
      tcy: '',
      tdot: '',
      telrec: '',
      tfr: '',
      there4: '',
      therefore: '',
      theta: '',
      thetasym: '',
      thetav: '',
      thickapprox: '',
      thicksim: '',
      thinsp: '',
      thkap: '',
      thksim: '',
      thorn: '',
      tilde: '',
      times: '',
      timesb: '',
      timesbar: '',
      timesd: '',
      tint: '',
      toea: '',
      top: '',
      topbot: '',
      topcir: '',
      topf: '',
      topfork: '',
      tosa: '',
      tprime: '',
      trade: '',
      triangle: '',
      triangledown: '',
      triangleleft: '',
      trianglelefteq: '',
      triangleq: '',
      triangleright: '',
      trianglerighteq: '',
      tridot: '',
      trie: '',
      triminus: '',
      triplus: '',
      trisb: '',
      tritime: '',
      trpezium: '',
      tscr: '',
      tscy: '',
      tshcy: '',
      tstrok: '',
      twixt: '',
      twoheadleftarrow: '',
      twoheadrightarrow: '',
      uArr: '',
      uHar: '',
      uacute: '',
      uarr: '',
      ubrcy: '',
      ubreve: '',
      ucirc: '',
      ucy: '',
      udarr: '',
      udblac: '',
      udhar: '',
      ufisht: '',
      ufr: '',
      ugrave: '',
      uharl: '',
      uharr: '',
      uhblk: '',
      ulcorn: '',
      ulcorner: '',
      ulcrop: '',
      ultri: '',
      umacr: '',
      uml: '',
      uogon: '',
      uopf: '',
      uparrow: '',
      updownarrow: '',
      upharpoonleft: '',
      upharpoonright: '',
      uplus: '',
      upsi: '',
      upsih: '',
      upsilon: '',
      upuparrows: '',
      urcorn: '',
      urcorner: '',
      urcrop: '',
      uring: '',
      urtri: '',
      uscr: '',
      utdot: '',
      utilde: '',
      utri: '',
      utrif: '',
      uuarr: '',
      uuml: '',
      uwangle: '',
      vArr: '',
      vBar: '',
      vBarv: '',
      vDash: '',
      vangrt: '',
      varepsilon: '',
      varkappa: '',
      varnothing: '',
      varphi: '',
      varpi: '',
      varpropto: '',
      varr: '',
      varrho: '',
      varsigma: '',
      varsubsetneq: '',
      varsubsetneqq: '',
      varsupsetneq: '',
      varsupsetneqq: '',
      vartheta: '',
      vartriangleleft: '',
      vartriangleright: '',
      vcy: '',
      vdash: '',
      vee: '',
      veebar: '',
      veeeq: '',
      vellip: '',
      verbar: '|',
      vert: '|',
      vfr: '',
      vltri: '',
      vnsub: '',
      vnsup: '',
      vopf: '',
      vprop: '',
      vrtri: '',
      vscr: '',
      vsubnE: '',
      vsubne: '',
      vsupnE: '',
      vsupne: '',
      vzigzag: '',
      wcirc: '',
      wedbar: '',
      wedge: '',
      wedgeq: '',
      weierp: '',
      wfr: '',
      wopf: '',
      wp: '',
      wr: '',
      wreath: '',
      wscr: '',
      xcap: '',
      xcirc: '',
      xcup: '',
      xdtri: '',
      xfr: '',
      xhArr: '',
      xharr: '',
      xi: '',
      xlArr: '',
      xlarr: '',
      xmap: '',
      xnis: '',
      xodot: '',
      xopf: '',
      xoplus: '',
      xotime: '',
      xrArr: '',
      xrarr: '',
      xscr: '',
      xsqcup: '',
      xuplus: '',
      xutri: '',
      xvee: '',
      xwedge: '',
      yacute: '',
      yacy: '',
      ycirc: '',
      ycy: '',
      yen: '',
      yfr: '',
      yicy: '',
      yopf: '',
      yscr: '',
      yucy: '',
      yuml: '',
      zacute: '',
      zcaron: '',
      zcy: '',
      zdot: '',
      zeetrf: '',
      zeta: '',
      zfr: '',
      zhcy: '',
      zigrarr: '',
      zopf: '',
      zscr: '',
      zwj: '',
      zwnj: ''
    };

    const own$7 = {}.hasOwnProperty;

    /**
     * Decode a single character reference (without the `&` or `;`).
     * You probably only need this when youre building parsers yourself that follow
     * different rules compared to HTML.
     * This is optimized to be tiny in browsers.
     *
     * @param {string} value
     *   `notin` (named), `#123` (deci), `#x123` (hexa).
     * @returns {string|false}
     *   Decoded reference.
     */
    function decodeNamedCharacterReference(value) {
      return own$7.call(characterEntities, value) ? characterEntities[value] : false
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const characterReference = {
      name: 'characterReference',
      tokenize: tokenizeCharacterReference
    };
    /** @type {Tokenizer} */

    function tokenizeCharacterReference(effects, ok, nok) {
      const self = this;
      let size = 0;
      /** @type {number} */

      let max;
      /** @type {(code: Code) => code is number} */

      let test;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('characterReference');
        effects.enter('characterReferenceMarker');
        effects.consume(code);
        effects.exit('characterReferenceMarker');
        return open
      }
      /** @type {State} */

      function open(code) {
        if (code === 35) {
          effects.enter('characterReferenceMarkerNumeric');
          effects.consume(code);
          effects.exit('characterReferenceMarkerNumeric');
          return numeric
        }

        effects.enter('characterReferenceValue');
        max = 31;
        test = asciiAlphanumeric;
        return value(code)
      }
      /** @type {State} */

      function numeric(code) {
        if (code === 88 || code === 120) {
          effects.enter('characterReferenceMarkerHexadecimal');
          effects.consume(code);
          effects.exit('characterReferenceMarkerHexadecimal');
          effects.enter('characterReferenceValue');
          max = 6;
          test = asciiHexDigit;
          return value
        }

        effects.enter('characterReferenceValue');
        max = 7;
        test = asciiDigit;
        return value(code)
      }
      /** @type {State} */

      function value(code) {
        /** @type {Token} */
        let token;

        if (code === 59 && size) {
          token = effects.exit('characterReferenceValue');

          if (
            test === asciiAlphanumeric &&
            !decodeNamedCharacterReference(self.sliceSerialize(token))
          ) {
            return nok(code)
          }

          effects.enter('characterReferenceMarker');
          effects.consume(code);
          effects.exit('characterReferenceMarker');
          effects.exit('characterReference');
          return ok
        }

        if (test(code) && size++ < max) {
          effects.consume(code);
          return value
        }

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const codeFenced = {
      name: 'codeFenced',
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    /** @type {Tokenizer} */

    function tokenizeCodeFenced(effects, ok, nok) {
      const self = this;
      /** @type {Construct} */

      const closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      /** @type {Construct} */

      const nonLazyLine = {
        tokenize: tokenizeNonLazyLine,
        partial: true
      };
      const tail = this.events[this.events.length - 1];
      const initialPrefix =
        tail && tail[1].type === 'linePrefix'
          ? tail[2].sliceSerialize(tail[1], true).length
          : 0;
      let sizeOpen = 0;
      /** @type {NonNullable<Code>} */

      let marker;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('codeFenced');
        effects.enter('codeFencedFence');
        effects.enter('codeFencedFenceSequence');
        marker = code;
        return sequenceOpen(code)
      }
      /** @type {State} */

      function sequenceOpen(code) {
        if (code === marker) {
          effects.consume(code);
          sizeOpen++;
          return sequenceOpen
        }

        effects.exit('codeFencedFenceSequence');
        return sizeOpen < 3
          ? nok(code)
          : factorySpace(effects, infoOpen, 'whitespace')(code)
      }
      /** @type {State} */

      function infoOpen(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code)
        }

        effects.enter('codeFencedFenceInfo');
        effects.enter('chunkString', {
          contentType: 'string'
        });
        return info(code)
      }
      /** @type {State} */

      function info(code) {
        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit('chunkString');
          effects.exit('codeFencedFenceInfo');
          return factorySpace(effects, infoAfter, 'whitespace')(code)
        }

        if (code === 96 && code === marker) return nok(code)
        effects.consume(code);
        return info
      }
      /** @type {State} */

      function infoAfter(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code)
        }

        effects.enter('codeFencedFenceMeta');
        effects.enter('chunkString', {
          contentType: 'string'
        });
        return meta(code)
      }
      /** @type {State} */

      function meta(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('chunkString');
          effects.exit('codeFencedFenceMeta');
          return openAfter(code)
        }

        if (code === 96 && code === marker) return nok(code)
        effects.consume(code);
        return meta
      }
      /** @type {State} */

      function openAfter(code) {
        effects.exit('codeFencedFence');
        return self.interrupt ? ok(code) : contentStart(code)
      }
      /** @type {State} */

      function contentStart(code) {
        if (code === null) {
          return after(code)
        }

        if (markdownLineEnding(code)) {
          return effects.attempt(
            nonLazyLine,
            effects.attempt(
              closingFenceConstruct,
              after,
              initialPrefix
                ? factorySpace(
                    effects,
                    contentStart,
                    'linePrefix',
                    initialPrefix + 1
                  )
                : contentStart
            ),
            after
          )(code)
        }

        effects.enter('codeFlowValue');
        return contentContinue(code)
      }
      /** @type {State} */

      function contentContinue(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('codeFlowValue');
          return contentStart(code)
        }

        effects.consume(code);
        return contentContinue
      }
      /** @type {State} */

      function after(code) {
        effects.exit('codeFenced');
        return ok(code)
      }
      /** @type {Tokenizer} */

      function tokenizeNonLazyLine(effects, ok, nok) {
        const self = this;
        return start
        /** @type {State} */

        function start(code) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return lineStart
        }
        /** @type {State} */

        function lineStart(code) {
          return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
        }
      }
      /** @type {Tokenizer} */

      function tokenizeClosingFence(effects, ok, nok) {
        let size = 0;
        return factorySpace(
          effects,
          closingSequenceStart,
          'linePrefix',
          this.parser.constructs.disable.null.includes('codeIndented')
            ? undefined
            : 4
        )
        /** @type {State} */

        function closingSequenceStart(code) {
          effects.enter('codeFencedFence');
          effects.enter('codeFencedFenceSequence');
          return closingSequence(code)
        }
        /** @type {State} */

        function closingSequence(code) {
          if (code === marker) {
            effects.consume(code);
            size++;
            return closingSequence
          }

          if (size < sizeOpen) return nok(code)
          effects.exit('codeFencedFenceSequence');
          return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)
        }
        /** @type {State} */

        function closingSequenceEnd(code) {
          if (code === null || markdownLineEnding(code)) {
            effects.exit('codeFencedFence');
            return ok(code)
          }

          return nok(code)
        }
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const codeIndented = {
      name: 'codeIndented',
      tokenize: tokenizeCodeIndented
    };
    /** @type {Construct} */

    const indentedContent = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    /** @type {Tokenizer} */

    function tokenizeCodeIndented(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('codeIndented');
        return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)
      }
      /** @type {State} */

      function afterStartPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail &&
          tail[1].type === 'linePrefix' &&
          tail[2].sliceSerialize(tail[1], true).length >= 4
          ? afterPrefix(code)
          : nok(code)
      }
      /** @type {State} */

      function afterPrefix(code) {
        if (code === null) {
          return after(code)
        }

        if (markdownLineEnding(code)) {
          return effects.attempt(indentedContent, afterPrefix, after)(code)
        }

        effects.enter('codeFlowValue');
        return content(code)
      }
      /** @type {State} */

      function content(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('codeFlowValue');
          return afterPrefix(code)
        }

        effects.consume(code);
        return content
      }
      /** @type {State} */

      function after(code) {
        effects.exit('codeIndented');
        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeIndentedContent(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        // If this is a lazy line, it cant be code.
        if (self.parser.lazy[self.now().line]) {
          return nok(code)
        }

        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return start
        }

        return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)
      }
      /** @type {State} */

      function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail &&
          tail[1].type === 'linePrefix' &&
          tail[2].sliceSerialize(tail[1], true).length >= 4
          ? ok(code)
          : markdownLineEnding(code)
          ? start(code)
          : nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Previous} Previous
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const codeText = {
      name: 'codeText',
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous: previous$1
    };
    /** @type {Resolver} */

    function resolveCodeText(events) {
      let tailExitIndex = events.length - 4;
      let headEnterIndex = 3;
      /** @type {number} */

      let index;
      /** @type {number|undefined} */

      let enter; // If we start and end with an EOL or a space.

      if (
        (events[headEnterIndex][1].type === 'lineEnding' ||
          events[headEnterIndex][1].type === 'space') &&
        (events[tailExitIndex][1].type === 'lineEnding' ||
          events[tailExitIndex][1].type === 'space')
      ) {
        index = headEnterIndex; // And we have data.

        while (++index < tailExitIndex) {
          if (events[index][1].type === 'codeTextData') {
            // Then we have padding.
            events[headEnterIndex][1].type = 'codeTextPadding';
            events[tailExitIndex][1].type = 'codeTextPadding';
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break
          }
        }
      } // Merge adjacent spaces and data.

      index = headEnterIndex - 1;
      tailExitIndex++;

      while (++index <= tailExitIndex) {
        if (enter === undefined) {
          if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
            enter = index;
          }
        } else if (
          index === tailExitIndex ||
          events[index][1].type === 'lineEnding'
        ) {
          events[enter][1].type = 'codeTextData';

          if (index !== enter + 2) {
            events[enter][1].end = events[index - 1][1].end;
            events.splice(enter + 2, index - enter - 2);
            tailExitIndex -= index - enter - 2;
            index = enter + 2;
          }

          enter = undefined;
        }
      }

      return events
    }
    /** @type {Previous} */

    function previous$1(code) {
      // If there is a previous code, there will always be a tail.
      return (
        code !== 96 ||
        this.events[this.events.length - 1][1].type === 'characterEscape'
      )
    }
    /** @type {Tokenizer} */

    function tokenizeCodeText(effects, ok, nok) {
      let sizeOpen = 0;
      /** @type {number} */

      let size;
      /** @type {Token} */

      let token;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('codeText');
        effects.enter('codeTextSequence');
        return openingSequence(code)
      }
      /** @type {State} */

      function openingSequence(code) {
        if (code === 96) {
          effects.consume(code);
          sizeOpen++;
          return openingSequence
        }

        effects.exit('codeTextSequence');
        return gap(code)
      }
      /** @type {State} */

      function gap(code) {
        // EOF.
        if (code === null) {
          return nok(code)
        } // Closing fence?
        // Could also be data.

        if (code === 96) {
          token = effects.enter('codeTextSequence');
          size = 0;
          return closingSequence(code)
        } // Tabs dont work, and virtual spaces dont make sense.

        if (code === 32) {
          effects.enter('space');
          effects.consume(code);
          effects.exit('space');
          return gap
        }

        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return gap
        } // Data.

        effects.enter('codeTextData');
        return data(code)
      } // In code.

      /** @type {State} */

      function data(code) {
        if (
          code === null ||
          code === 32 ||
          code === 96 ||
          markdownLineEnding(code)
        ) {
          effects.exit('codeTextData');
          return gap(code)
        }

        effects.consume(code);
        return data
      } // Closing fence.

      /** @type {State} */

      function closingSequence(code) {
        // More.
        if (code === 96) {
          effects.consume(code);
          size++;
          return closingSequence
        } // Done!

        if (size === sizeOpen) {
          effects.exit('codeTextSequence');
          effects.exit('codeText');
          return ok(code)
        } // More or less accents: mark as data.

        token.type = 'codeTextData';
        return data(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').Chunk} Chunk
     * @typedef {import('micromark-util-types').Event} Event
     */

    /**
     * Tokenize subcontent.
     *
     * @param {Event[]} events
     * @returns {boolean}
     */
    function subtokenize(events) {
      /** @type {Record<string, number>} */
      const jumps = {};
      let index = -1;
      /** @type {Event} */

      let event;
      /** @type {number|undefined} */

      let lineIndex;
      /** @type {number} */

      let otherIndex;
      /** @type {Event} */

      let otherEvent;
      /** @type {Event[]} */

      let parameters;
      /** @type {Event[]} */

      let subevents;
      /** @type {boolean|undefined} */

      let more;

      while (++index < events.length) {
        while (index in jumps) {
          index = jumps[index];
        }

        event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text
        // is in the first content of a list item.

        if (
          index &&
          event[1].type === 'chunkFlow' &&
          events[index - 1][1].type === 'listItemPrefix'
        ) {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;

          if (
            otherIndex < subevents.length &&
            subevents[otherIndex][1].type === 'lineEndingBlank'
          ) {
            otherIndex += 2;
          }

          if (
            otherIndex < subevents.length &&
            subevents[otherIndex][1].type === 'content'
          ) {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === 'content') {
                break
              }

              if (subevents[otherIndex][1].type === 'chunkText') {
                subevents[otherIndex][1]._isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        } // Enter.

        if (event[0] === 'enter') {
          if (event[1].contentType) {
            Object.assign(jumps, subcontent(events, index));
            index = jumps[index];
            more = true;
          }
        } // Exit.
        else if (event[1]._container) {
          otherIndex = index;
          lineIndex = undefined;

          while (otherIndex--) {
            otherEvent = events[otherIndex];

            if (
              otherEvent[1].type === 'lineEnding' ||
              otherEvent[1].type === 'lineEndingBlank'
            ) {
              if (otherEvent[0] === 'enter') {
                if (lineIndex) {
                  events[lineIndex][1].type = 'lineEndingBlank';
                }

                otherEvent[1].type = 'lineEnding';
                lineIndex = otherIndex;
              }
            } else {
              break
            }
          }

          if (lineIndex) {
            // Fix position.
            event[1].end = Object.assign({}, events[lineIndex][1].start); // Switch container exit w/ line endings.

            parameters = events.slice(lineIndex, index);
            parameters.unshift(event);
            splice(events, lineIndex, index - lineIndex + 1, parameters);
          }
        }
      }

      return !more
    }
    /**
     * Tokenize embedded tokens.
     *
     * @param {Event[]} events
     * @param {number} eventIndex
     * @returns {Record<string, number>}
     */

    function subcontent(events, eventIndex) {
      const token = events[eventIndex][1];
      const context = events[eventIndex][2];
      let startPosition = eventIndex - 1;
      /** @type {number[]} */

      const startPositions = [];
      const tokenizer =
        token._tokenizer || context.parser[token.contentType](token.start);
      const childEvents = tokenizer.events;
      /** @type {[number, number][]} */

      const jumps = [];
      /** @type {Record<string, number>} */

      const gaps = {};
      /** @type {Chunk[]} */

      let stream;
      /** @type {Token|undefined} */

      let previous;
      let index = -1;
      /** @type {Token|undefined} */

      let current = token;
      let adjust = 0;
      let start = 0;
      const breaks = [start]; // Loop forward through the linked tokens to pass them in order to the
      // subtokenizer.

      while (current) {
        // Find the position of the event for this token.
        while (events[++startPosition][1] !== current) {
          // Empty.
        }

        startPositions.push(startPosition);

        if (!current._tokenizer) {
          stream = context.sliceStream(current);

          if (!current.next) {
            stream.push(null);
          }

          if (previous) {
            tokenizer.defineSkip(current.start);
          }

          if (current._isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = true;
          }

          tokenizer.write(stream);

          if (current._isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = undefined;
          }
        } // Unravel the next token.

        previous = current;
        current = current.next;
      } // Now, loop back through all events (and linked tokens), to figure out which
      // parts belong where.

      current = token;

      while (++index < childEvents.length) {
        if (
          // Find a void token that includes a break.
          childEvents[index][0] === 'exit' &&
          childEvents[index - 1][0] === 'enter' &&
          childEvents[index][1].type === childEvents[index - 1][1].type &&
          childEvents[index][1].start.line !== childEvents[index][1].end.line
        ) {
          start = index + 1;
          breaks.push(start); // Help GC.

          current._tokenizer = undefined;
          current.previous = undefined;
          current = current.next;
        }
      } // Help GC.

      tokenizer.events = []; // If theres one more token (which is the cases for lines that end in an
      // EOF), thats perfect: the last point we found starts it.
      // If there isnt then make sure any remaining content is added to it.

      if (current) {
        // Help GC.
        current._tokenizer = undefined;
        current.previous = undefined;
      } else {
        breaks.pop();
      } // Now splice the events from the subtokenizer into the current events,
      // moving back to front so that splice indices arent affected.

      index = breaks.length;

      while (index--) {
        const slice = childEvents.slice(breaks[index], breaks[index + 1]);
        const start = startPositions.pop();
        jumps.unshift([start, start + slice.length - 1]);
        splice(events, start, 2, slice);
      }

      index = -1;

      while (++index < jumps.length) {
        gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
        adjust += jumps[index][1] - jumps[index][0] - 1;
      }

      return gaps
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     */

    /**
     * No name because it must not be turned off.
     * @type {Construct}
     */
    const content = {
      tokenize: tokenizeContent,
      resolve: resolveContent
    };
    /** @type {Construct} */

    const continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    /**
     * Content is transparent: its parsed right now. That way, definitions are also
     * parsed right now: before text in paragraphs (specifically, media) are parsed.
     *
     * @type {Resolver}
     */

    function resolveContent(events) {
      subtokenize(events);
      return events
    }
    /** @type {Tokenizer} */

    function tokenizeContent(effects, ok) {
      /** @type {Token} */
      let previous;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('content');
        previous = effects.enter('chunkContent', {
          contentType: 'content'
        });
        return data(code)
      }
      /** @type {State} */

      function data(code) {
        if (code === null) {
          return contentEnd(code)
        }

        if (markdownLineEnding(code)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code)
        } // Data.

        effects.consume(code);
        return data
      }
      /** @type {State} */

      function contentEnd(code) {
        effects.exit('chunkContent');
        effects.exit('content');
        return ok(code)
      }
      /** @type {State} */

      function contentContinue(code) {
        effects.consume(code);
        effects.exit('chunkContent');
        previous.next = effects.enter('chunkContent', {
          contentType: 'content',
          previous
        });
        previous = previous.next;
        return data
      }
    }
    /** @type {Tokenizer} */

    function tokenizeContinuation(effects, ok, nok) {
      const self = this;
      return startLookahead
      /** @type {State} */

      function startLookahead(code) {
        effects.exit('chunkContent');
        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        return factorySpace(effects, prefixed, 'linePrefix')
      }
      /** @type {State} */

      function prefixed(code) {
        if (code === null || markdownLineEnding(code)) {
          return nok(code)
        }

        const tail = self.events[self.events.length - 1];

        if (
          !self.parser.constructs.disable.null.includes('codeIndented') &&
          tail &&
          tail[1].type === 'linePrefix' &&
          tail[2].sliceSerialize(tail[1], true).length >= 4
        ) {
          return ok(code)
        }

        return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').State} State
     */

    /**
     * @param {Effects} effects
     * @param {State} ok
     * @param {State} nok
     * @param {string} type
     * @param {string} literalType
     * @param {string} literalMarkerType
     * @param {string} rawType
     * @param {string} stringType
     * @param {number} [max=Infinity]
     * @returns {State}
     */
    // eslint-disable-next-line max-params
    function factoryDestination(
      effects,
      ok,
      nok,
      type,
      literalType,
      literalMarkerType,
      rawType,
      stringType,
      max
    ) {
      const limit = max || Number.POSITIVE_INFINITY;
      let balance = 0;
      return start
      /** @type {State} */

      function start(code) {
        if (code === 60) {
          effects.enter(type);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore
        }

        if (code === null || code === 41 || asciiControl(code)) {
          return nok(code)
        }

        effects.enter(type);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter('chunkString', {
          contentType: 'string'
        });
        return destinationRaw(code)
      }
      /** @type {State} */

      function destinationEnclosedBefore(code) {
        if (code === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type);
          return ok
        }

        effects.enter(stringType);
        effects.enter('chunkString', {
          contentType: 'string'
        });
        return destinationEnclosed(code)
      }
      /** @type {State} */

      function destinationEnclosed(code) {
        if (code === 62) {
          effects.exit('chunkString');
          effects.exit(stringType);
          return destinationEnclosedBefore(code)
        }

        if (code === null || code === 60 || markdownLineEnding(code)) {
          return nok(code)
        }

        effects.consume(code);
        return code === 92 ? destinationEnclosedEscape : destinationEnclosed
      }
      /** @type {State} */

      function destinationEnclosedEscape(code) {
        if (code === 60 || code === 62 || code === 92) {
          effects.consume(code);
          return destinationEnclosed
        }

        return destinationEnclosed(code)
      }
      /** @type {State} */

      function destinationRaw(code) {
        if (code === 40) {
          if (++balance > limit) return nok(code)
          effects.consume(code);
          return destinationRaw
        }

        if (code === 41) {
          if (!balance--) {
            effects.exit('chunkString');
            effects.exit(stringType);
            effects.exit(rawType);
            effects.exit(type);
            return ok(code)
          }

          effects.consume(code);
          return destinationRaw
        }

        if (code === null || markdownLineEndingOrSpace(code)) {
          if (balance) return nok(code)
          effects.exit('chunkString');
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type);
          return ok(code)
        }

        if (asciiControl(code)) return nok(code)
        effects.consume(code);
        return code === 92 ? destinationRawEscape : destinationRaw
      }
      /** @type {State} */

      function destinationRawEscape(code) {
        if (code === 40 || code === 41 || code === 92) {
          effects.consume(code);
          return destinationRaw
        }

        return destinationRaw(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').State} State
     */

    /**
     * @this {TokenizeContext}
     * @param {Effects} effects
     * @param {State} ok
     * @param {State} nok
     * @param {string} type
     * @param {string} markerType
     * @param {string} stringType
     * @returns {State}
     */
    // eslint-disable-next-line max-params
    function factoryLabel(effects, ok, nok, type, markerType, stringType) {
      const self = this;
      let size = 0;
      /** @type {boolean} */

      let data;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak
      }
      /** @type {State} */

      function atBreak(code) {
        if (
          code === null ||
          code === 91 ||
          (code === 93 && !data) ||
          /* To do: remove in the future once weve switched from
           * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
           * which doesnt need this */

          /* Hidden footnotes hook */

          /* c8 ignore next 3 */
          (code === 94 &&
            !size &&
            '_hiddenFootnoteSupport' in self.parser.constructs) ||
          size > 999
        ) {
          return nok(code)
        }

        if (code === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok
        }

        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return atBreak
        }

        effects.enter('chunkString', {
          contentType: 'string'
        });
        return label(code)
      }
      /** @type {State} */

      function label(code) {
        if (
          code === null ||
          code === 91 ||
          code === 93 ||
          markdownLineEnding(code) ||
          size++ > 999
        ) {
          effects.exit('chunkString');
          return atBreak(code)
        }

        effects.consume(code);
        data = data || !markdownSpace(code);
        return code === 92 ? labelEscape : label
      }
      /** @type {State} */

      function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return label
        }

        return label(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /**
     * @param {Effects} effects
     * @param {State} ok
     * @param {State} nok
     * @param {string} type
     * @param {string} markerType
     * @param {string} stringType
     * @returns {State}
     */
    // eslint-disable-next-line max-params
    function factoryTitle(effects, ok, nok, type, markerType, stringType) {
      /** @type {NonNullable<Code>} */
      let marker;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        marker = code === 40 ? 41 : code;
        return atFirstTitleBreak
      }
      /** @type {State} */

      function atFirstTitleBreak(code) {
        if (code === marker) {
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok
        }

        effects.enter(stringType);
        return atTitleBreak(code)
      }
      /** @type {State} */

      function atTitleBreak(code) {
        if (code === marker) {
          effects.exit(stringType);
          return atFirstTitleBreak(marker)
        }

        if (code === null) {
          return nok(code)
        } // Note: blank lines cant exist in content.

        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return factorySpace(effects, atTitleBreak, 'linePrefix')
        }

        effects.enter('chunkString', {
          contentType: 'string'
        });
        return title(code)
      }
      /** @type {State} */

      function title(code) {
        if (code === marker || code === null || markdownLineEnding(code)) {
          effects.exit('chunkString');
          return atTitleBreak(code)
        }

        effects.consume(code);
        return code === 92 ? titleEscape : title
      }
      /** @type {State} */

      function titleEscape(code) {
        if (code === marker || code === 92) {
          effects.consume(code);
          return title
        }

        return title(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').State} State
     */

    /**
     * @param {Effects} effects
     * @param {State} ok
     */
    function factoryWhitespace(effects, ok) {
      /** @type {boolean} */
      let seen;
      return start
      /** @type {State} */

      function start(code) {
        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          seen = true;
          return start
        }

        if (markdownSpace(code)) {
          return factorySpace(
            effects,
            start,
            seen ? 'linePrefix' : 'lineSuffix'
          )(code)
        }

        return ok(code)
      }
    }

    /**
     * Normalize an identifier (such as used in definitions).
     *
     * @param {string} value
     * @returns {string}
     */
    function normalizeIdentifier(value) {
      return (
        value // Collapse Markdown whitespace.
          .replace(/[\t\n\r ]+/g, ' ') // Trim.
          .replace(/^ | $/g, '') // Some characters are considered uppercase, but if their lowercase
          // counterpart is uppercased will result in a different uppercase
          // character.
          // Hence, to get that form, we perform both lower- and uppercase.
          // Upper case makes sure keys will not interact with default prototypal
          // methods: no method is uppercase.
          .toLowerCase()
          .toUpperCase()
      )
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const definition = {
      name: 'definition',
      tokenize: tokenizeDefinition
    };
    /** @type {Construct} */

    const titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    /** @type {Tokenizer} */

    function tokenizeDefinition(effects, ok, nok) {
      const self = this;
      /** @type {string} */

      let identifier;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('definition');
        return factoryLabel.call(
          self,
          effects,
          labelAfter,
          nok,
          'definitionLabel',
          'definitionLabelMarker',
          'definitionLabelString'
        )(code)
      }
      /** @type {State} */

      function labelAfter(code) {
        identifier = normalizeIdentifier(
          self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
        );

        if (code === 58) {
          effects.enter('definitionMarker');
          effects.consume(code);
          effects.exit('definitionMarker'); // Note: blank lines cant exist in content.

          return factoryWhitespace(
            effects,
            factoryDestination(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace(effects, after, 'whitespace'),
                factorySpace(effects, after, 'whitespace')
              ),
              nok,
              'definitionDestination',
              'definitionDestinationLiteral',
              'definitionDestinationLiteralMarker',
              'definitionDestinationRaw',
              'definitionDestinationString'
            )
          )
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('definition');

          if (!self.parser.defined.includes(identifier)) {
            self.parser.defined.push(identifier);
          }

          return ok(code)
        }

        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeTitle(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        return markdownLineEndingOrSpace(code)
          ? factoryWhitespace(effects, before)(code)
          : nok(code)
      }
      /** @type {State} */

      function before(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factorySpace(effects, after, 'whitespace'),
            nok,
            'definitionTitle',
            'definitionTitleMarker',
            'definitionTitleString'
          )(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const hardBreakEscape = {
      name: 'hardBreakEscape',
      tokenize: tokenizeHardBreakEscape
    };
    /** @type {Tokenizer} */

    function tokenizeHardBreakEscape(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('hardBreakEscape');
        effects.enter('escapeMarker');
        effects.consume(code);
        return open
      }
      /** @type {State} */

      function open(code) {
        if (markdownLineEnding(code)) {
          effects.exit('escapeMarker');
          effects.exit('hardBreakEscape');
          return ok(code)
        }

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const headingAtx = {
      name: 'headingAtx',
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    /** @type {Resolver} */

    function resolveHeadingAtx(events, context) {
      let contentEnd = events.length - 2;
      let contentStart = 3;
      /** @type {Token} */

      let content;
      /** @type {Token} */

      let text; // Prefix whitespace, part of the opening.

      if (events[contentStart][1].type === 'whitespace') {
        contentStart += 2;
      } // Suffix whitespace, part of the closing.

      if (
        contentEnd - 2 > contentStart &&
        events[contentEnd][1].type === 'whitespace'
      ) {
        contentEnd -= 2;
      }

      if (
        events[contentEnd][1].type === 'atxHeadingSequence' &&
        (contentStart === contentEnd - 1 ||
          (contentEnd - 4 > contentStart &&
            events[contentEnd - 2][1].type === 'whitespace'))
      ) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }

      if (contentEnd > contentStart) {
        content = {
          type: 'atxHeadingText',
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text = {
          type: 'chunkText',
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          // @ts-expect-error Constants are fine to assign.
          contentType: 'text'
        };
        splice(events, contentStart, contentEnd - contentStart + 1, [
          ['enter', content, context],
          ['enter', text, context],
          ['exit', text, context],
          ['exit', content, context]
        ]);
      }

      return events
    }
    /** @type {Tokenizer} */

    function tokenizeHeadingAtx(effects, ok, nok) {
      const self = this;
      let size = 0;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('atxHeading');
        effects.enter('atxHeadingSequence');
        return fenceOpenInside(code)
      }
      /** @type {State} */

      function fenceOpenInside(code) {
        if (code === 35 && size++ < 6) {
          effects.consume(code);
          return fenceOpenInside
        }

        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit('atxHeadingSequence');
          return self.interrupt ? ok(code) : headingBreak(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function headingBreak(code) {
        if (code === 35) {
          effects.enter('atxHeadingSequence');
          return sequence(code)
        }

        if (code === null || markdownLineEnding(code)) {
          effects.exit('atxHeading');
          return ok(code)
        }

        if (markdownSpace(code)) {
          return factorySpace(effects, headingBreak, 'whitespace')(code)
        }

        effects.enter('atxHeadingText');
        return data(code)
      }
      /** @type {State} */

      function sequence(code) {
        if (code === 35) {
          effects.consume(code);
          return sequence
        }

        effects.exit('atxHeadingSequence');
        return headingBreak(code)
      }
      /** @type {State} */

      function data(code) {
        if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
          effects.exit('atxHeadingText');
          return headingBreak(code)
        }

        effects.consume(code);
        return data
      }
    }

    /**
     * List of lowercase HTML tag names which when parsing HTML (flow), result
     * in more relaxed rules (condition 6): because they are known blocks, the
     * HTML-like syntax doesnt have to be strictly parsed.
     * For tag names not in this list, a more strict algorithm (condition 7) is used
     * to detect whether the HTML-like syntax is seen as HTML (flow) or not.
     *
     * This is copied from:
     * <https://spec.commonmark.org/0.30/#html-blocks>.
     */
    const htmlBlockNames = [
      'address',
      'article',
      'aside',
      'base',
      'basefont',
      'blockquote',
      'body',
      'caption',
      'center',
      'col',
      'colgroup',
      'dd',
      'details',
      'dialog',
      'dir',
      'div',
      'dl',
      'dt',
      'fieldset',
      'figcaption',
      'figure',
      'footer',
      'form',
      'frame',
      'frameset',
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      'head',
      'header',
      'hr',
      'html',
      'iframe',
      'legend',
      'li',
      'link',
      'main',
      'menu',
      'menuitem',
      'nav',
      'noframes',
      'ol',
      'optgroup',
      'option',
      'p',
      'param',
      'section',
      'summary',
      'table',
      'tbody',
      'td',
      'tfoot',
      'th',
      'thead',
      'title',
      'tr',
      'track',
      'ul'
    ];

    /**
     * List of lowercase HTML tag names which when parsing HTML (flow), result in
     * HTML that can include lines w/o exiting, until a closing tag also in this
     * list is found (condition 1).
     *
     * This module is copied from:
     * <https://spec.commonmark.org/0.30/#html-blocks>.
     *
     * Note that `textarea` was added in `CommonMark@0.30`.
     */
    const htmlRawNames = ['pre', 'script', 'style', 'textarea'];

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */
    /** @type {Construct} */

    const htmlFlow = {
      name: 'htmlFlow',
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    /** @type {Construct} */

    const nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    /** @type {Resolver} */

    function resolveToHtmlFlow(events) {
      let index = events.length;

      while (index--) {
        if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
          break
        }
      }

      if (index > 1 && events[index - 2][1].type === 'linePrefix') {
        // Add the prefix start to the HTML token.
        events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.

        events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.

        events.splice(index - 2, 2);
      }

      return events
    }
    /** @type {Tokenizer} */

    function tokenizeHtmlFlow(effects, ok, nok) {
      const self = this;
      /** @type {number} */

      let kind;
      /** @type {boolean} */

      let startTag;
      /** @type {string} */

      let buffer;
      /** @type {number} */

      let index;
      /** @type {Code} */

      let marker;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('htmlFlow');
        effects.enter('htmlFlowData');
        effects.consume(code);
        return open
      }
      /** @type {State} */

      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationStart
        }

        if (code === 47) {
          effects.consume(code);
          return tagCloseStart
        }

        if (code === 63) {
          effects.consume(code);
          kind = 3; // While were in an instruction instead of a declaration, were on a `?`
          // right now, so we do need to search for `>`, similar to declarations.

          return self.interrupt ? ok : continuationDeclarationInside
        }

        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = String.fromCharCode(code);
          startTag = true;
          return tagName
        }

        return nok(code)
      }
      /** @type {State} */

      function declarationStart(code) {
        if (code === 45) {
          effects.consume(code);
          kind = 2;
          return commentOpenInside
        }

        if (code === 91) {
          effects.consume(code);
          kind = 5;
          buffer = 'CDATA[';
          index = 0;
          return cdataOpenInside
        }

        if (asciiAlpha(code)) {
          effects.consume(code);
          kind = 4;
          return self.interrupt ? ok : continuationDeclarationInside
        }

        return nok(code)
      }
      /** @type {State} */

      function commentOpenInside(code) {
        if (code === 45) {
          effects.consume(code);
          return self.interrupt ? ok : continuationDeclarationInside
        }

        return nok(code)
      }
      /** @type {State} */

      function cdataOpenInside(code) {
        if (code === buffer.charCodeAt(index++)) {
          effects.consume(code);
          return index === buffer.length
            ? self.interrupt
              ? ok
              : continuation
            : cdataOpenInside
        }

        return nok(code)
      }
      /** @type {State} */

      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = String.fromCharCode(code);
          return tagName
        }

        return nok(code)
      }
      /** @type {State} */

      function tagName(code) {
        if (
          code === null ||
          code === 47 ||
          code === 62 ||
          markdownLineEndingOrSpace(code)
        ) {
          if (
            code !== 47 &&
            startTag &&
            htmlRawNames.includes(buffer.toLowerCase())
          ) {
            kind = 1;
            return self.interrupt ? ok(code) : continuation(code)
          }

          if (htmlBlockNames.includes(buffer.toLowerCase())) {
            kind = 6;

            if (code === 47) {
              effects.consume(code);
              return basicSelfClosing
            }

            return self.interrupt ? ok(code) : continuation(code)
          }

          kind = 7; // Do not support complete HTML when interrupting

          return self.interrupt && !self.parser.lazy[self.now().line]
            ? nok(code)
            : startTag
            ? completeAttributeNameBefore(code)
            : completeClosingTagAfter(code)
        }

        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          buffer += String.fromCharCode(code);
          return tagName
        }

        return nok(code)
      }
      /** @type {State} */

      function basicSelfClosing(code) {
        if (code === 62) {
          effects.consume(code);
          return self.interrupt ? ok : continuation
        }

        return nok(code)
      }
      /** @type {State} */

      function completeClosingTagAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeClosingTagAfter
        }

        return completeEnd(code)
      }
      /** @type {State} */

      function completeAttributeNameBefore(code) {
        if (code === 47) {
          effects.consume(code);
          return completeEnd
        }

        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return completeAttributeName
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameBefore
        }

        return completeEnd(code)
      }
      /** @type {State} */

      function completeAttributeName(code) {
        if (
          code === 45 ||
          code === 46 ||
          code === 58 ||
          code === 95 ||
          asciiAlphanumeric(code)
        ) {
          effects.consume(code);
          return completeAttributeName
        }

        return completeAttributeNameAfter(code)
      }
      /** @type {State} */

      function completeAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return completeAttributeValueBefore
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameAfter
        }

        return completeAttributeNameBefore(code)
      }
      /** @type {State} */

      function completeAttributeValueBefore(code) {
        if (
          code === null ||
          code === 60 ||
          code === 61 ||
          code === 62 ||
          code === 96
        ) {
          return nok(code)
        }

        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return completeAttributeValueQuoted
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeValueBefore
        }

        marker = null;
        return completeAttributeValueUnquoted(code)
      }
      /** @type {State} */

      function completeAttributeValueQuoted(code) {
        if (code === null || markdownLineEnding(code)) {
          return nok(code)
        }

        if (code === marker) {
          effects.consume(code);
          return completeAttributeValueQuotedAfter
        }

        effects.consume(code);
        return completeAttributeValueQuoted
      }
      /** @type {State} */

      function completeAttributeValueUnquoted(code) {
        if (
          code === null ||
          code === 34 ||
          code === 39 ||
          code === 60 ||
          code === 61 ||
          code === 62 ||
          code === 96 ||
          markdownLineEndingOrSpace(code)
        ) {
          return completeAttributeNameAfter(code)
        }

        effects.consume(code);
        return completeAttributeValueUnquoted
      }
      /** @type {State} */

      function completeAttributeValueQuotedAfter(code) {
        if (code === 47 || code === 62 || markdownSpace(code)) {
          return completeAttributeNameBefore(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function completeEnd(code) {
        if (code === 62) {
          effects.consume(code);
          return completeAfter
        }

        return nok(code)
      }
      /** @type {State} */

      function completeAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAfter
        }

        return code === null || markdownLineEnding(code)
          ? continuation(code)
          : nok(code)
      }
      /** @type {State} */

      function continuation(code) {
        if (code === 45 && kind === 2) {
          effects.consume(code);
          return continuationCommentInside
        }

        if (code === 60 && kind === 1) {
          effects.consume(code);
          return continuationRawTagOpen
        }

        if (code === 62 && kind === 4) {
          effects.consume(code);
          return continuationClose
        }

        if (code === 63 && kind === 3) {
          effects.consume(code);
          return continuationDeclarationInside
        }

        if (code === 93 && kind === 5) {
          effects.consume(code);
          return continuationCharacterDataInside
        }

        if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code)
        }

        if (code === null || markdownLineEnding(code)) {
          return continuationAtLineEnding(code)
        }

        effects.consume(code);
        return continuation
      }
      /** @type {State} */

      function continuationAtLineEnding(code) {
        effects.exit('htmlFlowData');
        return htmlContinueStart(code)
      }
      /** @type {State} */

      function htmlContinueStart(code) {
        if (code === null) {
          return done(code)
        }

        if (markdownLineEnding(code)) {
          return effects.attempt(
            {
              tokenize: htmlLineEnd,
              partial: true
            },
            htmlContinueStart,
            done
          )(code)
        }

        effects.enter('htmlFlowData');
        return continuation(code)
      }
      /** @type {Tokenizer} */

      function htmlLineEnd(effects, ok, nok) {
        return start
        /** @type {State} */

        function start(code) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return lineStart
        }
        /** @type {State} */

        function lineStart(code) {
          return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
        }
      }
      /** @type {State} */

      function continuationCommentInside(code) {
        if (code === 45) {
          effects.consume(code);
          return continuationDeclarationInside
        }

        return continuation(code)
      }
      /** @type {State} */

      function continuationRawTagOpen(code) {
        if (code === 47) {
          effects.consume(code);
          buffer = '';
          return continuationRawEndTag
        }

        return continuation(code)
      }
      /** @type {State} */

      function continuationRawEndTag(code) {
        if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
          effects.consume(code);
          return continuationClose
        }

        if (asciiAlpha(code) && buffer.length < 8) {
          effects.consume(code);
          buffer += String.fromCharCode(code);
          return continuationRawEndTag
        }

        return continuation(code)
      }
      /** @type {State} */

      function continuationCharacterDataInside(code) {
        if (code === 93) {
          effects.consume(code);
          return continuationDeclarationInside
        }

        return continuation(code)
      }
      /** @type {State} */

      function continuationDeclarationInside(code) {
        if (code === 62) {
          effects.consume(code);
          return continuationClose
        } // More dashes.

        if (code === 45 && kind === 2) {
          effects.consume(code);
          return continuationDeclarationInside
        }

        return continuation(code)
      }
      /** @type {State} */

      function continuationClose(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('htmlFlowData');
          return done(code)
        }

        effects.consume(code);
        return continuationClose
      }
      /** @type {State} */

      function done(code) {
        effects.exit('htmlFlow');
        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeNextBlank(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.exit('htmlFlowData');
        effects.enter('lineEndingBlank');
        effects.consume(code);
        effects.exit('lineEndingBlank');
        return effects.attempt(blankLine, ok, nok)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const htmlText = {
      name: 'htmlText',
      tokenize: tokenizeHtmlText
    };
    /** @type {Tokenizer} */

    function tokenizeHtmlText(effects, ok, nok) {
      const self = this;
      /** @type {NonNullable<Code>|undefined} */

      let marker;
      /** @type {string} */

      let buffer;
      /** @type {number} */

      let index;
      /** @type {State} */

      let returnState;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('htmlText');
        effects.enter('htmlTextData');
        effects.consume(code);
        return open
      }
      /** @type {State} */

      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationOpen
        }

        if (code === 47) {
          effects.consume(code);
          return tagCloseStart
        }

        if (code === 63) {
          effects.consume(code);
          return instruction
        }

        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagOpen
        }

        return nok(code)
      }
      /** @type {State} */

      function declarationOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentOpen
        }

        if (code === 91) {
          effects.consume(code);
          buffer = 'CDATA[';
          index = 0;
          return cdataOpen
        }

        if (asciiAlpha(code)) {
          effects.consume(code);
          return declaration
        }

        return nok(code)
      }
      /** @type {State} */

      function commentOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentStart
        }

        return nok(code)
      }
      /** @type {State} */

      function commentStart(code) {
        if (code === null || code === 62) {
          return nok(code)
        }

        if (code === 45) {
          effects.consume(code);
          return commentStartDash
        }

        return comment(code)
      }
      /** @type {State} */

      function commentStartDash(code) {
        if (code === null || code === 62) {
          return nok(code)
        }

        return comment(code)
      }
      /** @type {State} */

      function comment(code) {
        if (code === null) {
          return nok(code)
        }

        if (code === 45) {
          effects.consume(code);
          return commentClose
        }

        if (markdownLineEnding(code)) {
          returnState = comment;
          return atLineEnding(code)
        }

        effects.consume(code);
        return comment
      }
      /** @type {State} */

      function commentClose(code) {
        if (code === 45) {
          effects.consume(code);
          return end
        }

        return comment(code)
      }
      /** @type {State} */

      function cdataOpen(code) {
        if (code === buffer.charCodeAt(index++)) {
          effects.consume(code);
          return index === buffer.length ? cdata : cdataOpen
        }

        return nok(code)
      }
      /** @type {State} */

      function cdata(code) {
        if (code === null) {
          return nok(code)
        }

        if (code === 93) {
          effects.consume(code);
          return cdataClose
        }

        if (markdownLineEnding(code)) {
          returnState = cdata;
          return atLineEnding(code)
        }

        effects.consume(code);
        return cdata
      }
      /** @type {State} */

      function cdataClose(code) {
        if (code === 93) {
          effects.consume(code);
          return cdataEnd
        }

        return cdata(code)
      }
      /** @type {State} */

      function cdataEnd(code) {
        if (code === 62) {
          return end(code)
        }

        if (code === 93) {
          effects.consume(code);
          return cdataEnd
        }

        return cdata(code)
      }
      /** @type {State} */

      function declaration(code) {
        if (code === null || code === 62) {
          return end(code)
        }

        if (markdownLineEnding(code)) {
          returnState = declaration;
          return atLineEnding(code)
        }

        effects.consume(code);
        return declaration
      }
      /** @type {State} */

      function instruction(code) {
        if (code === null) {
          return nok(code)
        }

        if (code === 63) {
          effects.consume(code);
          return instructionClose
        }

        if (markdownLineEnding(code)) {
          returnState = instruction;
          return atLineEnding(code)
        }

        effects.consume(code);
        return instruction
      }
      /** @type {State} */

      function instructionClose(code) {
        return code === 62 ? end(code) : instruction(code)
      }
      /** @type {State} */

      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagClose
        }

        return nok(code)
      }
      /** @type {State} */

      function tagClose(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagClose
        }

        return tagCloseBetween(code)
      }
      /** @type {State} */

      function tagCloseBetween(code) {
        if (markdownLineEnding(code)) {
          returnState = tagCloseBetween;
          return atLineEnding(code)
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return tagCloseBetween
        }

        return end(code)
      }
      /** @type {State} */

      function tagOpen(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagOpen
        }

        if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function tagOpenBetween(code) {
        if (code === 47) {
          effects.consume(code);
          return end
        }

        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return tagOpenAttributeName
        }

        if (markdownLineEnding(code)) {
          returnState = tagOpenBetween;
          return atLineEnding(code)
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenBetween
        }

        return end(code)
      }
      /** @type {State} */

      function tagOpenAttributeName(code) {
        if (
          code === 45 ||
          code === 46 ||
          code === 58 ||
          code === 95 ||
          asciiAlphanumeric(code)
        ) {
          effects.consume(code);
          return tagOpenAttributeName
        }

        return tagOpenAttributeNameAfter(code)
      }
      /** @type {State} */

      function tagOpenAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return tagOpenAttributeValueBefore
        }

        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code)
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeNameAfter
        }

        return tagOpenBetween(code)
      }
      /** @type {State} */

      function tagOpenAttributeValueBefore(code) {
        if (
          code === null ||
          code === 60 ||
          code === 61 ||
          code === 62 ||
          code === 96
        ) {
          return nok(code)
        }

        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return tagOpenAttributeValueQuoted
        }

        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code)
        }

        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeValueBefore
        }

        effects.consume(code);
        marker = undefined;
        return tagOpenAttributeValueUnquoted
      }
      /** @type {State} */

      function tagOpenAttributeValueQuoted(code) {
        if (code === marker) {
          effects.consume(code);
          return tagOpenAttributeValueQuotedAfter
        }

        if (code === null) {
          return nok(code)
        }

        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code)
        }

        effects.consume(code);
        return tagOpenAttributeValueQuoted
      }
      /** @type {State} */

      function tagOpenAttributeValueQuotedAfter(code) {
        if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function tagOpenAttributeValueUnquoted(code) {
        if (
          code === null ||
          code === 34 ||
          code === 39 ||
          code === 60 ||
          code === 61 ||
          code === 96
        ) {
          return nok(code)
        }

        if (code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code)
        }

        effects.consume(code);
        return tagOpenAttributeValueUnquoted
      } // We cant have blank lines in content, so no need to worry about empty
      // tokens.

      /** @type {State} */

      function atLineEnding(code) {
        effects.exit('htmlTextData');
        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        return factorySpace(
          effects,
          afterPrefix,
          'linePrefix',
          self.parser.constructs.disable.null.includes('codeIndented')
            ? undefined
            : 4
        )
      }
      /** @type {State} */

      function afterPrefix(code) {
        effects.enter('htmlTextData');
        return returnState(code)
      }
      /** @type {State} */

      function end(code) {
        if (code === 62) {
          effects.consume(code);
          effects.exit('htmlTextData');
          effects.exit('htmlText');
          return ok
        }

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const labelEnd = {
      name: 'labelEnd',
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    /** @type {Construct} */

    const resourceConstruct = {
      tokenize: tokenizeResource
    };
    /** @type {Construct} */

    const fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    /** @type {Construct} */

    const collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    /** @type {Resolver} */

    function resolveAllLabelEnd(events) {
      let index = -1;
      /** @type {Token} */

      let token;

      while (++index < events.length) {
        token = events[index][1];

        if (
          token.type === 'labelImage' ||
          token.type === 'labelLink' ||
          token.type === 'labelEnd'
        ) {
          // Remove the marker.
          events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);
          token.type = 'data';
          index++;
        }
      }

      return events
    }
    /** @type {Resolver} */

    function resolveToLabelEnd(events, context) {
      let index = events.length;
      let offset = 0;
      /** @type {Token} */

      let token;
      /** @type {number|undefined} */

      let open;
      /** @type {number|undefined} */

      let close;
      /** @type {Event[]} */

      let media; // Find an opening.

      while (index--) {
        token = events[index][1];

        if (open) {
          // If we see another link, or inactive link label, weve been here before.
          if (
            token.type === 'link' ||
            (token.type === 'labelLink' && token._inactive)
          ) {
            break
          } // Mark other link openings as inactive, as we cant have links in
          // links.

          if (events[index][0] === 'enter' && token.type === 'labelLink') {
            token._inactive = true;
          }
        } else if (close) {
          if (
            events[index][0] === 'enter' &&
            (token.type === 'labelImage' || token.type === 'labelLink') &&
            !token._balanced
          ) {
            open = index;

            if (token.type !== 'labelLink') {
              offset = 2;
              break
            }
          }
        } else if (token.type === 'labelEnd') {
          close = index;
        }
      }

      const group = {
        type: events[open][1].type === 'labelLink' ? 'link' : 'image',
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      const label = {
        type: 'label',
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[close][1].end)
      };
      const text = {
        type: 'labelText',
        start: Object.assign({}, events[open + offset + 2][1].end),
        end: Object.assign({}, events[close - 2][1].start)
      };
      media = [
        ['enter', group, context],
        ['enter', label, context]
      ]; // Opening marker.

      media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.

      media = push(media, [['enter', text, context]]); // Between.

      media = push(
        media,
        resolveAll(
          context.parser.constructs.insideSpan.null,
          events.slice(open + offset + 4, close - 3),
          context
        )
      ); // Text close, marker close, label close.

      media = push(media, [
        ['exit', text, context],
        events[close - 2],
        events[close - 1],
        ['exit', label, context]
      ]); // Reference, resource, or so.

      media = push(media, events.slice(close + 1)); // Media close.

      media = push(media, [['exit', group, context]]);
      splice(events, open, events.length, media);
      return events
    }
    /** @type {Tokenizer} */

    function tokenizeLabelEnd(effects, ok, nok) {
      const self = this;
      let index = self.events.length;
      /** @type {Token} */

      let labelStart;
      /** @type {boolean} */

      let defined; // Find an opening.

      while (index--) {
        if (
          (self.events[index][1].type === 'labelImage' ||
            self.events[index][1].type === 'labelLink') &&
          !self.events[index][1]._balanced
        ) {
          labelStart = self.events[index][1];
          break
        }
      }

      return start
      /** @type {State} */

      function start(code) {
        if (!labelStart) {
          return nok(code)
        } // Its a balanced bracket, but contains a link.

        if (labelStart._inactive) return balanced(code)
        defined = self.parser.defined.includes(
          normalizeIdentifier(
            self.sliceSerialize({
              start: labelStart.end,
              end: self.now()
            })
          )
        );
        effects.enter('labelEnd');
        effects.enter('labelMarker');
        effects.consume(code);
        effects.exit('labelMarker');
        effects.exit('labelEnd');
        return afterLabelEnd
      }
      /** @type {State} */

      function afterLabelEnd(code) {
        // Resource: `[asd](fgh)`.
        if (code === 40) {
          return effects.attempt(
            resourceConstruct,
            ok,
            defined ? ok : balanced
          )(code)
        } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?

        if (code === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok,
            defined
              ? effects.attempt(collapsedReferenceConstruct, ok, balanced)
              : balanced
          )(code)
        } // Shortcut reference: `[asd]`?

        return defined ? ok(code) : balanced(code)
      }
      /** @type {State} */

      function balanced(code) {
        labelStart._balanced = true;
        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeResource(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('resource');
        effects.enter('resourceMarker');
        effects.consume(code);
        effects.exit('resourceMarker');
        return factoryWhitespace(effects, open)
      }
      /** @type {State} */

      function open(code) {
        if (code === 41) {
          return end(code)
        }

        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          'resourceDestination',
          'resourceDestinationLiteral',
          'resourceDestinationLiteralMarker',
          'resourceDestinationRaw',
          'resourceDestinationString',
          32
        )(code)
      }
      /** @type {State} */

      function destinationAfter(code) {
        return markdownLineEndingOrSpace(code)
          ? factoryWhitespace(effects, between)(code)
          : end(code)
      }
      /** @type {State} */

      function between(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end),
            nok,
            'resourceTitle',
            'resourceTitleMarker',
            'resourceTitleString'
          )(code)
        }

        return end(code)
      }
      /** @type {State} */

      function end(code) {
        if (code === 41) {
          effects.enter('resourceMarker');
          effects.consume(code);
          effects.exit('resourceMarker');
          effects.exit('resource');
          return ok
        }

        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeFullReference(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        return factoryLabel.call(
          self,
          effects,
          afterLabel,
          nok,
          'reference',
          'referenceMarker',
          'referenceString'
        )(code)
      }
      /** @type {State} */

      function afterLabel(code) {
        return self.parser.defined.includes(
          normalizeIdentifier(
            self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
          )
        )
          ? ok(code)
          : nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeCollapsedReference(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('reference');
        effects.enter('referenceMarker');
        effects.consume(code);
        effects.exit('referenceMarker');
        return open
      }
      /** @type {State} */

      function open(code) {
        if (code === 93) {
          effects.enter('referenceMarker');
          effects.consume(code);
          effects.exit('referenceMarker');
          effects.exit('reference');
          return ok
        }

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */
    /** @type {Construct} */

    const labelStartImage = {
      name: 'labelStartImage',
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    /** @type {Tokenizer} */

    function tokenizeLabelStartImage(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('labelImage');
        effects.enter('labelImageMarker');
        effects.consume(code);
        effects.exit('labelImageMarker');
        return open
      }
      /** @type {State} */

      function open(code) {
        if (code === 91) {
          effects.enter('labelMarker');
          effects.consume(code);
          effects.exit('labelMarker');
          effects.exit('labelImage');
          return after
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        /* To do: remove in the future once weve switched from
         * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
         * which doesnt need this */

        /* Hidden footnotes hook */

        /* c8 ignore next 3 */
        return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
          ? nok(code)
          : ok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */
    /** @type {Construct} */

    const labelStartLink = {
      name: 'labelStartLink',
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    /** @type {Tokenizer} */

    function tokenizeLabelStartLink(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('labelLink');
        effects.enter('labelMarker');
        effects.consume(code);
        effects.exit('labelMarker');
        effects.exit('labelLink');
        return after
      }
      /** @type {State} */

      function after(code) {
        /* To do: remove in the future once weve switched from
         * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
         * which doesnt need this */

        /* Hidden footnotes hook. */

        /* c8 ignore next 3 */
        return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
          ? nok(code)
          : ok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {Construct} */
    const lineEnding = {
      name: 'lineEnding',
      tokenize: tokenizeLineEnding
    };
    /** @type {Tokenizer} */

    function tokenizeLineEnding(effects, ok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        return factorySpace(effects, ok, 'linePrefix')
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const thematicBreak$1 = {
      name: 'thematicBreak',
      tokenize: tokenizeThematicBreak
    };
    /** @type {Tokenizer} */

    function tokenizeThematicBreak(effects, ok, nok) {
      let size = 0;
      /** @type {NonNullable<Code>} */

      let marker;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('thematicBreak');
        marker = code;
        return atBreak(code)
      }
      /** @type {State} */

      function atBreak(code) {
        if (code === marker) {
          effects.enter('thematicBreakSequence');
          return sequence(code)
        }

        if (markdownSpace(code)) {
          return factorySpace(effects, atBreak, 'whitespace')(code)
        }

        if (size < 3 || (code !== null && !markdownLineEnding(code))) {
          return nok(code)
        }

        effects.exit('thematicBreak');
        return ok(code)
      }
      /** @type {State} */

      function sequence(code) {
        if (code === marker) {
          effects.consume(code);
          size++;
          return sequence
        }

        effects.exit('thematicBreakSequence');
        return atBreak(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').Exiter} Exiter
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */
    /** @type {Construct} */

    const list$1 = {
      name: 'list',
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    /** @type {Construct} */

    const listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    /** @type {Construct} */

    const indentConstruct = {
      tokenize: tokenizeIndent$1,
      partial: true
    };
    /**
     * @type {Tokenizer}
     * @this {TokenizeContextWithState}
     */

    function tokenizeListStart(effects, ok, nok) {
      const self = this;
      const tail = self.events[self.events.length - 1];
      let initialSize =
        tail && tail[1].type === 'linePrefix'
          ? tail[2].sliceSerialize(tail[1], true).length
          : 0;
      let size = 0;
      return start
      /** @type {State} */

      function start(code) {
        const kind =
          self.containerState.type ||
          (code === 42 || code === 43 || code === 45
            ? 'listUnordered'
            : 'listOrdered');

        if (
          kind === 'listUnordered'
            ? !self.containerState.marker || code === self.containerState.marker
            : asciiDigit(code)
        ) {
          if (!self.containerState.type) {
            self.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }

          if (kind === 'listUnordered') {
            effects.enter('listItemPrefix');
            return code === 42 || code === 45
              ? effects.check(thematicBreak$1, nok, atMarker)(code)
              : atMarker(code)
          }

          if (!self.interrupt || code === 49) {
            effects.enter('listItemPrefix');
            effects.enter('listItemValue');
            return inside(code)
          }
        }

        return nok(code)
      }
      /** @type {State} */

      function inside(code) {
        if (asciiDigit(code) && ++size < 10) {
          effects.consume(code);
          return inside
        }

        if (
          (!self.interrupt || size < 2) &&
          (self.containerState.marker
            ? code === self.containerState.marker
            : code === 41 || code === 46)
        ) {
          effects.exit('listItemValue');
          return atMarker(code)
        }

        return nok(code)
      }
      /**
       * @type {State}
       **/

      function atMarker(code) {
        effects.enter('listItemMarker');
        effects.consume(code);
        effects.exit('listItemMarker');
        self.containerState.marker = self.containerState.marker || code;
        return effects.check(
          blankLine, // Cant be empty when interrupting.
          self.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        )
      }
      /** @type {State} */

      function onBlank(code) {
        self.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code)
      }
      /** @type {State} */

      function otherPrefix(code) {
        if (markdownSpace(code)) {
          effects.enter('listItemPrefixWhitespace');
          effects.consume(code);
          effects.exit('listItemPrefixWhitespace');
          return endOfPrefix
        }

        return nok(code)
      }
      /** @type {State} */

      function endOfPrefix(code) {
        self.containerState.size =
          initialSize +
          self.sliceSerialize(effects.exit('listItemPrefix'), true).length;
        return ok(code)
      }
    }
    /**
     * @type {Tokenizer}
     * @this {TokenizeContextWithState}
     */

    function tokenizeListContinuation(effects, ok, nok) {
      const self = this;
      self.containerState._closeFlow = undefined;
      return effects.check(blankLine, onBlank, notBlank)
      /** @type {State} */

      function onBlank(code) {
        self.containerState.furtherBlankLines =
          self.containerState.furtherBlankLines ||
          self.containerState.initialBlankLine; // We have a blank line.
        // Still, try to consume at most the items size.

        return factorySpace(
          effects,
          ok,
          'listItemIndent',
          self.containerState.size + 1
        )(code)
      }
      /** @type {State} */

      function notBlank(code) {
        if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
          self.containerState.furtherBlankLines = undefined;
          self.containerState.initialBlankLine = undefined;
          return notInCurrentItem(code)
        }

        self.containerState.furtherBlankLines = undefined;
        self.containerState.initialBlankLine = undefined;
        return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
      }
      /** @type {State} */

      function notInCurrentItem(code) {
        // While we do continue, we signal that the flow should be closed.
        self.containerState._closeFlow = true; // As were closing flow, were no longer interrupting.

        self.interrupt = undefined;
        return factorySpace(
          effects,
          effects.attempt(list$1, ok, nok),
          'linePrefix',
          self.parser.constructs.disable.null.includes('codeIndented')
            ? undefined
            : 4
        )(code)
      }
    }
    /**
     * @type {Tokenizer}
     * @this {TokenizeContextWithState}
     */

    function tokenizeIndent$1(effects, ok, nok) {
      const self = this;
      return factorySpace(
        effects,
        afterPrefix,
        'listItemIndent',
        self.containerState.size + 1
      )
      /** @type {State} */

      function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail &&
          tail[1].type === 'listItemIndent' &&
          tail[2].sliceSerialize(tail[1], true).length === self.containerState.size
          ? ok(code)
          : nok(code)
      }
    }
    /**
     * @type {Exiter}
     * @this {TokenizeContextWithState}
     */

    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    /**
     * @type {Tokenizer}
     * @this {TokenizeContextWithState}
     */

    function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
      const self = this;
      return factorySpace(
        effects,
        afterPrefix,
        'listItemPrefixWhitespace',
        self.parser.constructs.disable.null.includes('codeIndented')
          ? undefined
          : 4 + 1
      )
      /** @type {State} */

      function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return !markdownSpace(code) &&
          tail &&
          tail[1].type === 'listItemPrefixWhitespace'
          ? ok(code)
          : nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */

    /** @type {Construct} */
    const setextUnderline = {
      name: 'setextUnderline',
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    /** @type {Resolver} */

    function resolveToSetextUnderline(events, context) {
      let index = events.length;
      /** @type {number|undefined} */

      let content;
      /** @type {number|undefined} */

      let text;
      /** @type {number|undefined} */

      let definition; // Find the opening of the content.
      // Itll always exist: we dont tokenize if it isnt there.

      while (index--) {
        if (events[index][0] === 'enter') {
          if (events[index][1].type === 'content') {
            content = index;
            break
          }

          if (events[index][1].type === 'paragraph') {
            text = index;
          }
        } // Exit
        else {
          if (events[index][1].type === 'content') {
            // Remove the content end (if needed well add it later)
            events.splice(index, 1);
          }

          if (!definition && events[index][1].type === 'definition') {
            definition = index;
          }
        }
      }

      const heading = {
        type: 'setextHeading',
        start: Object.assign({}, events[text][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      }; // Change the paragraph to setext heading text.

      events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, well keep on having content,
      // but we need move it.

      if (definition) {
        events.splice(text, 0, ['enter', heading, context]);
        events.splice(definition + 1, 0, ['exit', events[content][1], context]);
        events[content][1].end = Object.assign({}, events[definition][1].end);
      } else {
        events[content][1] = heading;
      } // Add the heading exit at the end.

      events.push(['exit', heading, context]);
      return events
    }
    /** @type {Tokenizer} */

    function tokenizeSetextUnderline(effects, ok, nok) {
      const self = this;
      let index = self.events.length;
      /** @type {NonNullable<Code>} */

      let marker;
      /** @type {boolean} */

      let paragraph; // Find an opening.

      while (index--) {
        // Skip enter/exit of line ending, line prefix, and content.
        // We can now either have a definition or a paragraph.
        if (
          self.events[index][1].type !== 'lineEnding' &&
          self.events[index][1].type !== 'linePrefix' &&
          self.events[index][1].type !== 'content'
        ) {
          paragraph = self.events[index][1].type === 'paragraph';
          break
        }
      }

      return start
      /** @type {State} */

      function start(code) {
        if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
          effects.enter('setextHeadingLine');
          effects.enter('setextHeadingLineSequence');
          marker = code;
          return closingSequence(code)
        }

        return nok(code)
      }
      /** @type {State} */

      function closingSequence(code) {
        if (code === marker) {
          effects.consume(code);
          return closingSequence
        }

        effects.exit('setextHeadingLineSequence');
        return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)
      }
      /** @type {State} */

      function closingSequenceEnd(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit('setextHeadingLine');
          return ok(code)
        }

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').Initializer} Initializer
     * @typedef {import('micromark-util-types').State} State
     */

    /** @type {InitialConstruct} */
    const flow$1 = {
      tokenize: initializeFlow
    };
    /** @type {Initializer} */

    function initializeFlow(effects) {
      const self = this;
      const initial = effects.attempt(
        // Try to parse a blank line.
        blankLine,
        atBlankEnding, // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            'linePrefix'
          )
        )
      );
      return initial
      /** @type {State} */

      function atBlankEnding(code) {
        if (code === null) {
          effects.consume(code);
          return
        }

        effects.enter('lineEndingBlank');
        effects.consume(code);
        effects.exit('lineEndingBlank');
        self.currentConstruct = undefined;
        return initial
      }
      /** @type {State} */

      function afterConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return
        }

        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        self.currentConstruct = undefined;
        return initial
      }
    }

    /**
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Initializer} Initializer
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Code} Code
     */
    const resolver = {
      resolveAll: createResolver()
    };
    const string$1 = initializeFactory('string');
    const text$3 = initializeFactory('text');
    /**
     * @param {'string'|'text'} field
     * @returns {InitialConstruct}
     */

    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === 'text' ? resolveAllLineSuffixes : undefined
        )
      }
      /** @type {Initializer} */

      function initializeText(effects) {
        const self = this;
        const constructs = this.parser.constructs[field];
        const text = effects.attempt(constructs, start, notText);
        return start
        /** @type {State} */

        function start(code) {
          return atBreak(code) ? text(code) : notText(code)
        }
        /** @type {State} */

        function notText(code) {
          if (code === null) {
            effects.consume(code);
            return
          }

          effects.enter('data');
          effects.consume(code);
          return data
        }
        /** @type {State} */

        function data(code) {
          if (atBreak(code)) {
            effects.exit('data');
            return text(code)
          } // Data.

          effects.consume(code);
          return data
        }
        /**
         * @param {Code} code
         * @returns {boolean}
         */

        function atBreak(code) {
          if (code === null) {
            return true
          }

          const list = constructs[code];
          let index = -1;

          if (list) {
            while (++index < list.length) {
              const item = list[index];

              if (!item.previous || item.previous.call(self, self.previous)) {
                return true
              }
            }
          }

          return false
        }
      }
    }
    /**
     * @param {Resolver} [extraResolver]
     * @returns {Resolver}
     */

    function createResolver(extraResolver) {
      return resolveAllText
      /** @type {Resolver} */

      function resolveAllText(events, context) {
        let index = -1;
        /** @type {number|undefined} */

        let enter; // A rather boring computation (to merge adjacent `data` events) which
        // improves mm performance by 29%.

        while (++index <= events.length) {
          if (enter === undefined) {
            if (events[index] && events[index][1].type === 'data') {
              enter = index;
              index++;
            }
          } else if (!events[index] || events[index][1].type !== 'data') {
            // Dont do anything if there is one data token.
            if (index !== enter + 2) {
              events[enter][1].end = events[index - 1][1].end;
              events.splice(enter + 2, index - enter - 2);
              index = enter + 2;
            }

            enter = undefined;
          }
        }

        return extraResolver ? extraResolver(events, context) : events
      }
    }
    /**
     * A rather ugly set of instructions which again looks at chunks in the input
     * stream.
     * The reason to do this here is that it is *much* faster to parse in reverse.
     * And that we cant hook into `null` to split the line suffix before an EOF.
     * To do: figure out if we can make this into a clean utility, or even in core.
     * As it will be useful for GFMs literal autolink extension (and maybe even
     * tables?)
     *
     * @type {Resolver}
     */

    function resolveAllLineSuffixes(events, context) {
      let eventIndex = 0; // Skip first.

      while (++eventIndex <= events.length) {
        if (
          (eventIndex === events.length ||
            events[eventIndex][1].type === 'lineEnding') &&
          events[eventIndex - 1][1].type === 'data'
        ) {
          const data = events[eventIndex - 1][1];
          const chunks = context.sliceStream(data);
          let index = chunks.length;
          let bufferIndex = -1;
          let size = 0;
          /** @type {boolean|undefined} */

          let tabs;

          while (index--) {
            const chunk = chunks[index];

            if (typeof chunk === 'string') {
              bufferIndex = chunk.length;

              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size++;
                bufferIndex--;
              }

              if (bufferIndex) break
              bufferIndex = -1;
            } // Number
            else if (chunk === -2) {
              tabs = true;
              size++;
            } else if (chunk === -1) ; else {
              // Replacement character, exit.
              index++;
              break
            }
          }

          if (size) {
            const token = {
              type:
                eventIndex === events.length || tabs || size < 2
                  ? 'lineSuffix'
                  : 'hardBreakTrailing',
              start: {
                line: data.end.line,
                column: data.end.column - size,
                offset: data.end.offset - size,
                _index: data.start._index + index,
                _bufferIndex: index
                  ? bufferIndex
                  : data.start._bufferIndex + bufferIndex
              },
              end: Object.assign({}, data.end)
            };
            data.end = Object.assign({}, token.start);

            if (data.start.offset === data.end.offset) {
              Object.assign(data, token);
            } else {
              events.splice(
                eventIndex,
                0,
                ['enter', token, context],
                ['exit', token, context]
              );
              eventIndex += 2;
            }
          }

          eventIndex++;
        }
      }

      return events
    }

    /**
     * @typedef {import('micromark-util-types').Code} Code
     * @typedef {import('micromark-util-types').Chunk} Chunk
     * @typedef {import('micromark-util-types').Point} Point
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').Effects} Effects
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Construct} Construct
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').ParseContext} ParseContext
     */

    /**
     * Create a tokenizer.
     * Tokenizers deal with one type of data (e.g., containers, flow, text).
     * The parser is the object dealing with it all.
     * `initialize` works like other constructs, except that only its `tokenize`
     * function is used, in which case it doesnt receive an `ok` or `nok`.
     * `from` can be given to set the point before the first character, although
     * when further lines are indented, they must be set with `defineSkip`.
     *
     * @param {ParseContext} parser
     * @param {InitialConstruct} initialize
     * @param {Omit<Point, '_index'|'_bufferIndex'>} [from]
     * @returns {TokenizeContext}
     */
    function createTokenizer(parser, initialize, from) {
      /** @type {Point} */
      let point = Object.assign(
        from
          ? Object.assign({}, from)
          : {
              line: 1,
              column: 1,
              offset: 0
            },
        {
          _index: 0,
          _bufferIndex: -1
        }
      );
      /** @type {Record<string, number>} */

      const columnStart = {};
      /** @type {Array<Construct>} */

      const resolveAllConstructs = [];
      /** @type {Array<Chunk>} */

      let chunks = [];
      /** @type {Array<Token>} */

      let stack = [];
      /**
       * Tools used for tokenizing.
       *
       * @type {Effects}
       */

      const effects = {
        consume,
        enter,
        exit,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        })
      };
      /**
       * State and tools for resolving and serializing.
       *
       * @type {TokenizeContext}
       */

      const context = {
        previous: null,
        code: null,
        containerState: {},
        events: [],
        parser,
        sliceStream,
        sliceSerialize,
        now,
        defineSkip,
        write
      };
      /**
       * The state function.
       *
       * @type {State|void}
       */

      let state = initialize.tokenize.call(context, effects);

      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }

      return context
      /** @type {TokenizeContext['write']} */

      function write(slice) {
        chunks = push(chunks, slice);
        main(); // Exit if were not done, resolve might change stuff.

        if (chunks[chunks.length - 1] !== null) {
          return []
        }

        addResult(initialize, 0); // Otherwise, resolve, and exit.

        context.events = resolveAll(resolveAllConstructs, context.events, context);
        return context.events
      } //
      // Tools.
      //

      /** @type {TokenizeContext['sliceSerialize']} */

      function sliceSerialize(token, expandTabs) {
        return serializeChunks(sliceStream(token), expandTabs)
      }
      /** @type {TokenizeContext['sliceStream']} */

      function sliceStream(token) {
        return sliceChunks(chunks, token)
      }
      /** @type {TokenizeContext['now']} */

      function now() {
        return Object.assign({}, point)
      }
      /** @type {TokenizeContext['defineSkip']} */

      function defineSkip(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      } //
      // State management.
      //

      /**
       * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
       * `consume`).
       * Here is where we walk through the chunks, which either include strings of
       * several characters, or numerical character codes.
       * The reason to do this in a loop instead of a call is so the stack can
       * drain.
       *
       * @returns {void}
       */

      function main() {
        /** @type {number} */
        let chunkIndex;

        while (point._index < chunks.length) {
          const chunk = chunks[point._index]; // If were in a buffer chunk, loop through it.

          if (typeof chunk === 'string') {
            chunkIndex = point._index;

            if (point._bufferIndex < 0) {
              point._bufferIndex = 0;
            }

            while (
              point._index === chunkIndex &&
              point._bufferIndex < chunk.length
            ) {
              go(chunk.charCodeAt(point._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      /**
       * Deal with one code.
       *
       * @param {Code} code
       * @returns {void}
       */

      function go(code) {
        state = state(code);
      }
      /** @type {Effects['consume']} */

      function consume(code) {
        if (markdownLineEnding(code)) {
          point.line++;
          point.column = 1;
          point.offset += code === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code !== -1) {
          point.column++;
          point.offset++;
        } // Not in a string chunk.

        if (point._bufferIndex < 0) {
          point._index++;
        } else {
          point._bufferIndex++; // At end of string chunk.
          // @ts-expect-error Points w/ non-negative `_bufferIndex` reference
          // strings.

          if (point._bufferIndex === chunks[point._index].length) {
            point._bufferIndex = -1;
            point._index++;
          }
        } // Expose the previous character.

        context.previous = code; // Mark as consumed.
      }
      /** @type {Effects['enter']} */

      function enter(type, fields) {
        /** @type {Token} */
        // @ts-expect-error Patch instead of assign required fields to help GC.
        const token = fields || {};
        token.type = type;
        token.start = now();
        context.events.push(['enter', token, context]);
        stack.push(token);
        return token
      }
      /** @type {Effects['exit']} */

      function exit(type) {
        const token = stack.pop();
        token.end = now();
        context.events.push(['exit', token, context]);
        return token
      }
      /**
       * Use results.
       *
       * @type {ReturnHandle}
       */

      function onsuccessfulconstruct(construct, info) {
        addResult(construct, info.from);
      }
      /**
       * Discard results.
       *
       * @type {ReturnHandle}
       */

      function onsuccessfulcheck(_, info) {
        info.restore();
      }
      /**
       * Factory to attempt/check/interrupt.
       *
       * @param {ReturnHandle} onreturn
       * @param {Record<string, unknown>} [fields]
       */

      function constructFactory(onreturn, fields) {
        return hook
        /**
         * Handle either an object mapping codes to constructs, a list of
         * constructs, or a single construct.
         *
         * @param {Construct|Array<Construct>|ConstructRecord} constructs
         * @param {State} returnState
         * @param {State} [bogusState]
         * @returns {State}
         */

        function hook(constructs, returnState, bogusState) {
          /** @type {Array<Construct>} */
          let listOfConstructs;
          /** @type {number} */

          let constructIndex;
          /** @type {Construct} */

          let currentConstruct;
          /** @type {Info} */

          let info;
          return Array.isArray(constructs)
            ? /* c8 ignore next 1 */
              handleListOfConstructs(constructs)
            : 'tokenize' in constructs // @ts-expect-error Looks like a construct.
            ? handleListOfConstructs([constructs])
            : handleMapOfConstructs(constructs)
          /**
           * Handle a list of construct.
           *
           * @param {ConstructRecord} map
           * @returns {State}
           */

          function handleMapOfConstructs(map) {
            return start
            /** @type {State} */

            function start(code) {
              const def = code !== null && map[code];
              const all = code !== null && map.null;
              const list = [
                // To do: add more extension tests.

                /* c8 ignore next 2 */
                ...(Array.isArray(def) ? def : def ? [def] : []),
                ...(Array.isArray(all) ? all : all ? [all] : [])
              ];
              return handleListOfConstructs(list)(code)
            }
          }
          /**
           * Handle a list of construct.
           *
           * @param {Array<Construct>} list
           * @returns {State}
           */

          function handleListOfConstructs(list) {
            listOfConstructs = list;
            constructIndex = 0;

            if (list.length === 0) {
              return bogusState
            }

            return handleConstruct(list[constructIndex])
          }
          /**
           * Handle a single construct.
           *
           * @param {Construct} construct
           * @returns {State}
           */

          function handleConstruct(construct) {
            return start
            /** @type {State} */

            function start(code) {
              // To do: not needed to store if there is no bogus state, probably?
              // Currently doesnt work because `inspect` in document does a check
              // w/o a bogus, which doesnt make sense. But it does seem to help perf
              // by not storing.
              info = store();
              currentConstruct = construct;

              if (!construct.partial) {
                context.currentConstruct = construct;
              }

              if (
                construct.name &&
                context.parser.constructs.disable.null.includes(construct.name)
              ) {
                return nok()
              }

              return construct.tokenize.call(
                // If we do have fields, create an object w/ `context` as its
                // prototype.
                // This allows a live binding, which is needed for `interrupt`.
                fields ? Object.assign(Object.create(context), fields) : context,
                effects,
                ok,
                nok
              )(code)
            }
          }
          /** @type {State} */

          function ok(code) {
            onreturn(currentConstruct, info);
            return returnState
          }
          /** @type {State} */

          function nok(code) {
            info.restore();

            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex])
            }

            return bogusState
          }
        }
      }
      /**
       * @param {Construct} construct
       * @param {number} from
       * @returns {void}
       */

      function addResult(construct, from) {
        if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
          resolveAllConstructs.push(construct);
        }

        if (construct.resolve) {
          splice(
            context.events,
            from,
            context.events.length - from,
            construct.resolve(context.events.slice(from), context)
          );
        }

        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      /**
       * Store state.
       *
       * @returns {Info}
       */

      function store() {
        const startPoint = now();
        const startPrevious = context.previous;
        const startCurrentConstruct = context.currentConstruct;
        const startEventsIndex = context.events.length;
        const startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        }
        /**
         * Restore state.
         *
         * @returns {void}
         */

        function restore() {
          point = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      /**
       * Move the current point a bit forward in the line when its on a column
       * skip.
       *
       * @returns {void}
       */

      function accountForPotentialSkip() {
        if (point.line in columnStart && point.column < 2) {
          point.column = columnStart[point.line];
          point.offset += columnStart[point.line] - 1;
        }
      }
    }
    /**
     * Get the chunks from a slice of chunks in the range of a token.
     *
     * @param {Array<Chunk>} chunks
     * @param {Pick<Token, 'start'|'end'>} token
     * @returns {Array<Chunk>}
     */

    function sliceChunks(chunks, token) {
      const startIndex = token.start._index;
      const startBufferIndex = token.start._bufferIndex;
      const endIndex = token.end._index;
      const endBufferIndex = token.end._bufferIndex;
      /** @type {Array<Chunk>} */

      let view;

      if (startIndex === endIndex) {
        // @ts-expect-error `_bufferIndex` is used on string chunks.
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);

        if (startBufferIndex > -1) {
          // @ts-expect-error `_bufferIndex` is used on string chunks.
          view[0] = view[0].slice(startBufferIndex);
        }

        if (endBufferIndex > 0) {
          // @ts-expect-error `_bufferIndex` is used on string chunks.
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }

      return view
    }
    /**
     * Get the string value of a slice of chunks.
     *
     * @param {Array<Chunk>} chunks
     * @param {boolean} [expandTabs=false]
     * @returns {string}
     */

    function serializeChunks(chunks, expandTabs) {
      let index = -1;
      /** @type {Array<string>} */

      const result = [];
      /** @type {boolean|undefined} */

      let atTab;

      while (++index < chunks.length) {
        const chunk = chunks[index];
        /** @type {string} */

        let value;

        if (typeof chunk === 'string') {
          value = chunk;
        } else
          switch (chunk) {
            case -5: {
              value = '\r';
              break
            }

            case -4: {
              value = '\n';
              break
            }

            case -3: {
              value = '\r' + '\n';
              break
            }

            case -2: {
              value = expandTabs ? ' ' : '\t';
              break
            }

            case -1: {
              if (!expandTabs && atTab) continue
              value = ' ';
              break
            }

            default: {
              // Currently only replacement character.
              value = String.fromCharCode(chunk);
            }
          }

        atTab = chunk === -2;
        result.push(value);
      }

      return result.join('')
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     */
    /** @type {Extension['document']} */

    const document$1 = {
      [42]: list$1,
      [43]: list$1,
      [45]: list$1,
      [48]: list$1,
      [49]: list$1,
      [50]: list$1,
      [51]: list$1,
      [52]: list$1,
      [53]: list$1,
      [54]: list$1,
      [55]: list$1,
      [56]: list$1,
      [57]: list$1,
      [62]: blockQuote
    };
    /** @type {Extension['contentInitial']} */

    const contentInitial = {
      [91]: definition
    };
    /** @type {Extension['flowInitial']} */

    const flowInitial = {
      [-2]: codeIndented,
      [-1]: codeIndented,
      [32]: codeIndented
    };
    /** @type {Extension['flow']} */

    const flow = {
      [35]: headingAtx,
      [42]: thematicBreak$1,
      [45]: [setextUnderline, thematicBreak$1],
      [60]: htmlFlow,
      [61]: setextUnderline,
      [95]: thematicBreak$1,
      [96]: codeFenced,
      [126]: codeFenced
    };
    /** @type {Extension['string']} */

    const string = {
      [38]: characterReference,
      [92]: characterEscape
    };
    /** @type {Extension['text']} */

    const text$2 = {
      [-5]: lineEnding,
      [-4]: lineEnding,
      [-3]: lineEnding,
      [33]: labelStartImage,
      [38]: characterReference,
      [42]: attention,
      [60]: [autolink, htmlText],
      [91]: labelStartLink,
      [92]: [hardBreakEscape, characterEscape],
      [93]: labelEnd,
      [95]: attention,
      [96]: codeText
    };
    /** @type {Extension['insideSpan']} */

    const insideSpan = {
      null: [attention, resolver]
    };
    /** @type {Extension['attentionMarkers']} */

    const attentionMarkers = {
      null: [42, 95]
    };
    /** @type {Extension['disable']} */

    const disable = {
      null: []
    };

    var defaultConstructs = /*#__PURE__*/Object.freeze({
        __proto__: null,
        document: document$1,
        contentInitial: contentInitial,
        flowInitial: flowInitial,
        flow: flow,
        string: string,
        text: text$2,
        insideSpan: insideSpan,
        attentionMarkers: attentionMarkers,
        disable: disable
    });

    /**
     * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
     * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension
     * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
     * @typedef {import('micromark-util-types').ParseContext} ParseContext
     * @typedef {import('micromark-util-types').Create} Create
     */
    /**
     * @param {ParseOptions} [options]
     * @returns {ParseContext}
     */

    function parse$1(options = {}) {
      /** @type {FullNormalizedExtension} */
      // @ts-expect-error `defaultConstructs` is full, so the result will be too.
      const constructs = combineExtensions(
        // @ts-expect-error Same as above.
        [defaultConstructs].concat(options.extensions || [])
      );
      /** @type {ParseContext} */

      const parser = {
        defined: [],
        lazy: {},
        constructs,
        content: create(content$1),
        document: create(document$2),
        flow: create(flow$1),
        string: create(string$1),
        text: create(text$3)
      };
      return parser
      /**
       * @param {InitialConstruct} initial
       */

      function create(initial) {
        return creator
        /** @type {Create} */

        function creator(from) {
          return createTokenizer(parser, initial, from)
        }
      }
    }

    /**
     * @typedef {import('micromark-util-types').Encoding} Encoding
     * @typedef {import('micromark-util-types').Value} Value
     * @typedef {import('micromark-util-types').Chunk} Chunk
     * @typedef {import('micromark-util-types').Code} Code
     */

    /**
     * @callback Preprocessor
     * @param {Value} value
     * @param {Encoding} [encoding]
     * @param {boolean} [end=false]
     * @returns {Array<Chunk>}
     */
    const search = /[\0\t\n\r]/g;
    /**
     * @returns {Preprocessor}
     */

    function preprocess() {
      let column = 1;
      let buffer = '';
      /** @type {boolean|undefined} */

      let start = true;
      /** @type {boolean|undefined} */

      let atCarriageReturn;
      return preprocessor
      /** @type {Preprocessor} */

      function preprocessor(value, encoding, end) {
        /** @type {Array<Chunk>} */
        const chunks = [];
        /** @type {RegExpMatchArray|null} */

        let match;
        /** @type {number} */

        let next;
        /** @type {number} */

        let startPosition;
        /** @type {number} */

        let endPosition;
        /** @type {Code} */

        let code; // @ts-expect-error `Buffer` does allow an encoding.

        value = buffer + value.toString(encoding);
        startPosition = 0;
        buffer = '';

        if (start) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }

          start = undefined;
        }

        while (startPosition < value.length) {
          search.lastIndex = startPosition;
          match = search.exec(value);
          endPosition =
            match && match.index !== undefined ? match.index : value.length;
          code = value.charCodeAt(endPosition);

          if (!match) {
            buffer = value.slice(startPosition);
            break
          }

          if (code === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = undefined;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = undefined;
            }

            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column += endPosition - startPosition;
            }

            switch (code) {
              case 0: {
                chunks.push(65533);
                column++;
                break
              }

              case 9: {
                next = Math.ceil(column / 4) * 4;
                chunks.push(-2);

                while (column++ < next) chunks.push(-1);

                break
              }

              case 10: {
                chunks.push(-4);
                column = 1;
                break
              }

              default: {
                atCarriageReturn = true;
                column = 1;
              }
            }
          }

          startPosition = endPosition + 1;
        }

        if (end) {
          if (atCarriageReturn) chunks.push(-5);
          if (buffer) chunks.push(buffer);
          chunks.push(null);
        }

        return chunks
      }
    }

    /**
     * @typedef {import('micromark-util-types').Event} Event
     */
    /**
     * @param {Array<Event>} events
     * @returns {Array<Event>}
     */

    function postprocess(events) {
      while (!subtokenize(events)) {
        // Empty
      }

      return events
    }

    /**
     * Turn the number (in string form as either hexa- or plain decimal) coming from
     * a numeric character reference into a character.
     *
     * @param {string} value
     *   Value to decode.
     * @param {number} base
     *   Numeric base.
     * @returns {string}
     */
    function decodeNumericCharacterReference(value, base) {
      const code = Number.parseInt(value, base);

      if (
        // C0 except for HT, LF, FF, CR, space
        code < 9 ||
        code === 11 ||
        (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.
        (code > 126 && code < 160) || // Lone high surrogates and low surrogates.
        (code > 55295 && code < 57344) || // Noncharacters.
        (code > 64975 && code < 65008) ||
        (code & 65535) === 65535 ||
        (code & 65535) === 65534 || // Out of range
        code > 1114111
      ) {
        return '\uFFFD'
      }

      return String.fromCharCode(code)
    }

    const characterEscapeOrReference =
      /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    /**
     * Utility to decode markdown strings (which occur in places such as fenced
     * code info strings, destinations, labels, and titles).
     * The string content type allows character escapes and -references.
     * This decodes those.
     *
     * @param {string} value
     * @returns {string}
     */

    function decodeString(value) {
      return value.replace(characterEscapeOrReference, decode)
    }
    /**
     * @param {string} $0
     * @param {string} $1
     * @param {string} $2
     * @returns {string}
     */

    function decode($0, $1, $2) {
      if ($1) {
        // Escape.
        return $1
      } // Reference.

      const head = $2.charCodeAt(0);

      if (head === 35) {
        const head = $2.charCodeAt(1);
        const hex = head === 120 || head === 88;
        return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)
      }

      return decodeNamedCharacterReference($2) || $0
    }

    /**
     * @typedef {import('micromark-util-types').Encoding} Encoding
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
     * @typedef {import('micromark-util-types').Value} Value
     *
     * @typedef {import('unist').Parent} UnistParent
     * @typedef {import('unist').Point} Point
     *
     * @typedef {import('mdast').PhrasingContent} PhrasingContent
     * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').Break} Break
     * @typedef {import('mdast').Blockquote} Blockquote
     * @typedef {import('mdast').Code} Code
     * @typedef {import('mdast').Definition} Definition
     * @typedef {import('mdast').Emphasis} Emphasis
     * @typedef {import('mdast').Heading} Heading
     * @typedef {import('mdast').HTML} HTML
     * @typedef {import('mdast').Image} Image
     * @typedef {import('mdast').ImageReference} ImageReference
     * @typedef {import('mdast').InlineCode} InlineCode
     * @typedef {import('mdast').Link} Link
     * @typedef {import('mdast').LinkReference} LinkReference
     * @typedef {import('mdast').List} List
     * @typedef {import('mdast').ListItem} ListItem
     * @typedef {import('mdast').Paragraph} Paragraph
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast').Strong} Strong
     * @typedef {import('mdast').Text} Text
     * @typedef {import('mdast').ThematicBreak} ThematicBreak
     * @typedef {import('mdast').ReferenceType} ReferenceType
     * @typedef {import('../index.js').CompileData} CompileData
     */
    const own$6 = {}.hasOwnProperty;

    /**
     * @param value
     *   Markdown to parse.
     * @param encoding
     *   Character encoding for when `value` is `Buffer`.
     * @param options
     *   Configuration.
     * @returns
     *   mdast tree.
     */
    const fromMarkdown =
      /**
       * @type {(
       *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
       *   ((value: Value, options?: Options | null | undefined) => Root)
       * )}
       */

      /**
       * @param {Value} value
       * @param {Encoding | Options | null | undefined} [encoding]
       * @param {Options | null | undefined} [options]
       * @returns {Root}
       */
      function (value, encoding, options) {
        if (typeof encoding !== 'string') {
          options = encoding;
          encoding = undefined;
        }
        return compiler(options)(
          postprocess(
            // @ts-expect-error: micromark types need to accept `null`.
            parse$1(options).document().write(preprocess()(value, encoding, true))
          )
        )
      };

    /**
     * Note this compiler only understand complete buffering, not streaming.
     *
     * @param {Options | null | undefined} [options]
     */
    function compiler(options) {
      /** @type {Config} */
      const config = {
        transforms: [],
        canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],
        enter: {
          autolink: opener(link),
          autolinkProtocol: onenterdata,
          autolinkEmail: onenterdata,
          atxHeading: opener(heading),
          blockQuote: opener(blockQuote),
          characterEscape: onenterdata,
          characterReference: onenterdata,
          codeFenced: opener(codeFlow),
          codeFencedFenceInfo: buffer,
          codeFencedFenceMeta: buffer,
          codeIndented: opener(codeFlow, buffer),
          codeText: opener(codeText, buffer),
          codeTextData: onenterdata,
          data: onenterdata,
          codeFlowValue: onenterdata,
          definition: opener(definition),
          definitionDestinationString: buffer,
          definitionLabelString: buffer,
          definitionTitleString: buffer,
          emphasis: opener(emphasis),
          hardBreakEscape: opener(hardBreak),
          hardBreakTrailing: opener(hardBreak),
          htmlFlow: opener(html, buffer),
          htmlFlowData: onenterdata,
          htmlText: opener(html, buffer),
          htmlTextData: onenterdata,
          image: opener(image),
          label: buffer,
          link: opener(link),
          listItem: opener(listItem),
          listItemValue: onenterlistitemvalue,
          listOrdered: opener(list, onenterlistordered),
          listUnordered: opener(list),
          paragraph: opener(paragraph),
          reference: onenterreference,
          referenceString: buffer,
          resourceDestinationString: buffer,
          resourceTitleString: buffer,
          setextHeading: opener(heading),
          strong: opener(strong),
          thematicBreak: opener(thematicBreak)
        },
        exit: {
          atxHeading: closer(),
          atxHeadingSequence: onexitatxheadingsequence,
          autolink: closer(),
          autolinkEmail: onexitautolinkemail,
          autolinkProtocol: onexitautolinkprotocol,
          blockQuote: closer(),
          characterEscapeValue: onexitdata,
          characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
          characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
          characterReferenceValue: onexitcharacterreferencevalue,
          codeFenced: closer(onexitcodefenced),
          codeFencedFence: onexitcodefencedfence,
          codeFencedFenceInfo: onexitcodefencedfenceinfo,
          codeFencedFenceMeta: onexitcodefencedfencemeta,
          codeFlowValue: onexitdata,
          codeIndented: closer(onexitcodeindented),
          codeText: closer(onexitcodetext),
          codeTextData: onexitdata,
          data: onexitdata,
          definition: closer(),
          definitionDestinationString: onexitdefinitiondestinationstring,
          definitionLabelString: onexitdefinitionlabelstring,
          definitionTitleString: onexitdefinitiontitlestring,
          emphasis: closer(),
          hardBreakEscape: closer(onexithardbreak),
          hardBreakTrailing: closer(onexithardbreak),
          htmlFlow: closer(onexithtmlflow),
          htmlFlowData: onexitdata,
          htmlText: closer(onexithtmltext),
          htmlTextData: onexitdata,
          image: closer(onexitimage),
          label: onexitlabel,
          labelText: onexitlabeltext,
          lineEnding: onexitlineending,
          link: closer(onexitlink),
          listItem: closer(),
          listOrdered: closer(),
          listUnordered: closer(),
          paragraph: closer(),
          referenceString: onexitreferencestring,
          resourceDestinationString: onexitresourcedestinationstring,
          resourceTitleString: onexitresourcetitlestring,
          resource: onexitresource,
          setextHeading: closer(onexitsetextheading),
          setextHeadingLineSequence: onexitsetextheadinglinesequence,
          setextHeadingText: onexitsetextheadingtext,
          strong: closer(),
          thematicBreak: closer()
        }
      };
      configure(config, (options || {}).mdastExtensions || []);

      /** @type {CompileData} */
      const data = {};
      return compile

      /**
       * Turn micromark events into an mdast tree.
       *
       * @param {Array<Event>} events
       *   Events.
       * @returns {Root}
       *   mdast tree.
       */
      function compile(events) {
        /** @type {Root} */
        let tree = {
          type: 'root',
          children: []
        };
        /** @type {Omit<CompileContext, 'sliceSerialize'>} */
        const context = {
          stack: [tree],
          tokenStack: [],
          config,
          enter,
          exit,
          buffer,
          resume,
          setData,
          getData
        };
        /** @type {Array<number>} */
        const listStack = [];
        let index = -1;
        while (++index < events.length) {
          // We preprocess lists to add `listItem` tokens, and to infer whether
          // items the list itself are spread out.
          if (
            events[index][1].type === 'listOrdered' ||
            events[index][1].type === 'listUnordered'
          ) {
            if (events[index][0] === 'enter') {
              listStack.push(index);
            } else {
              const tail = listStack.pop();
              index = prepareList(events, tail, index);
            }
          }
        }
        index = -1;
        while (++index < events.length) {
          const handler = config[events[index][0]];
          if (own$6.call(handler, events[index][1].type)) {
            handler[events[index][1].type].call(
              Object.assign(
                {
                  sliceSerialize: events[index][2].sliceSerialize
                },
                context
              ),
              events[index][1]
            );
          }
        }

        // Handle tokens still being open.
        if (context.tokenStack.length > 0) {
          const tail = context.tokenStack[context.tokenStack.length - 1];
          const handler = tail[1] || defaultOnError;
          handler.call(context, undefined, tail[0]);
        }

        // Figure out `root` position.
        tree.position = {
          start: point$1(
            events.length > 0
              ? events[0][1].start
              : {
                  line: 1,
                  column: 1,
                  offset: 0
                }
          ),
          end: point$1(
            events.length > 0
              ? events[events.length - 2][1].end
              : {
                  line: 1,
                  column: 1,
                  offset: 0
                }
          )
        };

        // Call transforms.
        index = -1;
        while (++index < config.transforms.length) {
          tree = config.transforms[index](tree) || tree;
        }
        return tree
      }

      /**
       * @param {Array<Event>} events
       * @param {number} start
       * @param {number} length
       * @returns {number}
       */
      function prepareList(events, start, length) {
        let index = start - 1;
        let containerBalance = -1;
        let listSpread = false;
        /** @type {Token | undefined} */
        let listItem;
        /** @type {number | undefined} */
        let lineIndex;
        /** @type {number | undefined} */
        let firstBlankLineIndex;
        /** @type {boolean | undefined} */
        let atMarker;
        while (++index <= length) {
          const event = events[index];
          if (
            event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered' ||
            event[1].type === 'blockQuote'
          ) {
            if (event[0] === 'enter') {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = undefined;
          } else if (event[1].type === 'lineEndingBlank') {
            if (event[0] === 'enter') {
              if (
                listItem &&
                !atMarker &&
                !containerBalance &&
                !firstBlankLineIndex
              ) {
                firstBlankLineIndex = index;
              }
              atMarker = undefined;
            }
          } else if (
            event[1].type === 'linePrefix' ||
            event[1].type === 'listItemValue' ||
            event[1].type === 'listItemMarker' ||
            event[1].type === 'listItemPrefix' ||
            event[1].type === 'listItemPrefixWhitespace'
          ) ; else {
            atMarker = undefined;
          }
          if (
            (!containerBalance &&
              event[0] === 'enter' &&
              event[1].type === 'listItemPrefix') ||
            (containerBalance === -1 &&
              event[0] === 'exit' &&
              (event[1].type === 'listUnordered' ||
                event[1].type === 'listOrdered'))
          ) {
            if (listItem) {
              let tailIndex = index;
              lineIndex = undefined;
              while (tailIndex--) {
                const tailEvent = events[tailIndex];
                if (
                  tailEvent[1].type === 'lineEnding' ||
                  tailEvent[1].type === 'lineEndingBlank'
                ) {
                  if (tailEvent[0] === 'exit') continue
                  if (lineIndex) {
                    events[lineIndex][1].type = 'lineEndingBlank';
                    listSpread = true;
                  }
                  tailEvent[1].type = 'lineEnding';
                  lineIndex = tailIndex;
                } else if (
                  tailEvent[1].type === 'linePrefix' ||
                  tailEvent[1].type === 'blockQuotePrefix' ||
                  tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
                  tailEvent[1].type === 'blockQuoteMarker' ||
                  tailEvent[1].type === 'listItemIndent'
                ) ; else {
                  break
                }
              }
              if (
                firstBlankLineIndex &&
                (!lineIndex || firstBlankLineIndex < lineIndex)
              ) {
                // @ts-expect-error Patched.
                listItem._spread = true;
              }

              // Fix position.
              listItem.end = Object.assign(
                {},
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);
              index++;
              length++;
            }

            // Create a new list item.
            if (event[1].type === 'listItemPrefix') {
              listItem = {
                type: 'listItem',
                // @ts-expect-error Patched
                _spread: false,
                start: Object.assign({}, event[1].start)
              };
              // @ts-expect-error: `listItem` is most definitely defined, TS...
              events.splice(index, 0, ['enter', listItem, event[2]]);
              index++;
              length++;
              firstBlankLineIndex = undefined;
              atMarker = true;
            }
          }
        }

        // @ts-expect-error Patched.
        events[start][1]._spread = listSpread;
        return length
      }

      /**
       * Set data.
       *
       * @template {keyof CompileData} Key
       *   Field type.
       * @param {Key} key
       *   Key of field.
       * @param {CompileData[Key]} [value]
       *   New value.
       * @returns {void}
       *   Nothing.
       */
      function setData(key, value) {
        data[key] = value;
      }

      /**
       * Get data.
       *
       * @template {keyof CompileData} Key
       *   Field type.
       * @param {Key} key
       *   Key of field.
       * @returns {CompileData[Key]}
       *   Value.
       */
      function getData(key) {
        return data[key]
      }

      /**
       * Create an opener handle.
       *
       * @param {(token: Token) => Node} create
       *   Create a node.
       * @param {Handle} [and]
       *   Optional function to also run.
       * @returns {Handle}
       *   Handle.
       */
      function opener(create, and) {
        return open

        /**
         * @this {CompileContext}
         * @param {Token} token
         * @returns {void}
         */
        function open(token) {
          enter.call(this, create(token), token);
          if (and) and.call(this, token);
        }
      }

      /**
       * @this {CompileContext}
       * @returns {void}
       */
      function buffer() {
        this.stack.push({
          type: 'fragment',
          children: []
        });
      }

      /**
       * @template {Node} Kind
       *   Node type.
       * @this {CompileContext}
       *   Context.
       * @param {Kind} node
       *   Node to enter.
       * @param {Token} token
       *   Corresponding token.
       * @param {OnEnterError | undefined} [errorHandler]
       *   Handle the case where this token is open, but it is closed by something else.
       * @returns {Kind}
       *   The given node.
       */
      function enter(node, token, errorHandler) {
        const parent = this.stack[this.stack.length - 1];
        // @ts-expect-error: Assume `Node` can exist as a child of `parent`.
        parent.children.push(node);
        this.stack.push(node);
        this.tokenStack.push([token, errorHandler]);
        // @ts-expect-error: `end` will be patched later.
        node.position = {
          start: point$1(token.start)
        };
        return node
      }

      /**
       * Create a closer handle.
       *
       * @param {Handle} [and]
       *   Optional function to also run.
       * @returns {Handle}
       *   Handle.
       */
      function closer(and) {
        return close

        /**
         * @this {CompileContext}
         * @param {Token} token
         * @returns {void}
         */
        function close(token) {
          if (and) and.call(this, token);
          exit.call(this, token);
        }
      }

      /**
       * @this {CompileContext}
       *   Context.
       * @param {Token} token
       *   Corresponding token.
       * @param {OnExitError | undefined} [onExitError]
       *   Handle the case where another token is open.
       * @returns {Node}
       *   The closed node.
       */
      function exit(token, onExitError) {
        const node = this.stack.pop();
        const open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            'Cannot close `' +
              token.type +
              '` (' +
              stringifyPosition({
                start: token.start,
                end: token.end
              }) +
              '): its not open'
          )
        } else if (open[0].type !== token.type) {
          if (onExitError) {
            onExitError.call(this, token, open[0]);
          } else {
            const handler = open[1] || defaultOnError;
            handler.call(this, token, open[0]);
          }
        }
        node.position.end = point$1(token.end);
        return node
      }

      /**
       * @this {CompileContext}
       * @returns {string}
       */
      function resume() {
        return toString(this.stack.pop())
      }

      //
      // Handlers.
      //

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onenterlistordered() {
        setData('expectingFirstListItemValue', true);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onenterlistitemvalue(token) {
        if (getData('expectingFirstListItemValue')) {
          const ancestor = this.stack[this.stack.length - 2];
          ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
          setData('expectingFirstListItemValue');
        }
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcodefencedfenceinfo() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.lang = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcodefencedfencemeta() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.meta = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcodefencedfence() {
        // Exit if this is the closing fence.
        if (getData('flowCodeInside')) return
        this.buffer();
        setData('flowCodeInside', true);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcodefenced() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '');
        setData('flowCodeInside');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcodeindented() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.value = data.replace(/(\r?\n|\r)$/g, '');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitdefinitionlabelstring(token) {
        const label = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.label = label;
        node.identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitdefinitiontitlestring() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.title = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitdefinitiondestinationstring() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.url = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitatxheadingsequence(token) {
        const node = this.stack[this.stack.length - 1];
        if (!node.depth) {
          const depth = this.sliceSerialize(token).length;
          node.depth = depth;
        }
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitsetextheadingtext() {
        setData('setextHeadingSlurpLineEnding', true);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitsetextheadinglinesequence(token) {
        const node = this.stack[this.stack.length - 1];
        node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitsetextheading() {
        setData('setextHeadingSlurpLineEnding');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onenterdata(token) {
        const node = this.stack[this.stack.length - 1];
        let tail = node.children[node.children.length - 1];
        if (!tail || tail.type !== 'text') {
          // Add a new text node.
          tail = text();
          // @ts-expect-error: well add `end` later.
          tail.position = {
            start: point$1(token.start)
          };
          // @ts-expect-error: Assume `parent` accepts `text`.
          node.children.push(tail);
        }
        this.stack.push(tail);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitdata(token) {
        const tail = this.stack.pop();
        tail.value += this.sliceSerialize(token);
        tail.position.end = point$1(token.end);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitlineending(token) {
        const context = this.stack[this.stack.length - 1];
        // If were at a hard break, include the line ending in there.
        if (getData('atHardBreak')) {
          const tail = context.children[context.children.length - 1];
          tail.position.end = point$1(token.end);
          setData('atHardBreak');
          return
        }
        if (
          !getData('setextHeadingSlurpLineEnding') &&
          config.canContainEols.includes(context.type)
        ) {
          onenterdata.call(this, token);
          onexitdata.call(this, token);
        }
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexithardbreak() {
        setData('atHardBreak', true);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexithtmlflow() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.value = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexithtmltext() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.value = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitcodetext() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.value = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitlink() {
        const node = this.stack[this.stack.length - 1];
        // Note: there are also `identifier` and `label` fields on this link node!
        // These are used / cleaned here.

        // To do: clean.
        if (getData('inReference')) {
          /** @type {ReferenceType} */
          const referenceType = getData('referenceType') || 'shortcut';
          node.type += 'Reference';
          // @ts-expect-error: mutate.
          node.referenceType = referenceType;
          // @ts-expect-error: mutate.
          delete node.url;
          delete node.title;
        } else {
          // @ts-expect-error: mutate.
          delete node.identifier;
          // @ts-expect-error: mutate.
          delete node.label;
        }
        setData('referenceType');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitimage() {
        const node = this.stack[this.stack.length - 1];
        // Note: there are also `identifier` and `label` fields on this link node!
        // These are used / cleaned here.

        // To do: clean.
        if (getData('inReference')) {
          /** @type {ReferenceType} */
          const referenceType = getData('referenceType') || 'shortcut';
          node.type += 'Reference';
          // @ts-expect-error: mutate.
          node.referenceType = referenceType;
          // @ts-expect-error: mutate.
          delete node.url;
          delete node.title;
        } else {
          // @ts-expect-error: mutate.
          delete node.identifier;
          // @ts-expect-error: mutate.
          delete node.label;
        }
        setData('referenceType');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitlabeltext(token) {
        const string = this.sliceSerialize(token);
        const ancestor = this.stack[this.stack.length - 2];
        // @ts-expect-error: stash this on the node, as it might become a reference
        // later.
        ancestor.label = decodeString(string);
        // @ts-expect-error: same as above.
        ancestor.identifier = normalizeIdentifier(string).toLowerCase();
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitlabel() {
        const fragment = this.stack[this.stack.length - 1];
        const value = this.resume();
        const node = this.stack[this.stack.length - 1];
        // Assume a reference.
        setData('inReference', true);
        if (node.type === 'link') {
          /** @type {Array<StaticPhrasingContent>} */
          // @ts-expect-error: Assume static phrasing content.
          const children = fragment.children;
          node.children = children;
        } else {
          node.alt = value;
        }
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitresourcedestinationstring() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.url = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitresourcetitlestring() {
        const data = this.resume();
        const node = this.stack[this.stack.length - 1];
        node.title = data;
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitresource() {
        setData('inReference');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onenterreference() {
        setData('referenceType', 'collapsed');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitreferencestring(token) {
        const label = this.resume();
        const node = this.stack[this.stack.length - 1];
        // @ts-expect-error: stash this on the node, as it might become a reference
        // later.
        node.label = label;
        // @ts-expect-error: same as above.
        node.identifier = normalizeIdentifier(
          this.sliceSerialize(token)
        ).toLowerCase();
        setData('referenceType', 'full');
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */

      function onexitcharacterreferencemarker(token) {
        setData('characterReferenceType', token.type);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitcharacterreferencevalue(token) {
        const data = this.sliceSerialize(token);
        const type = getData('characterReferenceType');
        /** @type {string} */
        let value;
        if (type) {
          value = decodeNumericCharacterReference(
            data,
            type === 'characterReferenceMarkerNumeric' ? 10 : 16
          );
          setData('characterReferenceType');
        } else {
          const result = decodeNamedCharacterReference(data);
          value = result;
        }
        const tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point$1(token.end);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitautolinkprotocol(token) {
        onexitdata.call(this, token);
        const node = this.stack[this.stack.length - 1];
        node.url = this.sliceSerialize(token);
      }

      /**
       * @this {CompileContext}
       * @type {Handle}
       */
      function onexitautolinkemail(token) {
        onexitdata.call(this, token);
        const node = this.stack[this.stack.length - 1];
        node.url = 'mailto:' + this.sliceSerialize(token);
      }

      //
      // Creaters.
      //

      /** @returns {Blockquote} */
      function blockQuote() {
        return {
          type: 'blockquote',
          children: []
        }
      }

      /** @returns {Code} */
      function codeFlow() {
        return {
          type: 'code',
          lang: null,
          meta: null,
          value: ''
        }
      }

      /** @returns {InlineCode} */
      function codeText() {
        return {
          type: 'inlineCode',
          value: ''
        }
      }

      /** @returns {Definition} */
      function definition() {
        return {
          type: 'definition',
          identifier: '',
          label: null,
          title: null,
          url: ''
        }
      }

      /** @returns {Emphasis} */
      function emphasis() {
        return {
          type: 'emphasis',
          children: []
        }
      }

      /** @returns {Heading} */
      function heading() {
        // @ts-expect-error `depth` will be set later.
        return {
          type: 'heading',
          depth: undefined,
          children: []
        }
      }

      /** @returns {Break} */
      function hardBreak() {
        return {
          type: 'break'
        }
      }

      /** @returns {HTML} */
      function html() {
        return {
          type: 'html',
          value: ''
        }
      }

      /** @returns {Image} */
      function image() {
        return {
          type: 'image',
          title: null,
          url: '',
          alt: null
        }
      }

      /** @returns {Link} */
      function link() {
        return {
          type: 'link',
          title: null,
          url: '',
          children: []
        }
      }

      /**
       * @param {Token} token
       * @returns {List}
       */
      function list(token) {
        return {
          type: 'list',
          ordered: token.type === 'listOrdered',
          start: null,
          // @ts-expect-error Patched.
          spread: token._spread,
          children: []
        }
      }

      /**
       * @param {Token} token
       * @returns {ListItem}
       */
      function listItem(token) {
        return {
          type: 'listItem',
          // @ts-expect-error Patched.
          spread: token._spread,
          checked: null,
          children: []
        }
      }

      /** @returns {Paragraph} */
      function paragraph() {
        return {
          type: 'paragraph',
          children: []
        }
      }

      /** @returns {Strong} */
      function strong() {
        return {
          type: 'strong',
          children: []
        }
      }

      /** @returns {Text} */
      function text() {
        return {
          type: 'text',
          value: ''
        }
      }

      /** @returns {ThematicBreak} */
      function thematicBreak() {
        return {
          type: 'thematicBreak'
        }
      }
    }

    /**
     * Copy a point-like value.
     *
     * @param {Point} d
     *   Point-like value.
     * @returns {Point}
     *   unist point.
     */
    function point$1(d) {
      return {
        line: d.line,
        column: d.column,
        offset: d.offset
      }
    }

    /**
     * @param {Config} combined
     * @param {Array<Extension | Array<Extension>>} extensions
     * @returns {void}
     */
    function configure(combined, extensions) {
      let index = -1;
      while (++index < extensions.length) {
        const value = extensions[index];
        if (Array.isArray(value)) {
          configure(combined, value);
        } else {
          extension(combined, value);
        }
      }
    }

    /**
     * @param {Config} combined
     * @param {Extension} extension
     * @returns {void}
     */
    function extension(combined, extension) {
      /** @type {keyof Extension} */
      let key;
      for (key in extension) {
        if (own$6.call(extension, key)) {
          if (key === 'canContainEols') {
            const right = extension[key];
            if (right) {
              combined[key].push(...right);
            }
          } else if (key === 'transforms') {
            const right = extension[key];
            if (right) {
              combined[key].push(...right);
            }
          } else if (key === 'enter' || key === 'exit') {
            const right = extension[key];
            if (right) {
              Object.assign(combined[key], right);
            }
          }
        }
      }
    }

    /** @type {OnEnterError} */
    function defaultOnError(left, right) {
      if (left) {
        throw new Error(
          'Cannot close `' +
            left.type +
            '` (' +
            stringifyPosition({
              start: left.start,
              end: left.end
            }) +
            '): a different token (`' +
            right.type +
            '`, ' +
            stringifyPosition({
              start: right.start,
              end: right.end
            }) +
            ') is open'
        )
      } else {
        throw new Error(
          'Cannot close document, a token (`' +
            right.type +
            '`, ' +
            stringifyPosition({
              start: right.start,
              end: right.end
            }) +
            ') is still open'
        )
      }
    }

    /**
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast-util-from-markdown').Options} Options
     */

    /** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */
    function remarkParse(options) {
      /** @type {import('unified').ParserFunction<Root>} */
      const parser = (doc) => {
        // Assume options.
        const settings = /** @type {Options} */ (this.data('settings'));

        return fromMarkdown(
          doc,
          Object.assign({}, settings, options, {
            // Note: these options are not in the readme.
            // The goal is for them to be set by plugins on `data` instead of being
            // passed by users.
            extensions: this.data('micromarkExtensions') || [],
            mdastExtensions: this.data('fromMarkdownExtensions') || []
          })
        )
      };

      Object.assign(this, {Parser: parser});
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Blockquote} Blockquote
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `blockquote` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Blockquote} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function blockquote(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'blockquote',
        properties: {},
        children: state.wrap(state.all(node), true)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Text} Text
     * @typedef {import('mdast').Break} Break
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `break` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Break} node
     *   mdast node.
     * @returns {Array<Element | Text>}
     *   hast element content.
     */
    function hardBreak(state, node) {
      /** @type {Element} */
      const result = {type: 'element', tagName: 'br', properties: {}, children: []};
      state.patch(node, result);
      return [state.applyData(node, result), {type: 'text', value: '\n'}]
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').Code} Code
     * @typedef {import('../state.js').State} State

     */

    /**
     * Turn an mdast `code` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Code} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function code$1(state, node) {
      const value = node.value ? node.value + '\n' : '';
      // To do: next major, use `node.lang` w/o regex, the splittings been going
      // on for years in remark now.
      const lang = node.lang ? node.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
      /** @type {Properties} */
      const properties = {};

      if (lang) {
        properties.className = ['language-' + lang];
      }

      // Create `<code>`.
      /** @type {Element} */
      let result = {
        type: 'element',
        tagName: 'code',
        properties,
        children: [{type: 'text', value}]
      };

      if (node.meta) {
        result.data = {meta: node.meta};
      }

      state.patch(node, result);
      result = state.applyData(node, result);

      // Create `<pre>`.
      result = {type: 'element', tagName: 'pre', properties: {}, children: [result]};
      state.patch(node, result);
      return result
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Delete} Delete
     * @typedef {import('../state.js').State} State

     */

    /**
     * Turn an mdast `delete` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Delete} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function strikethrough(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'del',
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Emphasis} Emphasis
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `emphasis` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Emphasis} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function emphasis(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'em',
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * Normalize a URL (such as used in definitions).
     *
     * Encode unsafe characters with percent-encoding, skipping already encoded
     * sequences.
     *
     * @param {string} value
     * @returns {string}
     */

    function normalizeUri(value) {
      /** @type {Array<string>} */
      const result = [];
      let index = -1;
      let start = 0;
      let skip = 0;

      while (++index < value.length) {
        const code = value.charCodeAt(index);
        /** @type {string} */

        let replace = ''; // A correct percent encoded value.

        if (
          code === 37 &&
          asciiAlphanumeric(value.charCodeAt(index + 1)) &&
          asciiAlphanumeric(value.charCodeAt(index + 2))
        ) {
          skip = 2;
        } // ASCII.
        else if (code < 128) {
          if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {
            replace = String.fromCharCode(code);
          }
        } // Astral.
        else if (code > 55295 && code < 57344) {
          const next = value.charCodeAt(index + 1); // A correct surrogate pair.

          if (code < 56320 && next > 56319 && next < 57344) {
            replace = String.fromCharCode(code, next);
            skip = 1;
          } // Lone surrogate.
          else {
            replace = '\uFFFD';
          }
        } // Unicode.
        else {
          replace = String.fromCharCode(code);
        }

        if (replace) {
          result.push(value.slice(start, index), encodeURIComponent(replace));
          start = index + skip + 1;
          replace = '';
        }

        if (skip) {
          index += skip;
          skip = 0;
        }
      }

      return result.join('') + value.slice(start)
    }

    /**
     * @typedef {import('mdast').FootnoteReference} FootnoteReference
     * @typedef {import('hast').Element} Element
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `footnoteReference` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {FootnoteReference} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function footnoteReference$1(state, node) {
      const id = String(node.identifier).toUpperCase();
      const safeId = normalizeUri(id.toLowerCase());
      const index = state.footnoteOrder.indexOf(id);
      /** @type {number} */
      let counter;

      if (index === -1) {
        state.footnoteOrder.push(id);
        state.footnoteCounts[id] = 1;
        counter = state.footnoteOrder.length;
      } else {
        state.footnoteCounts[id]++;
        counter = index + 1;
      }

      const reuseCounter = state.footnoteCounts[id];

      /** @type {Element} */
      const link = {
        type: 'element',
        tagName: 'a',
        properties: {
          href: '#' + state.clobberPrefix + 'fn-' + safeId,
          id:
            state.clobberPrefix +
            'fnref-' +
            safeId +
            (reuseCounter > 1 ? '-' + reuseCounter : ''),
          dataFootnoteRef: true,
          ariaDescribedBy: ['footnote-label']
        },
        children: [{type: 'text', value: String(counter)}]
      };
      state.patch(node, link);

      /** @type {Element} */
      const sup = {
        type: 'element',
        tagName: 'sup',
        properties: {},
        children: [link]
      };
      state.patch(node, sup);
      return state.applyData(node, sup)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Footnote} Footnote
     * @typedef {import('../state.js').State} State
     */

    // To do: when both:
    // * <https://github.com/micromark/micromark-extension-footnote>
    // * <https://github.com/syntax-tree/mdast-util-footnote>
    // are archived, remove this (also from mdast).
    // These inline notes are not used in GFM.

    /**
     * Turn an mdast `footnote` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Footnote} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function footnote(state, node) {
      const footnoteById = state.footnoteById;
      let no = 1;

      while (no in footnoteById) no++;

      const identifier = String(no);

      footnoteById[identifier] = {
        type: 'footnoteDefinition',
        identifier,
        children: [{type: 'paragraph', children: node.children}],
        position: node.position
      };

      return footnoteReference$1(state, {
        type: 'footnoteReference',
        identifier,
        position: node.position
      })
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Heading} Heading
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `heading` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Heading} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function heading(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'h' + node.depth,
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').HTML} Html
     * @typedef {import('../state.js').State} State
     * @typedef {import('../../index.js').Raw} Raw
     */

    /**
     * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise
     * nothing).
     *
     * @param {State} state
     *   Info passed around.
     * @param {Html} node
     *   mdast node.
     * @returns {Raw | Element | null}
     *   hast node.
     */
    function html$2(state, node) {
      if (state.dangerous) {
        /** @type {Raw} */
        const result = {type: 'raw', value: node.value};
        state.patch(node, result);
        return state.applyData(node, result)
      }

      // To do: next major: return `undefined`.
      return null
    }

    /**
     * @typedef {import('hast').ElementContent} ElementContent
     *
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').Reference} Reference
     * @typedef {import('mdast').Root} Root
     *
     * @typedef {import('./state.js').State} State
     */

    /**
     * @typedef {Root | Content} Nodes
     * @typedef {Extract<Nodes, Reference>} References
     */

    // To do: next major: always return array.

    /**
     * Return the content of a reference without definition as plain text.
     *
     * @param {State} state
     *   Info passed around.
     * @param {References} node
     *   Reference node (image, link).
     * @returns {ElementContent | Array<ElementContent>}
     *   hast content.
     */
    function revert(state, node) {
      const subtype = node.referenceType;
      let suffix = ']';

      if (subtype === 'collapsed') {
        suffix += '[]';
      } else if (subtype === 'full') {
        suffix += '[' + (node.label || node.identifier) + ']';
      }

      if (node.type === 'imageReference') {
        return {type: 'text', value: '![' + node.alt + suffix}
      }

      const contents = state.all(node);
      const head = contents[0];

      if (head && head.type === 'text') {
        head.value = '[' + head.value;
      } else {
        contents.unshift({type: 'text', value: '['});
      }

      const tail = contents[contents.length - 1];

      if (tail && tail.type === 'text') {
        tail.value += suffix;
      } else {
        contents.push({type: 'text', value: suffix});
      }

      return contents
    }

    /**
     * @typedef {import('hast').ElementContent} ElementContent
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').ImageReference} ImageReference
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `imageReference` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {ImageReference} node
     *   mdast node.
     * @returns {ElementContent | Array<ElementContent>}
     *   hast node.
     */
    function imageReference(state, node) {
      const def = state.definition(node.identifier);

      if (!def) {
        return revert(state, node)
      }

      /** @type {Properties} */
      const properties = {src: normalizeUri(def.url || ''), alt: node.alt};

      if (def.title !== null && def.title !== undefined) {
        properties.title = def.title;
      }

      /** @type {Element} */
      const result = {type: 'element', tagName: 'img', properties, children: []};
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').Image} Image
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `image` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Image} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function image(state, node) {
      /** @type {Properties} */
      const properties = {src: normalizeUri(node.url)};

      if (node.alt !== null && node.alt !== undefined) {
        properties.alt = node.alt;
      }

      if (node.title !== null && node.title !== undefined) {
        properties.title = node.title;
      }

      /** @type {Element} */
      const result = {type: 'element', tagName: 'img', properties, children: []};
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Text} Text
     * @typedef {import('mdast').InlineCode} InlineCode
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `inlineCode` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {InlineCode} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function inlineCode$1(state, node) {
      /** @type {Text} */
      const text = {type: 'text', value: node.value.replace(/\r?\n|\r/g, ' ')};
      state.patch(node, text);

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'code',
        properties: {},
        children: [text]
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').ElementContent} ElementContent
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').LinkReference} LinkReference
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `linkReference` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {LinkReference} node
     *   mdast node.
     * @returns {ElementContent | Array<ElementContent>}
     *   hast node.
     */
    function linkReference(state, node) {
      const def = state.definition(node.identifier);

      if (!def) {
        return revert(state, node)
      }

      /** @type {Properties} */
      const properties = {href: normalizeUri(def.url || '')};

      if (def.title !== null && def.title !== undefined) {
        properties.title = def.title;
      }

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'a',
        properties,
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').Link} Link
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `link` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Link} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function link(state, node) {
      /** @type {Properties} */
      const properties = {href: normalizeUri(node.url)};

      if (node.title !== null && node.title !== undefined) {
        properties.title = node.title;
      }

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'a',
        properties,
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').ElementContent} ElementContent
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').ListItem} ListItem
     * @typedef {import('mdast').Parent} Parent
     * @typedef {import('mdast').Root} Root
     * @typedef {import('../state.js').State} State
     */

    /**
     * @typedef {Root | Content} Nodes
     * @typedef {Extract<Nodes, Parent>} Parents
     */

    /**
     * Turn an mdast `listItem` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {ListItem} node
     *   mdast node.
     * @param {Parents | null | undefined} parent
     *   Parent of `node`.
     * @returns {Element}
     *   hast node.
     */
    function listItem$1(state, node, parent) {
      const results = state.all(node);
      const loose = parent ? listLoose(parent) : listItemLoose(node);
      /** @type {Properties} */
      const properties = {};
      /** @type {Array<ElementContent>} */
      const children = [];

      if (typeof node.checked === 'boolean') {
        const head = results[0];
        /** @type {Element} */
        let paragraph;

        if (head && head.type === 'element' && head.tagName === 'p') {
          paragraph = head;
        } else {
          paragraph = {type: 'element', tagName: 'p', properties: {}, children: []};
          results.unshift(paragraph);
        }

        if (paragraph.children.length > 0) {
          paragraph.children.unshift({type: 'text', value: ' '});
        }

        paragraph.children.unshift({
          type: 'element',
          tagName: 'input',
          properties: {type: 'checkbox', checked: node.checked, disabled: true},
          children: []
        });

        // According to github-markdown-css, this class hides bullet.
        // See: <https://github.com/sindresorhus/github-markdown-css>.
        properties.className = ['task-list-item'];
      }

      let index = -1;

      while (++index < results.length) {
        const child = results[index];

        // Add eols before nodes, except if this is a loose, first paragraph.
        if (
          loose ||
          index !== 0 ||
          child.type !== 'element' ||
          child.tagName !== 'p'
        ) {
          children.push({type: 'text', value: '\n'});
        }

        if (child.type === 'element' && child.tagName === 'p' && !loose) {
          children.push(...child.children);
        } else {
          children.push(child);
        }
      }

      const tail = results[results.length - 1];

      // Add a final eol.
      if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {
        children.push({type: 'text', value: '\n'});
      }

      /** @type {Element} */
      const result = {type: 'element', tagName: 'li', properties, children};
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @param {Parents} node
     * @return {Boolean}
     */
    function listLoose(node) {
      let loose = false;
      if (node.type === 'list') {
        loose = node.spread || false;
        const children = node.children;
        let index = -1;

        while (!loose && ++index < children.length) {
          loose = listItemLoose(children[index]);
        }
      }

      return loose
    }

    /**
     * @param {ListItem} node
     * @return {Boolean}
     */
    function listItemLoose(node) {
      const spread = node.spread;

      return spread === undefined || spread === null
        ? node.children.length > 1
        : spread
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('mdast').List} List
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `list` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {List} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function list(state, node) {
      /** @type {Properties} */
      const properties = {};
      const results = state.all(node);
      let index = -1;

      if (typeof node.start === 'number' && node.start !== 1) {
        properties.start = node.start;
      }

      // Like GitHub, add a class for custom styling.
      while (++index < results.length) {
        const child = results[index];

        if (
          child.type === 'element' &&
          child.tagName === 'li' &&
          child.properties &&
          Array.isArray(child.properties.className) &&
          child.properties.className.includes('task-list-item')
        ) {
          properties.className = ['contains-task-list'];
          break
        }
      }

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: node.ordered ? 'ol' : 'ul',
        properties,
        children: state.wrap(results, true)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Paragraph} Paragraph
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `paragraph` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Paragraph} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function paragraph(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'p',
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Root} HastRoot
     * @typedef {import('hast').Element} HastElement
     * @typedef {import('mdast').Root} MdastRoot
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `root` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {MdastRoot} node
     *   mdast node.
     * @returns {HastRoot | HastElement}
     *   hast node.
     */
    function root(state, node) {
      /** @type {HastRoot} */
      const result = {type: 'root', children: state.wrap(state.all(node))};
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Strong} Strong
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `strong` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Strong} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function strong(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'strong',
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('unist').Position} Position
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Point} Point
     */

    /**
     * @typedef NodeLike
     * @property {string} type
     * @property {PositionLike | null | undefined} [position]
     *
     * @typedef PositionLike
     * @property {PointLike | null | undefined} [start]
     * @property {PointLike | null | undefined} [end]
     *
     * @typedef PointLike
     * @property {number | null | undefined} [line]
     * @property {number | null | undefined} [column]
     * @property {number | null | undefined} [offset]
     */

    /**
     * Get the starting point of `node`.
     *
     * @param node
     *   Node.
     * @returns
     *   Point.
     */
    const pointStart = point('start');

    /**
     * Get the ending point of `node`.
     *
     * @param node
     *   Node.
     * @returns
     *   Point.
     */
    const pointEnd = point('end');

    /**
     * Get the positional info of `node`.
     *
     * @param {NodeLike | Node | null | undefined} [node]
     *   Node.
     * @returns {Position}
     *   Position.
     */
    function position(node) {
      return {start: pointStart(node), end: pointEnd(node)}
    }

    /**
     * Get the positional info of `node`.
     *
     * @param {'start' | 'end'} type
     *   Side.
     * @returns
     *   Getter.
     */
    function point(type) {
      return point

      /**
       * Get the point info of `node` at a bound side.
       *
       * @param {NodeLike | Node | null | undefined} [node]
       * @returns {Point}
       */
      function point(node) {
        const point = (node && node.position && node.position[type]) || {};

        // To do: next major: dont return points when invalid.
        return {
          // @ts-expect-error: in practice, null is allowed.
          line: point.line || null,
          // @ts-expect-error: in practice, null is allowed.
          column: point.column || null,
          // @ts-expect-error: in practice, null is allowed.
          offset: point.offset > -1 ? point.offset : null
        }
      }
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').Table} Table
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `table` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {Table} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function table(state, node) {
      const rows = state.all(node);
      const firstRow = rows.shift();
      /** @type {Array<Element>} */
      const tableContent = [];

      if (firstRow) {
        /** @type {Element} */
        const head = {
          type: 'element',
          tagName: 'thead',
          properties: {},
          children: state.wrap([firstRow], true)
        };
        state.patch(node.children[0], head);
        tableContent.push(head);
      }

      if (rows.length > 0) {
        /** @type {Element} */
        const body = {
          type: 'element',
          tagName: 'tbody',
          properties: {},
          children: state.wrap(rows, true)
        };

        const start = pointStart(node.children[1]);
        const end = pointEnd(node.children[node.children.length - 1]);
        if (start.line && end.line) body.position = {start, end};
        tableContent.push(body);
      }

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'table',
        properties: {},
        children: state.wrap(tableContent, true)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Properties} Properties
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').ElementContent} ElementContent
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').Parent} Parent
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast').TableRow} TableRow
     * @typedef {import('../state.js').State} State
     */

    /**
     * @typedef {Root | Content} Nodes
     * @typedef {Extract<Nodes, Parent>} Parents
     */

    /**
     * Turn an mdast `tableRow` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {TableRow} node
     *   mdast node.
     * @param {Parents | null | undefined} parent
     *   Parent of `node`.
     * @returns {Element}
     *   hast node.
     */
    function tableRow(state, node, parent) {
      const siblings = parent ? parent.children : undefined;
      // Generate a body row when without parent.
      const rowIndex = siblings ? siblings.indexOf(node) : 1;
      const tagName = rowIndex === 0 ? 'th' : 'td';
      const align = parent && parent.type === 'table' ? parent.align : undefined;
      const length = align ? align.length : node.children.length;
      let cellIndex = -1;
      /** @type {Array<ElementContent>} */
      const cells = [];

      while (++cellIndex < length) {
        // Note: can also be undefined.
        const cell = node.children[cellIndex];
        /** @type {Properties} */
        const properties = {};
        const alignValue = align ? align[cellIndex] : undefined;

        if (alignValue) {
          properties.align = alignValue;
        }

        /** @type {Element} */
        let result = {type: 'element', tagName, properties, children: []};

        if (cell) {
          result.children = state.all(cell);
          state.patch(cell, result);
          result = state.applyData(node, result);
        }

        cells.push(result);
      }

      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'tr',
        properties: {},
        children: state.wrap(cells, true)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').TableCell} TableCell
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `tableCell` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {TableCell} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function tableCell(state, node) {
      // Note: this function is normally not called: see `table-row` for how rows
      // and their cells are compiled.
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'td', // Assume body cell.
        properties: {},
        children: state.all(node)
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    const tab = 9; /* `\t` */
    const space = 32; /* ` ` */

    /**
     * Remove initial and final spaces and tabs at the line breaks in `value`.
     * Does not trim initial and final spaces and tabs of the value itself.
     *
     * @param {string} value
     *   Value to trim.
     * @returns {string}
     *   Trimmed value.
     */
    function trimLines(value) {
      const source = String(value);
      const search = /\r?\n|\r/g;
      let match = search.exec(source);
      let last = 0;
      /** @type {Array<string>} */
      const lines = [];

      while (match) {
        lines.push(
          trimLine(source.slice(last, match.index), last > 0, true),
          match[0]
        );

        last = match.index + match[0].length;
        match = search.exec(source);
      }

      lines.push(trimLine(source.slice(last), last > 0, false));

      return lines.join('')
    }

    /**
     * @param {string} value
     *   Line to trim.
     * @param {boolean} start
     *   Whether to trim the start of the line.
     * @param {boolean} end
     *   Whether to trim the end of the line.
     * @returns {string}
     *   Trimmed line.
     */
    function trimLine(value, start, end) {
      let startIndex = 0;
      let endIndex = value.length;

      if (start) {
        let code = value.codePointAt(startIndex);

        while (code === tab || code === space) {
          startIndex++;
          code = value.codePointAt(startIndex);
        }
      }

      if (end) {
        let code = value.codePointAt(endIndex - 1);

        while (code === tab || code === space) {
          endIndex--;
          code = value.codePointAt(endIndex - 1);
        }
      }

      return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''
    }

    /**
     * @typedef {import('hast').Element} HastElement
     * @typedef {import('hast').Text} HastText
     * @typedef {import('mdast').Text} MdastText
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `text` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {MdastText} node
     *   mdast node.
     * @returns {HastText | HastElement}
     *   hast node.
     */
    function text$1(state, node) {
      /** @type {HastText} */
      const result = {type: 'text', value: trimLines(String(node.value))};
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('mdast').ThematicBreak} ThematicBreak
     * @typedef {import('../state.js').State} State
     */

    /**
     * Turn an mdast `thematicBreak` node into hast.
     *
     * @param {State} state
     *   Info passed around.
     * @param {ThematicBreak} node
     *   mdast node.
     * @returns {Element}
     *   hast node.
     */
    function thematicBreak(state, node) {
      /** @type {Element} */
      const result = {
        type: 'element',
        tagName: 'hr',
        properties: {},
        children: []
      };
      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * Default handlers for nodes.
     */
    const handlers = {
      blockquote,
      break: hardBreak,
      code: code$1,
      delete: strikethrough,
      emphasis,
      footnoteReference: footnoteReference$1,
      footnote,
      heading,
      html: html$2,
      imageReference,
      image,
      inlineCode: inlineCode$1,
      linkReference,
      link,
      listItem: listItem$1,
      list,
      paragraph,
      root,
      strong,
      table,
      tableCell,
      tableRow,
      text: text$1,
      thematicBreak,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };

    // Return nothing for nodes that are ignored.
    function ignore() {
      // To do: next major: return `undefined`.
      return null
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Parent} Parent
     */

    /**
     * Generate an assertion from a test.
     *
     * Useful if youre going to test many nodes, for example when creating a
     * utility where something else passes a compatible test.
     *
     * The created function is a bit faster because it expects valid input only:
     * a `node`, `index`, and `parent`.
     *
     * @param test
     *   *   when nullish, checks if `node` is a `Node`.
     *   *   when `string`, works like passing `(node) => node.type === test`.
     *   *   when `function` checks if function passed the node is true.
     *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
     *   *   when `array`, checks if any one of the subtests pass.
     * @returns
     *   An assertion.
     */
    const convert =
      /**
       * @type {(
       *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
       *   ((test?: Test) => AssertAnything)
       * )}
       */
      (
        /**
         * @param {Test} [test]
         * @returns {AssertAnything}
         */
        function (test) {
          if (test === undefined || test === null) {
            return ok
          }

          if (typeof test === 'string') {
            return typeFactory(test)
          }

          if (typeof test === 'object') {
            return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
          }

          if (typeof test === 'function') {
            return castFactory(test)
          }

          throw new Error('Expected function, string, or object as test')
        }
      );

    /**
     * @param {Array<string | Props | TestFunctionAnything>} tests
     * @returns {AssertAnything}
     */
    function anyFactory(tests) {
      /** @type {Array<AssertAnything>} */
      const checks = [];
      let index = -1;

      while (++index < tests.length) {
        checks[index] = convert(tests[index]);
      }

      return castFactory(any)

      /**
       * @this {unknown}
       * @param {Array<unknown>} parameters
       * @returns {boolean}
       */
      function any(...parameters) {
        let index = -1;

        while (++index < checks.length) {
          if (checks[index].call(this, ...parameters)) return true
        }

        return false
      }
    }

    /**
     * Turn an object into a test for a node with a certain fields.
     *
     * @param {Props} check
     * @returns {AssertAnything}
     */
    function propsFactory(check) {
      return castFactory(all)

      /**
       * @param {Node} node
       * @returns {boolean}
       */
      function all(node) {
        /** @type {string} */
        let key;

        for (key in check) {
          // @ts-expect-error: hush, it sure works as an index.
          if (node[key] !== check[key]) return false
        }

        return true
      }
    }

    /**
     * Turn a string into a test for a node with a certain type.
     *
     * @param {string} check
     * @returns {AssertAnything}
     */
    function typeFactory(check) {
      return castFactory(type)

      /**
       * @param {Node} node
       */
      function type(node) {
        return node && node.type === check
      }
    }

    /**
     * Turn a custom test into a test for a node that passes that test.
     *
     * @param {TestFunctionAnything} check
     * @returns {AssertAnything}
     */
    function castFactory(check) {
      return assertion

      /**
       * @this {unknown}
       * @param {unknown} node
       * @param {Array<unknown>} parameters
       * @returns {boolean}
       */
      function assertion(node, ...parameters) {
        return Boolean(
          node &&
            typeof node === 'object' &&
            'type' in node &&
            // @ts-expect-error: fine.
            Boolean(check.call(this, node, ...parameters))
        )
      }
    }

    function ok() {
      return true
    }

    /**
     * @param {string} d
     * @returns {string}
     */
    function color(d) {
      return '\u001B[33m' + d + '\u001B[39m'
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Parent} Parent
     * @typedef {import('unist-util-is').Test} Test
     */

    /**
     * Continue traversing as normal.
     */
    const CONTINUE = true;

    /**
     * Stop traversing immediately.
     */
    const EXIT = false;

    /**
     * Do not traverse this nodes children.
     */
    const SKIP = 'skip';

    /**
     * Visit nodes, with ancestral information.
     *
     * This algorithm performs *depth-first* *tree traversal* in *preorder*
     * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
     *
     * You can choose for which nodes `visitor` is called by passing a `test`.
     * For complex tests, you should test yourself in `visitor`, as it will be
     * faster and will have improved type information.
     *
     * Walking the tree is an intensive task.
     * Make use of the return values of the visitor when possible.
     * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
     * to check if a node matches, and then perform different operations.
     *
     * You can change the tree.
     * See `Visitor` for more info.
     *
     * @param tree
     *   Tree to traverse.
     * @param test
     *   `unist-util-is`-compatible test
     * @param visitor
     *   Handle each node.
     * @param reverse
     *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
     * @returns
     *   Nothing.
     */
    const visitParents =
      /**
       * @type {(
       *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
       *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
       * )}
       */
      (
        /**
         * @param {Node} tree
         * @param {Test} test
         * @param {Visitor<Node>} visitor
         * @param {boolean | null | undefined} [reverse]
         * @returns {void}
         */
        function (tree, test, visitor, reverse) {
          if (typeof test === 'function' && typeof visitor !== 'function') {
            reverse = visitor;
            // @ts-expect-error no visitor given, so `visitor` is test.
            visitor = test;
            test = null;
          }

          const is = convert(test);
          const step = reverse ? -1 : 1;

          factory(tree, undefined, [])();

          /**
           * @param {Node} node
           * @param {number | undefined} index
           * @param {Array<Parent>} parents
           */
          function factory(node, index, parents) {
            /** @type {Record<string, unknown>} */
            // @ts-expect-error: hush
            const value = node && typeof node === 'object' ? node : {};

            if (typeof value.type === 'string') {
              const name =
                // `hast`
                typeof value.tagName === 'string'
                  ? value.tagName
                  : // `xast`
                  typeof value.name === 'string'
                  ? value.name
                  : undefined;

              Object.defineProperty(visit, 'name', {
                value:
                  'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'
              });
            }

            return visit

            function visit() {
              /** @type {ActionTuple} */
              let result = [];
              /** @type {ActionTuple} */
              let subresult;
              /** @type {number} */
              let offset;
              /** @type {Array<Parent>} */
              let grandparents;

              if (!test || is(node, index, parents[parents.length - 1] || null)) {
                result = toResult(visitor(node, parents));

                if (result[0] === EXIT) {
                  return result
                }
              }

              // @ts-expect-error looks like a parent.
              if (node.children && result[0] !== SKIP) {
                // @ts-expect-error looks like a parent.
                offset = (reverse ? node.children.length : -1) + step;
                // @ts-expect-error looks like a parent.
                grandparents = parents.concat(node);

                // @ts-expect-error looks like a parent.
                while (offset > -1 && offset < node.children.length) {
                  // @ts-expect-error looks like a parent.
                  subresult = factory(node.children[offset], offset, grandparents)();

                  if (subresult[0] === EXIT) {
                    return subresult
                  }

                  offset =
                    typeof subresult[1] === 'number' ? subresult[1] : offset + step;
                }
              }

              return result
            }
          }
        }
      );

    /**
     * Turn a return value into a clean result.
     *
     * @param {VisitorResult} value
     *   Valid return values from visitors.
     * @returns {ActionTuple}
     *   Clean result.
     */
    function toResult(value) {
      if (Array.isArray(value)) {
        return value
      }

      if (typeof value === 'number') {
        return [CONTINUE, value]
      }

      return [value]
    }

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('unist').Parent} Parent
     * @typedef {import('unist-util-is').Test} Test
     * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
     */

    /**
     * Visit nodes.
     *
     * This algorithm performs *depth-first* *tree traversal* in *preorder*
     * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
     *
     * You can choose for which nodes `visitor` is called by passing a `test`.
     * For complex tests, you should test yourself in `visitor`, as it will be
     * faster and will have improved type information.
     *
     * Walking the tree is an intensive task.
     * Make use of the return values of the visitor when possible.
     * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
     * to check if a node matches, and then perform different operations.
     *
     * You can change the tree.
     * See `Visitor` for more info.
     *
     * @param tree
     *   Tree to traverse.
     * @param test
     *   `unist-util-is`-compatible test
     * @param visitor
     *   Handle each node.
     * @param reverse
     *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
     * @returns
     *   Nothing.
     */
    const visit =
      /**
       * @type {(
       *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
       *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
       * )}
       */
      (
        /**
         * @param {Node} tree
         * @param {Test} test
         * @param {Visitor} visitor
         * @param {boolean | null | undefined} [reverse]
         * @returns {void}
         */
        function (tree, test, visitor, reverse) {
          if (typeof test === 'function' && typeof visitor !== 'function') {
            reverse = visitor;
            visitor = test;
            test = null;
          }

          visitParents(tree, test, overload, reverse);

          /**
           * @param {Node} node
           * @param {Array<Parent>} parents
           */
          function overload(node, parents) {
            const parent = parents[parents.length - 1];
            return visitor(
              node,
              parent ? parent.children.indexOf(node) : null,
              parent
            )
          }
        }
      );

    /**
     * @typedef PointLike
     * @property {number | null | undefined} [line]
     * @property {number | null | undefined} [column]
     * @property {number | null | undefined} [offset]
     *
     * @typedef PositionLike
     * @property {PointLike | null | undefined} [start]
     * @property {PointLike | null | undefined} [end]
     *
     * @typedef NodeLike
     * @property {PositionLike | null | undefined} [position]
     */

    /**
     * Check if `node` is generated.
     *
     * @param {NodeLike | null | undefined} [node]
     *   Node to check.
     * @returns {boolean}
     *   Whether `node` is generated (does not have positional info).
     */
    function generated(node) {
      return (
        !node ||
        !node.position ||
        !node.position.start ||
        !node.position.start.line ||
        !node.position.start.column ||
        !node.position.end ||
        !node.position.end.line ||
        !node.position.end.column
      )
    }

    /**
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').Definition} Definition
     */

    const own$5 = {}.hasOwnProperty;

    /**
     * Find definitions in `tree`.
     *
     * Uses CommonMark precedence, which means that earlier definitions are
     * preferred over duplicate later definitions.
     *
     * @param {Node} tree
     *   Tree to check.
     * @returns {GetDefinition}
     *   Getter.
     */
    function definitions(tree) {
      /** @type {Record<string, Definition>} */
      const cache = Object.create(null);

      if (!tree || !tree.type) {
        throw new Error('mdast-util-definitions expected node')
      }

      visit(tree, 'definition', (definition) => {
        const id = clean(definition.identifier);
        if (id && !own$5.call(cache, id)) {
          cache[id] = definition;
        }
      });

      return definition

      /** @type {GetDefinition} */
      function definition(identifier) {
        const id = clean(identifier);
        // To do: next major: return `undefined` when not found.
        return id && own$5.call(cache, id) ? cache[id] : null
      }
    }

    /**
     * @param {string | null | undefined} [value]
     * @returns {string}
     */
    function clean(value) {
      return String(value || '').toUpperCase()
    }

    /**
     * @typedef {import('hast').Content} HastContent
     * @typedef {import('hast').Element} HastElement
     * @typedef {import('hast').ElementContent} HastElementContent
     * @typedef {import('hast').Properties} HastProperties
     * @typedef {import('hast').Root} HastRoot
     * @typedef {import('hast').Text} HastText
     *
     * @typedef {import('mdast').Content} MdastContent
     * @typedef {import('mdast').Definition} MdastDefinition
     * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition
     * @typedef {import('mdast').Parent} MdastParent
     * @typedef {import('mdast').Root} MdastRoot
     */

    const own$4 = {}.hasOwnProperty;

    /**
     * Create `state` from an mdast tree.
     *
     * @param {MdastNodes} tree
     *   mdast node to transform.
     * @param {Options | null | undefined} [options]
     *   Configuration.
     * @returns {State}
     *   `state` function.
     */
    function createState(tree, options) {
      const settings = options || {};
      const dangerous = settings.allowDangerousHtml || false;
      /** @type {Record<string, MdastFootnoteDefinition>} */
      const footnoteById = {};

      // To do: next major: add `options` to state, remove:
      // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,
      // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,
      // `unknownHandler`.

      // To do: next major: move to `state.options.allowDangerousHtml`.
      state.dangerous = dangerous;
      // To do: next major: move to `state.options`.
      state.clobberPrefix =
        settings.clobberPrefix === undefined || settings.clobberPrefix === null
          ? 'user-content-'
          : settings.clobberPrefix;
      // To do: next major: move to `state.options`.
      state.footnoteLabel = settings.footnoteLabel || 'Footnotes';
      // To do: next major: move to `state.options`.
      state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2';
      // To do: next major: move to `state.options`.
      state.footnoteLabelProperties = settings.footnoteLabelProperties || {
        className: ['sr-only']
      };
      // To do: next major: move to `state.options`.
      state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content';
      // To do: next major: move to `state.options`.
      state.unknownHandler = settings.unknownHandler;
      // To do: next major: move to `state.options`.
      state.passThrough = settings.passThrough;

      state.handlers = {...handlers, ...settings.handlers};

      // To do: next major: replace utility with `definitionById` object, so we
      // only walk once (as we need footnotes too).
      state.definition = definitions(tree);
      state.footnoteById = footnoteById;
      /** @type {Array<string>} */
      state.footnoteOrder = [];
      /** @type {Record<string, number>} */
      state.footnoteCounts = {};

      state.patch = patch;
      state.applyData = applyData;
      state.one = oneBound;
      state.all = allBound;
      state.wrap = wrap;
      // To do: next major: remove `augment`.
      state.augment = augment;

      visit(tree, 'footnoteDefinition', (definition) => {
        const id = String(definition.identifier).toUpperCase();

        // Mimick CM behavior of link definitions.
        // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.
        if (!own$4.call(footnoteById, id)) {
          footnoteById[id] = definition;
        }
      });

      // @ts-expect-error Hush, its fine!
      return state

      /**
       * Finalise the created `right`, a hast node, from `left`, an mdast node.
       *
       * @param {MdastNodeWithData | PositionLike | null | undefined} left
       * @param {HastElementContent} right
       * @returns {HastElementContent}
       */
      /* c8 ignore start */
      // To do: next major: remove.
      function augment(left, right) {
        // Handle `data.hName`, `data.hProperties, `data.hChildren`.
        if (left && 'data' in left && left.data) {
          /** @type {MdastData} */
          const data = left.data;

          if (data.hName) {
            if (right.type !== 'element') {
              right = {
                type: 'element',
                tagName: '',
                properties: {},
                children: []
              };
            }

            right.tagName = data.hName;
          }

          if (right.type === 'element' && data.hProperties) {
            right.properties = {...right.properties, ...data.hProperties};
          }

          if ('children' in right && right.children && data.hChildren) {
            right.children = data.hChildren;
          }
        }

        if (left) {
          const ctx = 'type' in left ? left : {position: left};

          if (!generated(ctx)) {
            // @ts-expect-error: fine.
            right.position = {start: pointStart(ctx), end: pointEnd(ctx)};
          }
        }

        return right
      }
      /* c8 ignore stop */

      /**
       * Create an element for `node`.
       *
       * @type {HFunctionProps}
       */
      /* c8 ignore start */
      // To do: next major: remove.
      function state(node, tagName, props, children) {
        if (Array.isArray(props)) {
          children = props;
          props = {};
        }

        // @ts-expect-error augmenting an element yields an element.
        return augment(node, {
          type: 'element',
          tagName,
          properties: props || {},
          children: children || []
        })
      }
      /* c8 ignore stop */

      /**
       * Transform an mdast node into a hast node.
       *
       * @param {MdastNodes} node
       *   mdast node.
       * @param {MdastParents | null | undefined} [parent]
       *   Parent of `node`.
       * @returns {HastElementContent | Array<HastElementContent> | null | undefined}
       *   Resulting hast node.
       */
      function oneBound(node, parent) {
        // @ts-expect-error: thats a state :)
        return one(state, node, parent)
      }

      /**
       * Transform the children of an mdast node into hast nodes.
       *
       * @param {MdastNodes} parent
       *   mdast node to compile
       * @returns {Array<HastElementContent>}
       *   Resulting hast nodes.
       */
      function allBound(parent) {
        // @ts-expect-error: thats a state :)
        return all(state, parent)
      }
    }

    /**
     * Copy a nodes positional info.
     *
     * @param {MdastNodes} from
     *   mdast node to copy from.
     * @param {HastNodes} to
     *   hast node to copy into.
     * @returns {void}
     *   Nothing.
     */
    function patch(from, to) {
      if (from.position) to.position = position(from);
    }

    /**
     * Honor the `data` of `from` and maybe generate an element instead of `to`.
     *
     * @template {HastNodes} Type
     *   Node type.
     * @param {MdastNodes} from
     *   mdast node to use data from.
     * @param {Type} to
     *   hast node to change.
     * @returns {Type | HastElement}
     *   Nothing.
     */
    function applyData(from, to) {
      /** @type {Type | HastElement} */
      let result = to;

      // Handle `data.hName`, `data.hProperties, `data.hChildren`.
      if (from && from.data) {
        const hName = from.data.hName;
        const hChildren = from.data.hChildren;
        const hProperties = from.data.hProperties;

        if (typeof hName === 'string') {
          // Transforming the node resulted in an element with a different name
          // than wanted:
          if (result.type === 'element') {
            result.tagName = hName;
          }
          // Transforming the node resulted in a non-element, which happens for
          // raw, text, and root nodes (unless custom handlers are passed).
          // The intent is likely to keep the content around (otherwise: pass
          // `hChildren`).
          else {
            result = {
              type: 'element',
              tagName: hName,
              properties: {},
              children: []
            };

            // To do: next major: take the children from the `root`, or inject the
            // raw/text/comment or so into the element?
            // if ('children' in node) {
            //   // @ts-expect-error: assume `children` are allowed in elements.
            //   result.children = node.children
            // } else {
            //   // @ts-expect-error: assume `node` is allowed in elements.
            //   result.children.push(node)
            // }
          }
        }

        if (result.type === 'element' && hProperties) {
          result.properties = {...result.properties, ...hProperties};
        }

        if (
          'children' in result &&
          result.children &&
          hChildren !== null &&
          hChildren !== undefined
        ) {
          // @ts-expect-error: assume valid children are defined.
          result.children = hChildren;
        }
      }

      return result
    }

    /**
     * Transform an mdast node into a hast node.
     *
     * @param {State} state
     *   Info passed around.
     * @param {MdastNodes} node
     *   mdast node.
     * @param {MdastParents | null | undefined} [parent]
     *   Parent of `node`.
     * @returns {HastElementContent | Array<HastElementContent> | null | undefined}
     *   Resulting hast node.
     */
    // To do: next major: do not expose, keep bound.
    function one(state, node, parent) {
      const type = node && node.type;

      // Fail on non-nodes.
      if (!type) {
        throw new Error('Expected node, got `' + node + '`')
      }

      if (own$4.call(state.handlers, type)) {
        return state.handlers[type](state, node, parent)
      }

      if (state.passThrough && state.passThrough.includes(type)) {
        // To do: next major: deep clone.
        // @ts-expect-error: types of passed through nodes are expected to be added manually.
        return 'children' in node ? {...node, children: all(state, node)} : node
      }

      if (state.unknownHandler) {
        return state.unknownHandler(state, node, parent)
      }

      return defaultUnknownHandler(state, node)
    }

    /**
     * Transform the children of an mdast node into hast nodes.
     *
     * @param {State} state
     *   Info passed around.
     * @param {MdastNodes} parent
     *   mdast node to compile
     * @returns {Array<HastElementContent>}
     *   Resulting hast nodes.
     */
    // To do: next major: do not expose, keep bound.
    function all(state, parent) {
      /** @type {Array<HastElementContent>} */
      const values = [];

      if ('children' in parent) {
        const nodes = parent.children;
        let index = -1;
        while (++index < nodes.length) {
          const result = one(state, nodes[index], parent);

          // To do: see if we van clean this? Can we merge texts?
          if (result) {
            if (index && nodes[index - 1].type === 'break') {
              if (!Array.isArray(result) && result.type === 'text') {
                result.value = result.value.replace(/^\s+/, '');
              }

              if (!Array.isArray(result) && result.type === 'element') {
                const head = result.children[0];

                if (head && head.type === 'text') {
                  head.value = head.value.replace(/^\s+/, '');
                }
              }
            }

            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }

      return values
    }

    /**
     * Transform an unknown node.
     *
     * @param {State} state
     *   Info passed around.
     * @param {MdastNodes} node
     *   Unknown mdast node.
     * @returns {HastText | HastElement}
     *   Resulting hast node.
     */
    function defaultUnknownHandler(state, node) {
      const data = node.data || {};
      /** @type {HastText | HastElement} */
      const result =
        'value' in node &&
        !(own$4.call(data, 'hProperties') || own$4.call(data, 'hChildren'))
          ? {type: 'text', value: node.value}
          : {
              type: 'element',
              tagName: 'div',
              properties: {},
              children: all(state, node)
            };

      state.patch(node, result);
      return state.applyData(node, result)
    }

    /**
     * Wrap `nodes` with line endings between each node.
     *
     * @template {HastContent} Type
     *   Node type.
     * @param {Array<Type>} nodes
     *   List of nodes to wrap.
     * @param {boolean | null | undefined} [loose=false]
     *   Whether to add line endings at start and end.
     * @returns {Array<Type | HastText>}
     *   Wrapped nodes.
     */
    function wrap(nodes, loose) {
      /** @type {Array<Type | HastText>} */
      const result = [];
      let index = -1;

      if (loose) {
        result.push({type: 'text', value: '\n'});
      }

      while (++index < nodes.length) {
        if (index) result.push({type: 'text', value: '\n'});
        result.push(nodes[index]);
      }

      if (loose && nodes.length > 0) {
        result.push({type: 'text', value: '\n'});
      }

      return result
    }

    /**
     * @typedef {import('hast').Element} Element
     * @typedef {import('hast').ElementContent} ElementContent
     *
     * @typedef {import('./state.js').State} State
     */

    /**
     * Generate a hast footer for called footnote definitions.
     *
     * @param {State} state
     *   Info passed around.
     * @returns {Element | undefined}
     *   `section` element or `undefined`.
     */
    function footer(state) {
      /** @type {Array<ElementContent>} */
      const listItems = [];
      let index = -1;

      while (++index < state.footnoteOrder.length) {
        const def = state.footnoteById[state.footnoteOrder[index]];

        if (!def) {
          continue
        }

        const content = state.all(def);
        const id = String(def.identifier).toUpperCase();
        const safeId = normalizeUri(id.toLowerCase());
        let referenceIndex = 0;
        /** @type {Array<ElementContent>} */
        const backReferences = [];

        while (++referenceIndex <= state.footnoteCounts[id]) {
          /** @type {Element} */
          const backReference = {
            type: 'element',
            tagName: 'a',
            properties: {
              href:
                '#' +
                state.clobberPrefix +
                'fnref-' +
                safeId +
                (referenceIndex > 1 ? '-' + referenceIndex : ''),
              dataFootnoteBackref: true,
              className: ['data-footnote-backref'],
              ariaLabel: state.footnoteBackLabel
            },
            children: [{type: 'text', value: ''}]
          };

          if (referenceIndex > 1) {
            backReference.children.push({
              type: 'element',
              tagName: 'sup',
              children: [{type: 'text', value: String(referenceIndex)}]
            });
          }

          if (backReferences.length > 0) {
            backReferences.push({type: 'text', value: ' '});
          }

          backReferences.push(backReference);
        }

        const tail = content[content.length - 1];

        if (tail && tail.type === 'element' && tail.tagName === 'p') {
          const tailTail = tail.children[tail.children.length - 1];
          if (tailTail && tailTail.type === 'text') {
            tailTail.value += ' ';
          } else {
            tail.children.push({type: 'text', value: ' '});
          }

          tail.children.push(...backReferences);
        } else {
          content.push(...backReferences);
        }

        /** @type {Element} */
        const listItem = {
          type: 'element',
          tagName: 'li',
          properties: {id: state.clobberPrefix + 'fn-' + safeId},
          children: state.wrap(content, true)
        };

        state.patch(def, listItem);

        listItems.push(listItem);
      }

      if (listItems.length === 0) {
        return
      }

      return {
        type: 'element',
        tagName: 'section',
        properties: {dataFootnotes: true, className: ['footnotes']},
        children: [
          {
            type: 'element',
            tagName: state.footnoteLabelTagName,
            properties: {
              // To do: use structured clone.
              ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
              id: 'footnote-label'
            },
            children: [{type: 'text', value: state.footnoteLabel}]
          },
          {type: 'text', value: '\n'},
          {
            type: 'element',
            tagName: 'ol',
            properties: {},
            children: state.wrap(listItems, true)
          },
          {type: 'text', value: '\n'}
        ]
      }
    }

    /**
     * @typedef {import('hast').Content} HastContent
     * @typedef {import('hast').Root} HastRoot
     *
     * @typedef {import('mdast').Content} MdastContent
     * @typedef {import('mdast').Root} MdastRoot
     *
     * @typedef {import('./state.js').Options} Options
     */

    /**
     * Transform mdast to hast.
     *
     * ##### Notes
     *
     * ###### HTML
     *
     * Raw HTML is available in mdast as `html` nodes and can be embedded in hast
     * as semistandard `raw` nodes.
     * Most utilities ignore `raw` nodes but two notable ones dont:
     *
     * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will
     *     output the raw HTML.
     *     This is typically discouraged as noted by the option name but is useful
     *     if you completely trust authors
     * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them
     *     into standard hast nodes (`element`, `text`, etc).
     *     This is a heavy task as it needs a full HTML parser, but it is the only
     *     way to support untrusted content
     *
     * ###### Footnotes
     *
     * Many options supported here relate to footnotes.
     * Footnotes are not specified by CommonMark, which we follow by default.
     * They are supported by GitHub, so footnotes can be enabled in markdown with
     * `mdast-util-gfm`.
     *
     * The options `footnoteBackLabel` and `footnoteLabel` define natural language
     * that explains footnotes, which is hidden for sighted users but shown to
     * assistive technology.
     * When your page is not in English, you must define translated values.
     *
     * Back references use ARIA attributes, but the section label itself uses a
     * heading that is hidden with an `sr-only` class.
     * To show it to sighted users, define different attributes in
     * `footnoteLabelProperties`.
     *
     * ###### Clobbering
     *
     * Footnotes introduces a problem, as it links footnote calls to footnote
     * definitions on the page through `id` attributes generated from user content,
     * which results in DOM clobbering.
     *
     * DOM clobbering is this:
     *
     * ```html
     * <p id=x></p>
     * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>
     * ```
     *
     * Elements by their ID are made available by browsers on the `window` object,
     * which is a security risk.
     * Using a prefix solves this problem.
     *
     * More information on how to handle clobbering and the prefix is explained in
     * Example: headings (DOM clobbering) in `rehype-sanitize`.
     *
     * ###### Unknown nodes
     *
     * Unknown nodes are nodes with a type that isnt in `handlers` or `passThrough`.
     * The default behavior for unknown nodes is:
     *
     * *   when the node has a `value` (and doesnt have `data.hName`,
     *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`
     *     node
     * *   otherwise, create a `<div>` element (which could be changed with
     *     `data.hName`), with its children mapped from mdast to hast as well
     *
     * This behavior can be changed by passing an `unknownHandler`.
     *
     * @param {MdastNodes} tree
     *   mdast tree.
     * @param {Options | null | undefined} [options]
     *   Configuration.
     * @returns {HastNodes | null | undefined}
     *   hast tree.
     */
    // To do: next major: always return a single `root`.
    function toHast(tree, options) {
      const state = createState(tree, options);
      const node = state.one(tree, null);
      const foot = footer(state);

      if (foot) {
        // @ts-expect-error If theres a footer, there were definitions, meaning block
        // content.
        // So assume `node` is a parent node.
        node.children.push({type: 'text', value: '\n'}, foot);
      }

      // To do: next major: always return root?
      return Array.isArray(node) ? {type: 'root', children: node} : node
    }

    /**
     * @typedef {import('hast').Root} HastRoot
     * @typedef {import('mdast').Root} MdastRoot
     * @typedef {import('mdast-util-to-hast').Options} Options
     * @typedef {import('unified').Processor<any, any, any, any>} Processor
     *
     * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree
     */

    // Note: the `<MdastRoot, HastRoot>` overload doesnt seem to work :'(

    /**
     * Plugin that turns markdown into HTML to support rehype.
     *
     * *   If a destination processor is given, that processor runs with a new HTML
     *     (hast) tree (bridge-mode).
     *     As the given processor runs with a hast tree, and rehype plugins support
     *     hast, that means rehype plugins can be used with the given processor.
     *     The hast tree is discarded in the end.
     *     Its highly unlikely that you want to do this.
     * *   The common case is to not pass a destination processor, in which case the
     *     current processor continues running with a new HTML (hast) tree
     *     (mutate-mode).
     *     As the current processor continues with a hast tree, and rehype plugins
     *     support hast, that means rehype plugins can be used after
     *     `remark-rehype`.
     *     Its likely that this is what you want to do.
     *
     * @param destination
     *   Optional unified processor.
     * @param options
     *   Options passed to `mdast-util-to-hast`.
     */
    const remarkRehype =
      /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
      (
        function (destination, options) {
          return destination && 'run' in destination
            ? bridge(destination, options)
            : mutate(destination || options)
        }
      );

    var remarkRehype$1 = remarkRehype;

    /**
     * Bridge-mode.
     * Runs the destination with the new hast tree.
     *
     * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}
     */
    function bridge(destination, options) {
      return (node, file, next) => {
        destination.run(toHast(node, options), file, (error) => {
          next(error);
        });
      }
    }

    /**
     * Mutate-mode.
     * Further plugins run on the hast tree.
     *
     * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}
     */
    function mutate(options) {
      // @ts-expect-error: assume a corresponding node is returned by `toHast`.
      return (node) => toHast(node, options)
    }

    /**
     * @typedef {import('./info.js').Info} Info
     * @typedef {Record<string, Info>} Properties
     * @typedef {Record<string, string>} Normal
     */

    class Schema {
      /**
       * @constructor
       * @param {Properties} property
       * @param {Normal} normal
       * @param {string} [space]
       */
      constructor(property, normal, space) {
        this.property = property;
        this.normal = normal;
        if (space) {
          this.space = space;
        }
      }
    }

    /** @type {Properties} */
    Schema.prototype.property = {};
    /** @type {Normal} */
    Schema.prototype.normal = {};
    /** @type {string|null} */
    Schema.prototype.space = null;

    /**
     * @typedef {import('./schema.js').Properties} Properties
     * @typedef {import('./schema.js').Normal} Normal
     */

    /**
     * @param {Schema[]} definitions
     * @param {string} [space]
     * @returns {Schema}
     */
    function merge(definitions, space) {
      /** @type {Properties} */
      const property = {};
      /** @type {Normal} */
      const normal = {};
      let index = -1;

      while (++index < definitions.length) {
        Object.assign(property, definitions[index].property);
        Object.assign(normal, definitions[index].normal);
      }

      return new Schema(property, normal, space)
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function normalize(value) {
      return value.toLowerCase()
    }

    class Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       */
      constructor(property, attribute) {
        /** @type {string} */
        this.property = property;
        /** @type {string} */
        this.attribute = attribute;
      }
    }

    /** @type {string|null} */
    Info.prototype.space = null;
    Info.prototype.boolean = false;
    Info.prototype.booleanish = false;
    Info.prototype.overloadedBoolean = false;
    Info.prototype.number = false;
    Info.prototype.commaSeparated = false;
    Info.prototype.spaceSeparated = false;
    Info.prototype.commaOrSpaceSeparated = false;
    Info.prototype.mustUseProperty = false;
    Info.prototype.defined = false;

    let powers = 0;

    const boolean = increment();
    const booleanish = increment();
    const overloadedBoolean = increment();
    const number = increment();
    const spaceSeparated = increment();
    const commaSeparated = increment();
    const commaOrSpaceSeparated = increment();

    function increment() {
      return 2 ** ++powers
    }

    var types = /*#__PURE__*/Object.freeze({
        __proto__: null,
        boolean: boolean,
        booleanish: booleanish,
        overloadedBoolean: overloadedBoolean,
        number: number,
        spaceSeparated: spaceSeparated,
        commaSeparated: commaSeparated,
        commaOrSpaceSeparated: commaOrSpaceSeparated
    });

    /** @type {Array<keyof types>} */
    // @ts-expect-error: hush.
    const checks = Object.keys(types);

    class DefinedInfo extends Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       * @param {number|null} [mask]
       * @param {string} [space]
       */
      constructor(property, attribute, mask, space) {
        let index = -1;

        super(property, attribute);

        mark(this, 'space', space);

        if (typeof mask === 'number') {
          while (++index < checks.length) {
            const check = checks[index];
            mark(this, checks[index], (mask & types[check]) === types[check]);
          }
        }
      }
    }

    DefinedInfo.prototype.defined = true;

    /**
     * @param {DefinedInfo} values
     * @param {string} key
     * @param {unknown} value
     */
    function mark(values, key, value) {
      if (value) {
        // @ts-expect-error: assume `value` matches the expected value of `key`.
        values[key] = value;
      }
    }

    /**
     * @typedef {import('./schema.js').Properties} Properties
     * @typedef {import('./schema.js').Normal} Normal
     *
     * @typedef {Record<string, string>} Attributes
     *
     * @typedef {Object} Definition
     * @property {Record<string, number|null>} properties
     * @property {(attributes: Attributes, property: string) => string} transform
     * @property {string} [space]
     * @property {Attributes} [attributes]
     * @property {Array<string>} [mustUseProperty]
     */

    const own$3 = {}.hasOwnProperty;

    /**
     * @param {Definition} definition
     * @returns {Schema}
     */
    function create(definition) {
      /** @type {Properties} */
      const property = {};
      /** @type {Normal} */
      const normal = {};
      /** @type {string} */
      let prop;

      for (prop in definition.properties) {
        if (own$3.call(definition.properties, prop)) {
          const value = definition.properties[prop];
          const info = new DefinedInfo(
            prop,
            definition.transform(definition.attributes || {}, prop),
            value,
            definition.space
          );

          if (
            definition.mustUseProperty &&
            definition.mustUseProperty.includes(prop)
          ) {
            info.mustUseProperty = true;
          }

          property[prop] = info;

          normal[normalize(prop)] = prop;
          normal[normalize(info.attribute)] = prop;
        }
      }

      return new Schema(property, normal, definition.space)
    }

    const xlink = create({
      space: 'xlink',
      transform(_, prop) {
        return 'xlink:' + prop.slice(5).toLowerCase()
      },
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });

    const xml = create({
      space: 'xml',
      transform(_, prop) {
        return 'xml:' + prop.slice(3).toLowerCase()
      },
      properties: {xmlLang: null, xmlBase: null, xmlSpace: null}
    });

    /**
     * @param {Record<string, string>} attributes
     * @param {string} attribute
     * @returns {string}
     */
    function caseSensitiveTransform(attributes, attribute) {
      return attribute in attributes ? attributes[attribute] : attribute
    }

    /**
     * @param {Record<string, string>} attributes
     * @param {string} property
     * @returns {string}
     */
    function caseInsensitiveTransform(attributes, property) {
      return caseSensitiveTransform(attributes, property.toLowerCase())
    }

    const xmlns = create({
      space: 'xmlns',
      attributes: {xmlnsxlink: 'xmlns:xlink'},
      transform: caseInsensitiveTransform,
      properties: {xmlns: null, xmlnsXLink: null}
    });

    const aria = create({
      transform(_, prop) {
        return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
      },
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
      }
    });

    const html$1 = create({
      space: 'html',
      attributes: {
        acceptcharset: 'accept-charset',
        classname: 'class',
        htmlfor: 'for',
        httpequiv: 'http-equiv'
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,

        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null, // Several. Use CSS `text-align` instead,
        aLink: null, // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated, // `<object>`. List of URIs to archives
        axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null, // `<body>`. Use CSS `background-image` instead
        bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
        border: number, // `<table>`. Use CSS `border-width` instead,
        borderColor: null, // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number, // `<body>`
        cellPadding: null, // `<table>`
        cellSpacing: null, // `<table>`
        char: null, // Several table elements. When `align=char`, sets the character to align on
        charOff: null, // Several table elements. When `char`, offsets the alignment
        classId: null, // `<object>`
        clear: null, // `<br>`. Use CSS `clear` instead
        code: null, // `<object>`
        codeBase: null, // `<object>`
        codeType: null, // `<object>`
        color: null, // `<font>` and `<hr>`. Use CSS instead
        compact: boolean, // Lists. Use CSS to reduce space between items instead
        declare: boolean, // `<object>`
        event: null, // `<script>`
        face: null, // `<font>`. Use CSS instead
        frame: null, // `<table>`
        frameBorder: null, // `<iframe>`. Use CSS `border` instead
        hSpace: number, // `<img>` and `<object>`
        leftMargin: number, // `<body>`
        link: null, // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null, // `<img>`. Use a `<picture>`
        marginHeight: number, // `<body>`
        marginWidth: number, // `<body>`
        noResize: boolean, // `<frame>`
        noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean, // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean, // `<td>` and `<th>`
        object: null, // `<applet>`
        profile: null, // `<head>`
        prompt: null, // `<isindex>`
        rev: null, // `<link>`
        rightMargin: number, // `<body>`
        rules: null, // `<table>`
        scheme: null, // `<meta>`
        scrolling: booleanish, // `<frame>`. Use overflow in the child context
        standby: null, // `<object>`
        summary: null, // `<table>`
        text: null, // `<body>`. Use CSS `color` instead
        topMargin: number, // `<body>`
        valueType: null, // `<param>`
        version: null, // `<html>`. Use a doctype.
        vAlign: null, // Several. Use CSS `vertical-align` instead
        vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number, // `<img>` and `<object>`

        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
      }
    });

    const svg$1 = create({
      space: 'svg',
      attributes: {
        accentHeight: 'accent-height',
        alignmentBaseline: 'alignment-baseline',
        arabicForm: 'arabic-form',
        baselineShift: 'baseline-shift',
        capHeight: 'cap-height',
        className: 'class',
        clipPath: 'clip-path',
        clipRule: 'clip-rule',
        colorInterpolation: 'color-interpolation',
        colorInterpolationFilters: 'color-interpolation-filters',
        colorProfile: 'color-profile',
        colorRendering: 'color-rendering',
        crossOrigin: 'crossorigin',
        dataType: 'datatype',
        dominantBaseline: 'dominant-baseline',
        enableBackground: 'enable-background',
        fillOpacity: 'fill-opacity',
        fillRule: 'fill-rule',
        floodColor: 'flood-color',
        floodOpacity: 'flood-opacity',
        fontFamily: 'font-family',
        fontSize: 'font-size',
        fontSizeAdjust: 'font-size-adjust',
        fontStretch: 'font-stretch',
        fontStyle: 'font-style',
        fontVariant: 'font-variant',
        fontWeight: 'font-weight',
        glyphName: 'glyph-name',
        glyphOrientationHorizontal: 'glyph-orientation-horizontal',
        glyphOrientationVertical: 'glyph-orientation-vertical',
        hrefLang: 'hreflang',
        horizAdvX: 'horiz-adv-x',
        horizOriginX: 'horiz-origin-x',
        horizOriginY: 'horiz-origin-y',
        imageRendering: 'image-rendering',
        letterSpacing: 'letter-spacing',
        lightingColor: 'lighting-color',
        markerEnd: 'marker-end',
        markerMid: 'marker-mid',
        markerStart: 'marker-start',
        navDown: 'nav-down',
        navDownLeft: 'nav-down-left',
        navDownRight: 'nav-down-right',
        navLeft: 'nav-left',
        navNext: 'nav-next',
        navPrev: 'nav-prev',
        navRight: 'nav-right',
        navUp: 'nav-up',
        navUpLeft: 'nav-up-left',
        navUpRight: 'nav-up-right',
        onAbort: 'onabort',
        onActivate: 'onactivate',
        onAfterPrint: 'onafterprint',
        onBeforePrint: 'onbeforeprint',
        onBegin: 'onbegin',
        onCancel: 'oncancel',
        onCanPlay: 'oncanplay',
        onCanPlayThrough: 'oncanplaythrough',
        onChange: 'onchange',
        onClick: 'onclick',
        onClose: 'onclose',
        onCopy: 'oncopy',
        onCueChange: 'oncuechange',
        onCut: 'oncut',
        onDblClick: 'ondblclick',
        onDrag: 'ondrag',
        onDragEnd: 'ondragend',
        onDragEnter: 'ondragenter',
        onDragExit: 'ondragexit',
        onDragLeave: 'ondragleave',
        onDragOver: 'ondragover',
        onDragStart: 'ondragstart',
        onDrop: 'ondrop',
        onDurationChange: 'ondurationchange',
        onEmptied: 'onemptied',
        onEnd: 'onend',
        onEnded: 'onended',
        onError: 'onerror',
        onFocus: 'onfocus',
        onFocusIn: 'onfocusin',
        onFocusOut: 'onfocusout',
        onHashChange: 'onhashchange',
        onInput: 'oninput',
        onInvalid: 'oninvalid',
        onKeyDown: 'onkeydown',
        onKeyPress: 'onkeypress',
        onKeyUp: 'onkeyup',
        onLoad: 'onload',
        onLoadedData: 'onloadeddata',
        onLoadedMetadata: 'onloadedmetadata',
        onLoadStart: 'onloadstart',
        onMessage: 'onmessage',
        onMouseDown: 'onmousedown',
        onMouseEnter: 'onmouseenter',
        onMouseLeave: 'onmouseleave',
        onMouseMove: 'onmousemove',
        onMouseOut: 'onmouseout',
        onMouseOver: 'onmouseover',
        onMouseUp: 'onmouseup',
        onMouseWheel: 'onmousewheel',
        onOffline: 'onoffline',
        onOnline: 'ononline',
        onPageHide: 'onpagehide',
        onPageShow: 'onpageshow',
        onPaste: 'onpaste',
        onPause: 'onpause',
        onPlay: 'onplay',
        onPlaying: 'onplaying',
        onPopState: 'onpopstate',
        onProgress: 'onprogress',
        onRateChange: 'onratechange',
        onRepeat: 'onrepeat',
        onReset: 'onreset',
        onResize: 'onresize',
        onScroll: 'onscroll',
        onSeeked: 'onseeked',
        onSeeking: 'onseeking',
        onSelect: 'onselect',
        onShow: 'onshow',
        onStalled: 'onstalled',
        onStorage: 'onstorage',
        onSubmit: 'onsubmit',
        onSuspend: 'onsuspend',
        onTimeUpdate: 'ontimeupdate',
        onToggle: 'ontoggle',
        onUnload: 'onunload',
        onVolumeChange: 'onvolumechange',
        onWaiting: 'onwaiting',
        onZoom: 'onzoom',
        overlinePosition: 'overline-position',
        overlineThickness: 'overline-thickness',
        paintOrder: 'paint-order',
        panose1: 'panose-1',
        pointerEvents: 'pointer-events',
        referrerPolicy: 'referrerpolicy',
        renderingIntent: 'rendering-intent',
        shapeRendering: 'shape-rendering',
        stopColor: 'stop-color',
        stopOpacity: 'stop-opacity',
        strikethroughPosition: 'strikethrough-position',
        strikethroughThickness: 'strikethrough-thickness',
        strokeDashArray: 'stroke-dasharray',
        strokeDashOffset: 'stroke-dashoffset',
        strokeLineCap: 'stroke-linecap',
        strokeLineJoin: 'stroke-linejoin',
        strokeMiterLimit: 'stroke-miterlimit',
        strokeOpacity: 'stroke-opacity',
        strokeWidth: 'stroke-width',
        tabIndex: 'tabindex',
        textAnchor: 'text-anchor',
        textDecoration: 'text-decoration',
        textRendering: 'text-rendering',
        typeOf: 'typeof',
        underlinePosition: 'underline-position',
        underlineThickness: 'underline-thickness',
        unicodeBidi: 'unicode-bidi',
        unicodeRange: 'unicode-range',
        unitsPerEm: 'units-per-em',
        vAlphabetic: 'v-alphabetic',
        vHanging: 'v-hanging',
        vIdeographic: 'v-ideographic',
        vMathematical: 'v-mathematical',
        vectorEffect: 'vector-effect',
        vertAdvY: 'vert-adv-y',
        vertOriginX: 'vert-origin-x',
        vertOriginY: 'vert-origin-y',
        wordSpacing: 'word-spacing',
        writingMode: 'writing-mode',
        xHeight: 'x-height',
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: 'playbackorder',
        timelineBegin: 'timelinebegin'
      },
      transform: caseSensitiveTransform,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null, // SEMI_COLON_SEPARATED
        keySplines: null, // SEMI_COLON_SEPARATED
        keyTimes: null, // SEMI_COLON_SEPARATED
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });

    /**
     * @typedef {import('./util/schema.js').Schema} Schema
     */

    const valid = /^data[-\w.:]+$/i;
    const dash = /-[a-z]/g;
    const cap = /[A-Z]/g;

    /**
     * @param {Schema} schema
     * @param {string} value
     * @returns {Info}
     */
    function find(schema, value) {
      const normal = normalize(value);
      let prop = value;
      let Type = Info;

      if (normal in schema.normal) {
        return schema.property[schema.normal[normal]]
      }

      if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === '-') {
          // Turn it into a property.
          const rest = value.slice(5).replace(dash, camelcase);
          prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);
        } else {
          // Turn it into an attribute.
          const rest = value.slice(4);

          if (!dash.test(rest)) {
            let dashes = rest.replace(cap, kebab);

            if (dashes.charAt(0) !== '-') {
              dashes = '-' + dashes;
            }

            value = 'data' + dashes;
          }
        }

        Type = DefinedInfo;
      }

      return new Type(prop, value)
    }

    /**
     * @param {string} $0
     * @returns {string}
     */
    function kebab($0) {
      return '-' + $0.toLowerCase()
    }

    /**
     * @param {string} $0
     * @returns {string}
     */
    function camelcase($0) {
      return $0.charAt(1).toUpperCase()
    }

    /**
     * `hast` is close to `React`, but differs in a couple of cases.
     *
     * To get a React property from a hast property, check if it is in
     * `hastToReact`, if it is, then use the corresponding value,
     * otherwise, use the hast property.
     *
     * @type {Record<string, string>}
     */
    const hastToReact = {
      classId: 'classID',
      dataType: 'datatype',
      itemId: 'itemID',
      strokeDashArray: 'strokeDasharray',
      strokeDashOffset: 'strokeDashoffset',
      strokeLineCap: 'strokeLinecap',
      strokeLineJoin: 'strokeLinejoin',
      strokeMiterLimit: 'strokeMiterlimit',
      typeOf: 'typeof',
      xLinkActuate: 'xlinkActuate',
      xLinkArcRole: 'xlinkArcrole',
      xLinkHref: 'xlinkHref',
      xLinkRole: 'xlinkRole',
      xLinkShow: 'xlinkShow',
      xLinkTitle: 'xlinkTitle',
      xLinkType: 'xlinkType',
      xmlnsXLink: 'xmlnsXlink'
    };

    /**
     * @typedef {import('./lib/util/info.js').Info} Info
     * @typedef {import('./lib/util/schema.js').Schema} Schema
     */
    const html = merge([xml, xlink, xmlns, aria, html$1], 'html');
    const svg = merge([xml, xlink, xmlns, aria, svg$1], 'svg');

    /**
     * @typedef {import('unist').Node} Node
     * @typedef {import('hast').Root} Root
     * @typedef {import('hast').Element} Element
     *
     * @callback AllowElement
     * @param {Element} element
     * @param {number} index
     * @param {Element|Root} parent
     * @returns {boolean|undefined}
     *
     * @typedef Options
     * @property {Array<string>} [allowedElements]
     * @property {Array<string>} [disallowedElements=[]]
     * @property {AllowElement} [allowElement]
     * @property {boolean} [unwrapDisallowed=false]
     */

    /**
     * @type {import('unified').Plugin<[Options], Root>}
     */
    function rehypeFilter(options) {
      if (options.allowedElements && options.disallowedElements) {
        throw new TypeError(
          'Only one of `allowedElements` and `disallowedElements` should be defined'
        )
      }

      if (
        options.allowedElements ||
        options.disallowedElements ||
        options.allowElement
      ) {
        return (tree) => {
          visit(tree, 'element', (node, index, parent_) => {
            const parent = /** @type {Element|Root} */ (parent_);
            /** @type {boolean|undefined} */
            let remove;

            if (options.allowedElements) {
              remove = !options.allowedElements.includes(node.tagName);
            } else if (options.disallowedElements) {
              remove = options.disallowedElements.includes(node.tagName);
            }

            if (!remove && options.allowElement && typeof index === 'number') {
              remove = !options.allowElement(node, index, parent);
            }

            if (remove && typeof index === 'number') {
              if (options.unwrapDisallowed && node.children) {
                parent.children.splice(index, 1, ...node.children);
              } else {
                parent.children.splice(index, 1);
              }

              return index
            }

            return undefined
          });
        }
      }
    }

    var reactIs = {exports: {}};

    var reactIs_production_min = {};

    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
    function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;
    reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return v(a)===h};reactIs_production_min.isContextProvider=function(a){return v(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return v(a)===l};reactIs_production_min.isFragment=function(a){return v(a)===d};reactIs_production_min.isLazy=function(a){return v(a)===q};reactIs_production_min.isMemo=function(a){return v(a)===p};
    reactIs_production_min.isPortal=function(a){return v(a)===c};reactIs_production_min.isProfiler=function(a){return v(a)===f};reactIs_production_min.isStrictMode=function(a){return v(a)===e};reactIs_production_min.isSuspense=function(a){return v(a)===m};reactIs_production_min.isSuspenseList=function(a){return v(a)===n};
    reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};reactIs_production_min.typeOf=v;

    {
      reactIs.exports = reactIs_production_min;
    }

    var ReactIs = reactIs.exports;

    /**
     * Check if the given value is *inter-element whitespace*.
     *
     * @param {unknown} thing
     *   Thing to check (typically `Node` or `string`).
     * @returns {boolean}
     *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
     *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
     *   (`\r`), or form feed (`\f`).
     *   If a node is passed it must be a `Text` node, whose `value` field is
     *   checked.
     */
    function whitespace(thing) {
      /** @type {string} */
      const value =
        // @ts-expect-error looks like a node.
        thing && typeof thing === 'object' && thing.type === 'text'
          ? // @ts-expect-error looks like a text.
            thing.value || ''
          : thing;

      // HTML whitespace expression.
      // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
      return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === ''
    }

    /**
     * Parse space-separated tokens to an array of strings.
     *
     * @param {string} value
     *   Space-separated tokens.
     * @returns {Array<string>}
     *   List of tokens.
     */

    /**
     * Serialize an array of strings as space separated-tokens.
     *
     * @param {Array<string|number>} values
     *   List of tokens.
     * @returns {string}
     *   Space-separated tokens.
     */
    function stringify$1(values) {
      return values.join(' ').trim()
    }

    /**
     * @typedef Options
     *   Configuration for `stringify`.
     * @property {boolean} [padLeft=true]
     *   Whether to pad a space before a token.
     * @property {boolean} [padRight=false]
     *   Whether to pad a space after a token.
     */

    /**
     * Serialize an array of strings or numbers to comma-separated tokens.
     *
     * @param {Array<string|number>} values
     *   List of tokens.
     * @param {Options} [options]
     *   Configuration for `stringify` (optional).
     * @returns {string}
     *   Comma-separated tokens.
     */
    function stringify(values, options) {
      const settings = options || {};

      // Ensure the last empty entry is seen.
      const input = values[values.length - 1] === '' ? [...values, ''] : values;

      return input
        .join(
          (settings.padRight ? ' ' : '') +
            ',' +
            (settings.padLeft === false ? '' : ' ')
        )
        .trim()
    }

    var styleToObject = {exports: {}};

    // http://www.w3.org/TR/CSS21/grammar.html
    // https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;

    // declaration
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;

    // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
    var TRIM_REGEX = /^\s+|\s+$/g;

    // strings
    var NEWLINE = '\n';
    var FORWARD_SLASH = '/';
    var ASTERISK = '*';
    var EMPTY_STRING = '';

    // types
    var TYPE_COMMENT = 'comment';
    var TYPE_DECLARATION = 'declaration';

    /**
     * @param {String} style
     * @param {Object} [options]
     * @return {Object[]}
     * @throws {TypeError}
     * @throws {Error}
     */
    var inlineStyleParser = function(style, options) {
      if (typeof style !== 'string') {
        throw new TypeError('First argument must be a string');
      }

      if (!style) return [];

      options = options || {};

      /**
       * Positional.
       */
      var lineno = 1;
      var column = 1;

      /**
       * Update lineno and column based on `str`.
       *
       * @param {String} str
       */
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines) lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }

      /**
       * Mark position and patch `node.position`.
       *
       * @return {Function}
       */
      function position() {
        var start = { line: lineno, column: column };
        return function(node) {
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }

      /**
       * Store position information for a node.
       *
       * @constructor
       * @property {Object} start
       * @property {Object} end
       * @property {undefined|String} source
       */
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column: column };
        this.source = options.source;
      }

      /**
       * Non-enumerable source string.
       */
      Position.prototype.content = style;

      /**
       * Error `msg`.
       *
       * @param {String} msg
       * @throws {Error}
       */
      function error(msg) {
        var err = new Error(
          options.source + ':' + lineno + ':' + column + ': ' + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;

        if (options.silent) ; else {
          throw err;
        }
      }

      /**
       * Match `re` and return captures.
       *
       * @param {RegExp} re
       * @return {undefined|Array}
       */
      function match(re) {
        var m = re.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }

      /**
       * Parse whitespace.
       */
      function whitespace() {
        match(WHITESPACE_REGEX);
      }

      /**
       * Parse comments.
       *
       * @param {Object[]} [rules]
       * @return {Object[]}
       */
      function comments(rules) {
        var c;
        rules = rules || [];
        while ((c = comment())) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }

      /**
       * Parse comment.
       *
       * @return {Object}
       * @throws {Error}
       */
      function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

        var i = 2;
        while (
          EMPTY_STRING != style.charAt(i) &&
          (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
        ) {
          ++i;
        }
        i += 2;

        if (EMPTY_STRING === style.charAt(i - 1)) {
          return error('End of comment missing');
        }

        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;

        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }

      /**
       * Parse declaration.
       *
       * @return {Object}
       * @throws {Error}
       */
      function declaration() {
        var pos = position();

        // prop
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment();

        // :
        if (!match(COLON_REGEX)) return error("property missing ':'");

        // val
        var val = match(VALUE_REGEX);

        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val
            ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
            : EMPTY_STRING
        });

        // ;
        match(SEMICOLON_REGEX);

        return ret;
      }

      /**
       * Parse declarations.
       *
       * @return {Object[]}
       */
      function declarations() {
        var decls = [];

        comments(decls);

        // declarations
        var decl;
        while ((decl = declaration())) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }

        return decls;
      }

      whitespace();
      return declarations();
    };

    /**
     * Trim `str`.
     *
     * @param {String} str
     * @return {String}
     */
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }

    var parse = inlineStyleParser;

    /**
     * Parses inline style to object.
     *
     * @example
     * // returns { 'line-height': '42' }
     * StyleToObject('line-height: 42;');
     *
     * @param  {String}      style      - The inline style.
     * @param  {Function}    [iterator] - The iterator function.
     * @return {null|Object}
     */
    function StyleToObject(style, iterator) {
      var output = null;
      if (!style || typeof style !== 'string') {
        return output;
      }

      var declaration;
      var declarations = parse(style);
      var hasIterator = typeof iterator === 'function';
      var property;
      var value;

      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;

        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }

      return output;
    }

    styleToObject.exports = StyleToObject;
    styleToObject.exports.default = StyleToObject; // ESM support

    var StyleToObject$1 = styleToObject.exports;

    /**
     * @template T
     * @typedef {import('react').ComponentType<T>} ComponentType<T>
     */

    const own$2 = {}.hasOwnProperty;

    // The table-related elements that must not contain whitespace text according
    // to React.
    const tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr']);

    /**
     * @param {Context} context
     * @param {Element|Root} node
     */
    function childrenToReact(context, node) {
      /** @type {Array<ReactNode>} */
      const children = [];
      let childIndex = -1;
      /** @type {Comment|Doctype|Element|Raw|Text} */
      let child;

      while (++childIndex < node.children.length) {
        child = node.children[childIndex];

        if (child.type === 'element') {
          children.push(toReact(context, child, childIndex, node));
        } else if (child.type === 'text') {
          // Currently, a warning is triggered by react for *any* white space in
          // tables.
          // So we drop it.
          // See: <https://github.com/facebook/react/pull/7081>.
          // See: <https://github.com/facebook/react/pull/7515>.
          // See: <https://github.com/remarkjs/remark-react/issues/64>.
          // See: <https://github.com/remarkjs/react-markdown/issues/576>.
          if (
            node.type !== 'element' ||
            !tableElements.has(node.tagName) ||
            !whitespace(child)
          ) {
            children.push(child.value);
          }
        } else if (child.type === 'raw' && !context.options.skipHtml) {
          // Default behavior is to show (encoded) HTML.
          children.push(child.value);
        }
      }

      return children
    }

    /**
     * @param {Context} context
     * @param {Element} node
     * @param {number} index
     * @param {Element|Root} parent
     */
    function toReact(context, node, index, parent) {
      const options = context.options;
      const transform =
        options.transformLinkUri === undefined
          ? uriTransformer
          : options.transformLinkUri;
      const parentSchema = context.schema;
      /** @type {ReactMarkdownNames} */
      // @ts-expect-error assume a known HTML/SVG element.
      const name = node.tagName;
      /** @type {Record<string, unknown>} */
      const properties = {};
      let schema = parentSchema;
      /** @type {string} */
      let property;

      if (parentSchema.space === 'html' && name === 'svg') {
        schema = svg;
        context.schema = schema;
      }

      if (node.properties) {
        for (property in node.properties) {
          if (own$2.call(node.properties, property)) {
            addProperty(properties, property, node.properties[property], context);
          }
        }
      }

      if (name === 'ol' || name === 'ul') {
        context.listDepth++;
      }

      const children = childrenToReact(context, node);

      if (name === 'ol' || name === 'ul') {
        context.listDepth--;
      }

      // Restore parent schema.
      context.schema = parentSchema;

      // Nodes created by plugins do not have positional info, in which case we use
      // an object that matches the position interface.
      const position = node.position || {
        start: {line: null, column: null, offset: null},
        end: {line: null, column: null, offset: null}
      };
      const component =
        options.components && own$2.call(options.components, name)
          ? options.components[name]
          : name;
      const basic = typeof component === 'string' || component === React__default["default"].Fragment;

      if (!ReactIs.isValidElementType(component)) {
        throw new TypeError(
          `Component for name \`${name}\` not defined or is not renderable`
        )
      }

      properties.key = [
        name,
        position.start.line,
        position.start.column,
        index
      ].join('-');

      if (name === 'a' && options.linkTarget) {
        properties.target =
          typeof options.linkTarget === 'function'
            ? options.linkTarget(
                String(properties.href || ''),
                node.children,
                typeof properties.title === 'string' ? properties.title : null
              )
            : options.linkTarget;
      }

      if (name === 'a' && transform) {
        properties.href = transform(
          String(properties.href || ''),
          node.children,
          typeof properties.title === 'string' ? properties.title : null
        );
      }

      if (
        !basic &&
        name === 'code' &&
        parent.type === 'element' &&
        parent.tagName !== 'pre'
      ) {
        properties.inline = true;
      }

      if (
        !basic &&
        (name === 'h1' ||
          name === 'h2' ||
          name === 'h3' ||
          name === 'h4' ||
          name === 'h5' ||
          name === 'h6')
      ) {
        properties.level = Number.parseInt(name.charAt(1), 10);
      }

      if (name === 'img' && options.transformImageUri) {
        properties.src = options.transformImageUri(
          String(properties.src || ''),
          String(properties.alt || ''),
          typeof properties.title === 'string' ? properties.title : null
        );
      }

      if (!basic && name === 'li' && parent.type === 'element') {
        const input = getInputElement(node);
        properties.checked =
          input && input.properties ? Boolean(input.properties.checked) : null;
        properties.index = getElementsBeforeCount(parent, node);
        properties.ordered = parent.tagName === 'ol';
      }

      if (!basic && (name === 'ol' || name === 'ul')) {
        properties.ordered = name === 'ol';
        properties.depth = context.listDepth;
      }

      if (name === 'td' || name === 'th') {
        if (properties.align) {
          if (!properties.style) properties.style = {};
          // @ts-expect-error assume `style` is an object
          properties.style.textAlign = properties.align;
          delete properties.align;
        }

        if (!basic) {
          properties.isHeader = name === 'th';
        }
      }

      if (!basic && name === 'tr' && parent.type === 'element') {
        properties.isHeader = Boolean(parent.tagName === 'thead');
      }

      // If `sourcePos` is given, pass source information (line/column info from markdown source).
      if (options.sourcePos) {
        properties['data-sourcepos'] = flattenPosition(position);
      }

      if (!basic && options.rawSourcePos) {
        properties.sourcePosition = node.position;
      }

      // If `includeElementIndex` is given, pass node index info to components.
      if (!basic && options.includeElementIndex) {
        properties.index = getElementsBeforeCount(parent, node);
        properties.siblingCount = getElementsBeforeCount(parent);
      }

      if (!basic) {
        properties.node = node;
      }

      // Ensure no React warnings are emitted for void elements w/ children.
      return children.length > 0
        ? React__default["default"].createElement(component, properties, children)
        : React__default["default"].createElement(component, properties)
    }

    /**
     * @param {Element|Root} node
     * @returns {Element?}
     */
    function getInputElement(node) {
      let index = -1;

      while (++index < node.children.length) {
        const child = node.children[index];

        if (child.type === 'element' && child.tagName === 'input') {
          return child
        }
      }

      return null
    }

    /**
     * @param {Element|Root} parent
     * @param {Element} [node]
     * @returns {number}
     */
    function getElementsBeforeCount(parent, node) {
      let index = -1;
      let count = 0;

      while (++index < parent.children.length) {
        if (parent.children[index] === node) break
        if (parent.children[index].type === 'element') count++;
      }

      return count
    }

    /**
     * @param {Record<string, unknown>} props
     * @param {string} prop
     * @param {unknown} value
     * @param {Context} ctx
     */
    function addProperty(props, prop, value, ctx) {
      const info = find(ctx.schema, prop);
      let result = value;

      // Ignore nullish and `NaN` values.
      // eslint-disable-next-line no-self-compare
      if (result === null || result === undefined || result !== result) {
        return
      }

      // Accept `array`.
      // Most props are space-separated.
      if (Array.isArray(result)) {
        result = info.commaSeparated ? stringify(result) : stringify$1(result);
      }

      if (info.property === 'style' && typeof result === 'string') {
        result = parseStyle(result);
      }

      if (info.space && info.property) {
        props[
          own$2.call(hastToReact, info.property)
            ? hastToReact[info.property]
            : info.property
        ] = result;
      } else if (info.attribute) {
        props[info.attribute] = result;
      }
    }

    /**
     * @param {string} value
     * @returns {Record<string, string>}
     */
    function parseStyle(value) {
      /** @type {Record<string, string>} */
      const result = {};

      try {
        StyleToObject$1(value, iterator);
      } catch {
        // Silent.
      }

      return result

      /**
       * @param {string} name
       * @param {string} v
       */
      function iterator(name, v) {
        const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name;
        result[k.replace(/-([a-z])/g, styleReplacer)] = v;
      }
    }

    /**
     * @param {unknown} _
     * @param {string} $1
     */
    function styleReplacer(_, $1) {
      return $1.toUpperCase()
    }

    /**
     * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos
     * @returns {string}
     */
    function flattenPosition(pos) {
      return [
        pos.start.line,
        ':',
        pos.start.column,
        '-',
        pos.end.line,
        ':',
        pos.end.column
      ]
        .map(String)
        .join('')
    }

    /**
     * @typedef {import('react').ReactNode} ReactNode
     * @typedef {import('react').ReactElement<{}>} ReactElement
     * @typedef {import('unified').PluggableList} PluggableList
     * @typedef {import('hast').Root} Root
     * @typedef {import('./rehype-filter.js').Options} FilterOptions
     * @typedef {import('./ast-to-react.js').Options} TransformOptions
     *
     * @typedef CoreOptions
     * @property {string} children
     *
     * @typedef PluginOptions
     * @property {PluggableList} [remarkPlugins=[]]
     * @property {PluggableList} [rehypePlugins=[]]
     * @property {import('remark-rehype').Options | undefined} [remarkRehypeOptions={}]
     *
     * @typedef LayoutOptions
     * @property {string} [className]
     *
     * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions
     *
     * @typedef Deprecation
     * @property {string} id
     * @property {string} [to]
     */

    const own$1 = {}.hasOwnProperty;
    const changelog =
      'https://github.com/remarkjs/react-markdown/blob/main/changelog.md';

    /** @type {Record<string, Deprecation>} */
    const deprecated = {
      plugins: {to: 'remarkPlugins', id: 'change-plugins-to-remarkplugins'},
      renderers: {to: 'components', id: 'change-renderers-to-components'},
      astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},
      allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},
      escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},
      source: {to: 'children', id: 'change-source-to-children'},
      allowNode: {
        to: 'allowElement',
        id: 'replace-allownode-allowedtypes-and-disallowedtypes'
      },
      allowedTypes: {
        to: 'allowedElements',
        id: 'replace-allownode-allowedtypes-and-disallowedtypes'
      },
      disallowedTypes: {
        to: 'disallowedElements',
        id: 'replace-allownode-allowedtypes-and-disallowedtypes'
      },
      includeNodeIndex: {
        to: 'includeElementIndex',
        id: 'change-includenodeindex-to-includeelementindex'
      }
    };

    /**
     * React component to render markdown.
     *
     * @param {ReactMarkdownOptions} options
     * @returns {ReactElement}
     */
    function ReactMarkdown(options) {
      for (const key in deprecated) {
        if (own$1.call(deprecated, key) && own$1.call(options, key)) {
          const deprecation = deprecated[key];
          console.warn(
            `[react-markdown] Warning: please ${
          deprecation.to ? `use \`${deprecation.to}\` instead of` : 'remove'
        } \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
          );
          delete deprecated[key];
        }
      }

      const processor = unified()
        .use(remarkParse)
        .use(options.remarkPlugins || [])
        .use(remarkRehype$1, {
          ...options.remarkRehypeOptions,
          allowDangerousHtml: true
        })
        .use(options.rehypePlugins || [])
        .use(rehypeFilter, options);

      const file = new VFile();

      if (typeof options.children === 'string') {
        file.value = options.children;
      } else if (options.children !== undefined && options.children !== null) {
        console.warn(
          `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
        );
      }

      const hastNode = processor.runSync(processor.parse(file), file);

      if (hastNode.type !== 'root') {
        throw new TypeError('Expected a `root` node')
      }

      /** @type {ReactElement} */
      let result = React__default["default"].createElement(
        React__default["default"].Fragment,
        {},
        childrenToReact({options, schema: html, listDepth: 0}, hastNode)
      );

      if (options.className) {
        result = React__default["default"].createElement('div', {className: options.className}, result);
      }

      return result
    }

    ReactMarkdown.propTypes = {
      // Core options:
      children: PropTypes.string,
      // Layout options:
      className: PropTypes.string,
      // Filter options:
      allowElement: PropTypes.func,
      allowedElements: PropTypes.arrayOf(PropTypes.string),
      disallowedElements: PropTypes.arrayOf(PropTypes.string),
      unwrapDisallowed: PropTypes.bool,
      // Plugin options:
      remarkPlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.oneOfType([
              PropTypes.bool,
              PropTypes.string,
              PropTypes.object,
              PropTypes.func,
              PropTypes.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                PropTypes.any
              )
            ])
          )
        ])
      ),
      rehypePlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.oneOfType([
              PropTypes.bool,
              PropTypes.string,
              PropTypes.object,
              PropTypes.func,
              PropTypes.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                PropTypes.any
              )
            ])
          )
        ])
      ),
      // Transform options:
      sourcePos: PropTypes.bool,
      rawSourcePos: PropTypes.bool,
      skipHtml: PropTypes.bool,
      includeElementIndex: PropTypes.bool,
      transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
      linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
      transformImageUri: PropTypes.func,
      components: PropTypes.object
    };

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Previous} Previous
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').Code} Code
     */
    const www = {
      tokenize: tokenizeWww,
      partial: true
    };
    const domain = {
      tokenize: tokenizeDomain,
      partial: true
    };
    const path = {
      tokenize: tokenizePath,
      partial: true
    };
    const punctuation = {
      tokenize: tokenizePunctuation,
      partial: true
    };
    const namedCharacterReference = {
      tokenize: tokenizeNamedCharacterReference,
      partial: true
    };
    const wwwAutolink = {
      tokenize: tokenizeWwwAutolink,
      previous: previousWww
    };
    const httpAutolink = {
      tokenize: tokenizeHttpAutolink,
      previous: previousHttp
    };
    const emailAutolink = {
      tokenize: tokenizeEmailAutolink,
      previous: previousEmail
    };
    /** @type {ConstructRecord} */

    const text = {};
    /** @type {Extension} */

    const gfmAutolinkLiteral = {
      text
    };
    let code = 48; // Add alphanumerics.

    while (code < 123) {
      text[code] = emailAutolink;
      code++;
      if (code === 58) code = 65;
      else if (code === 91) code = 97;
    }

    text[43] = emailAutolink;
    text[45] = emailAutolink;
    text[46] = emailAutolink;
    text[95] = emailAutolink;
    text[72] = [emailAutolink, httpAutolink];
    text[104] = [emailAutolink, httpAutolink];
    text[87] = [emailAutolink, wwwAutolink];
    text[119] = [emailAutolink, wwwAutolink];
    /** @type {Tokenizer} */

    function tokenizeEmailAutolink(effects, ok, nok) {
      const self = this;
      /** @type {boolean} */

      let hasDot;
      /** @type {boolean|undefined} */

      let hasDigitInLastSegment;
      return start
      /** @type {State} */

      function start(code) {
        if (
          !gfmAtext(code) ||
          !previousEmail(self.previous) ||
          previousUnbalanced(self.events)
        ) {
          return nok(code)
        }

        effects.enter('literalAutolink');
        effects.enter('literalAutolinkEmail');
        return atext(code)
      }
      /** @type {State} */

      function atext(code) {
        if (gfmAtext(code)) {
          effects.consume(code);
          return atext
        }

        if (code === 64) {
          effects.consume(code);
          return label
        }

        return nok(code)
      }
      /** @type {State} */

      function label(code) {
        if (code === 46) {
          return effects.check(punctuation, done, dotContinuation)(code)
        }

        if (code === 45 || code === 95) {
          return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)
        }

        if (asciiAlphanumeric(code)) {
          if (!hasDigitInLastSegment && asciiDigit(code)) {
            hasDigitInLastSegment = true;
          }

          effects.consume(code);
          return label
        }

        return done(code)
      }
      /** @type {State} */

      function dotContinuation(code) {
        effects.consume(code);
        hasDot = true;
        hasDigitInLastSegment = undefined;
        return label
      }
      /** @type {State} */

      function dashOrUnderscoreContinuation(code) {
        effects.consume(code);
        return afterDashOrUnderscore
      }
      /** @type {State} */

      function afterDashOrUnderscore(code) {
        if (code === 46) {
          return effects.check(punctuation, nok, dotContinuation)(code)
        }

        return label(code)
      }
      /** @type {State} */

      function done(code) {
        if (hasDot && !hasDigitInLastSegment) {
          effects.exit('literalAutolinkEmail');
          effects.exit('literalAutolink');
          return ok(code)
        }

        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeWwwAutolink(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        if (
          (code !== 87 && code !== 119) ||
          !previousWww(self.previous) ||
          previousUnbalanced(self.events)
        ) {
          return nok(code)
        }

        effects.enter('literalAutolink');
        effects.enter('literalAutolinkWww'); // For `www.` we check instead of attempt, because when it matches, GH
        // treats it as part of a domain (yes, it says a valid domain must come
        // after `www.`, but thats not how its implemented by them).

        return effects.check(
          www,
          effects.attempt(domain, effects.attempt(path, done), nok),
          nok
        )(code)
      }
      /** @type {State} */

      function done(code) {
        effects.exit('literalAutolinkWww');
        effects.exit('literalAutolink');
        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeHttpAutolink(effects, ok, nok) {
      const self = this;
      return start
      /** @type {State} */

      function start(code) {
        if (
          (code !== 72 && code !== 104) ||
          !previousHttp(self.previous) ||
          previousUnbalanced(self.events)
        ) {
          return nok(code)
        }

        effects.enter('literalAutolink');
        effects.enter('literalAutolinkHttp');
        effects.consume(code);
        return t1
      }
      /** @type {State} */

      function t1(code) {
        if (code === 84 || code === 116) {
          effects.consume(code);
          return t2
        }

        return nok(code)
      }
      /** @type {State} */

      function t2(code) {
        if (code === 84 || code === 116) {
          effects.consume(code);
          return p
        }

        return nok(code)
      }
      /** @type {State} */

      function p(code) {
        if (code === 80 || code === 112) {
          effects.consume(code);
          return s
        }

        return nok(code)
      }
      /** @type {State} */

      function s(code) {
        if (code === 83 || code === 115) {
          effects.consume(code);
          return colon
        }

        return colon(code)
      }
      /** @type {State} */

      function colon(code) {
        if (code === 58) {
          effects.consume(code);
          return slash1
        }

        return nok(code)
      }
      /** @type {State} */

      function slash1(code) {
        if (code === 47) {
          effects.consume(code);
          return slash2
        }

        return nok(code)
      }
      /** @type {State} */

      function slash2(code) {
        if (code === 47) {
          effects.consume(code);
          return after
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        return code === null ||
          asciiControl(code) ||
          unicodeWhitespace(code) ||
          unicodePunctuation(code)
          ? nok(code)
          : effects.attempt(domain, effects.attempt(path, done), nok)(code)
      }
      /** @type {State} */

      function done(code) {
        effects.exit('literalAutolinkHttp');
        effects.exit('literalAutolink');
        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeWww(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.consume(code);
        return w2
      }
      /** @type {State} */

      function w2(code) {
        if (code === 87 || code === 119) {
          effects.consume(code);
          return w3
        }

        return nok(code)
      }
      /** @type {State} */

      function w3(code) {
        if (code === 87 || code === 119) {
          effects.consume(code);
          return dot
        }

        return nok(code)
      }
      /** @type {State} */

      function dot(code) {
        if (code === 46) {
          effects.consume(code);
          return after
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        return code === null || markdownLineEnding(code) ? nok(code) : ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeDomain(effects, ok, nok) {
      /** @type {boolean|undefined} */
      let hasUnderscoreInLastSegment;
      /** @type {boolean|undefined} */

      let hasUnderscoreInLastLastSegment;
      return domain
      /** @type {State} */

      function domain(code) {
        if (code === 38) {
          return effects.check(
            namedCharacterReference,
            done,
            punctuationContinuation
          )(code)
        }

        if (code === 46 || code === 95) {
          return effects.check(punctuation, done, punctuationContinuation)(code)
        } // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
        // occur, which sounds like ASCII only, but they also support `www..com`,
        // so thats Unicode.
        // Instead of some new production for Unicode alphanumerics, markdown
        // already has that for Unicode punctuation and whitespace, so use those.

        if (
          code === null ||
          asciiControl(code) ||
          unicodeWhitespace(code) ||
          (code !== 45 && unicodePunctuation(code))
        ) {
          return done(code)
        }

        effects.consume(code);
        return domain
      }
      /** @type {State} */

      function punctuationContinuation(code) {
        if (code === 46) {
          hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
          hasUnderscoreInLastSegment = undefined;
          effects.consume(code);
          return domain
        }

        if (code === 95) hasUnderscoreInLastSegment = true;
        effects.consume(code);
        return domain
      }
      /** @type {State} */

      function done(code) {
        if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
          return ok(code)
        }

        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizePath(effects, ok) {
      let balance = 0;
      return inPath
      /** @type {State} */

      function inPath(code) {
        if (code === 38) {
          return effects.check(
            namedCharacterReference,
            ok,
            continuedPunctuation
          )(code)
        }

        if (code === 40) {
          balance++;
        }

        if (code === 41) {
          return effects.check(
            punctuation,
            parenAtPathEnd,
            continuedPunctuation
          )(code)
        }

        if (pathEnd(code)) {
          return ok(code)
        }

        if (trailingPunctuation(code)) {
          return effects.check(punctuation, ok, continuedPunctuation)(code)
        }

        effects.consume(code);
        return inPath
      }
      /** @type {State} */

      function continuedPunctuation(code) {
        effects.consume(code);
        return inPath
      }
      /** @type {State} */

      function parenAtPathEnd(code) {
        balance--;
        return balance < 0 ? ok(code) : continuedPunctuation(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeNamedCharacterReference(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.consume(code);
        return inside
      }
      /** @type {State} */

      function inside(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return inside
        }

        if (code === 59) {
          effects.consume(code);
          return after
        }

        return nok(code)
      }
      /** @type {State} */

      function after(code) {
        // If the named character reference is followed by the end of the path, its
        // not continued punctuation.
        return pathEnd(code) ? ok(code) : nok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizePunctuation(effects, ok, nok) {
      return start
      /** @type {State} */

      function start(code) {
        effects.consume(code);
        return after
      }
      /** @type {State} */

      function after(code) {
        // Check the next.
        if (trailingPunctuation(code)) {
          effects.consume(code);
          return after
        } // If the punctuation marker is followed by the end of the path, its not
        // continued punctuation.

        return pathEnd(code) ? ok(code) : nok(code)
      }
    }
    /**
     * @param {Code} code
     * @returns {boolean}
     */

    function trailingPunctuation(code) {
      return (
        code === 33 ||
        code === 34 ||
        code === 39 ||
        code === 41 ||
        code === 42 ||
        code === 44 ||
        code === 46 ||
        code === 58 ||
        code === 59 ||
        code === 60 ||
        code === 63 ||
        code === 95 ||
        code === 126
      )
    }
    /**
     * @param {Code} code
     * @returns {boolean}
     */

    function pathEnd(code) {
      return code === null || code === 60 || markdownLineEndingOrSpace(code)
    }
    /**
     * @param {Code} code
     * @returns {boolean}
     */

    function gfmAtext(code) {
      return (
        code === 43 ||
        code === 45 ||
        code === 46 ||
        code === 95 ||
        asciiAlphanumeric(code)
      )
    }
    /** @type {Previous} */

    function previousWww(code) {
      return (
        code === null ||
        code === 40 ||
        code === 42 ||
        code === 95 ||
        code === 126 ||
        markdownLineEndingOrSpace(code)
      )
    }
    /** @type {Previous} */

    function previousHttp(code) {
      return code === null || !asciiAlpha(code)
    }
    /** @type {Previous} */

    function previousEmail(code) {
      return code !== 47 && previousHttp(code)
    }
    /**
     * @param {Array<Event>} events
     * @returns {boolean}
     */

    function previousUnbalanced(events) {
      let index = events.length;
      let result = false;

      while (index--) {
        const token = events[index][1];

        if (
          (token.type === 'labelLink' || token.type === 'labelImage') &&
          !token._balanced
        ) {
          result = true;
          break
        } // @ts-expect-error If weve seen this token, and it was marked as not
        // having any unbalanced bracket before it, we can exit.

        if (token._gfmAutolinkLiteralWalkedInto) {
          result = false;
          break
        }
      }

      if (events.length > 0 && !result) {
        // @ts-expect-error Mark the last token as walked into w/o finding
        // anything.
        events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
      }

      return result
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Exiter} Exiter
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Event} Event
     */
    const indent = {
      tokenize: tokenizeIndent,
      partial: true
    };
    /**
     * @returns {Extension}
     */

    function gfmFootnote() {
      /** @type {Extension} */
      return {
        document: {
          [91]: {
            tokenize: tokenizeDefinitionStart,
            continuation: {
              tokenize: tokenizeDefinitionContinuation
            },
            exit: gfmFootnoteDefinitionEnd
          }
        },
        text: {
          [91]: {
            tokenize: tokenizeGfmFootnoteCall
          },
          [93]: {
            add: 'after',
            tokenize: tokenizePotentialGfmFootnoteCall,
            resolveTo: resolveToPotentialGfmFootnoteCall
          }
        }
      }
    }
    /** @type {Tokenizer} */

    function tokenizePotentialGfmFootnoteCall(effects, ok, nok) {
      const self = this;
      let index = self.events.length;
      /** @type {Array<string>} */
      // @ts-expect-error Its fine!

      const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
      /** @type {Token} */

      let labelStart; // Find an opening.

      while (index--) {
        const token = self.events[index][1];

        if (token.type === 'labelImage') {
          labelStart = token;
          break
        } // Exit if weve walked far enough.

        if (
          token.type === 'gfmFootnoteCall' ||
          token.type === 'labelLink' ||
          token.type === 'label' ||
          token.type === 'image' ||
          token.type === 'link'
        ) {
          break
        }
      }

      return start
      /** @type {State} */

      function start(code) {
        if (!labelStart || !labelStart._balanced) {
          return nok(code)
        }

        const id = normalizeIdentifier(
          self.sliceSerialize({
            start: labelStart.end,
            end: self.now()
          })
        );

        if (id.charCodeAt(0) !== 94 || !defined.includes(id.slice(1))) {
          return nok(code)
        }

        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return ok(code)
      }
    }
    /** @type {Resolver} */

    function resolveToPotentialGfmFootnoteCall(events, context) {
      let index = events.length;

      while (index--) {
        if (
          events[index][1].type === 'labelImage' &&
          events[index][0] === 'enter'
        ) {
          events[index][1];
          break
        }
      }

      // Change the `labelImageMarker` to a `data`.
      events[index + 1][1].type = 'data';
      events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):

      const call = {
        type: 'gfmFootnoteCall',
        start: Object.assign({}, events[index + 3][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      }; // The `^` marker

      const marker = {
        type: 'gfmFootnoteCallMarker',
        start: Object.assign({}, events[index + 3][1].end),
        end: Object.assign({}, events[index + 3][1].end)
      }; // Increment the end 1 character.

      marker.end.column++;
      marker.end.offset++;
      marker.end._bufferIndex++;
      const string = {
        type: 'gfmFootnoteCallString',
        start: Object.assign({}, marker.end),
        end: Object.assign({}, events[events.length - 1][1].start)
      };
      const chunk = {
        type: 'chunkString',
        contentType: 'string',
        start: Object.assign({}, string.start),
        end: Object.assign({}, string.end)
      };
      /** @type {Array<Event>} */

      const replacement = [
        // Take the `labelImageMarker` (now `data`, the `!`)
        events[index + 1],
        events[index + 2],
        ['enter', call, context], // The `[`
        events[index + 3],
        events[index + 4], // The `^`.
        ['enter', marker, context],
        ['exit', marker, context], // Everything in between.
        ['enter', string, context],
        ['enter', chunk, context],
        ['exit', chunk, context],
        ['exit', string, context], // The ending (`]`, properly parsed and labelled).
        events[events.length - 2],
        events[events.length - 1],
        ['exit', call, context]
      ];
      events.splice(index, events.length - index + 1, ...replacement);
      return events
    }
    /** @type {Tokenizer} */

    function tokenizeGfmFootnoteCall(effects, ok, nok) {
      const self = this;
      /** @type {Array<string>} */
      // @ts-expect-error Its fine!

      const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
      let size = 0;
      /** @type {boolean} */

      let data;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('gfmFootnoteCall');
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        return callStart
      }
      /** @type {State} */

      function callStart(code) {
        if (code !== 94) return nok(code)
        effects.enter('gfmFootnoteCallMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallMarker');
        effects.enter('gfmFootnoteCallString');
        effects.enter('chunkString').contentType = 'string';
        return callData
      }
      /** @type {State} */

      function callData(code) {
        /** @type {Token} */
        let token;

        if (code === null || code === 91 || size++ > 999) {
          return nok(code)
        }

        if (code === 93) {
          if (!data) {
            return nok(code)
          }

          effects.exit('chunkString');
          token = effects.exit('gfmFootnoteCallString');
          return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))
            ? end(code)
            : nok(code)
        }

        effects.consume(code);

        if (!markdownLineEndingOrSpace(code)) {
          data = true;
        }

        return code === 92 ? callEscape : callData
      }
      /** @type {State} */

      function callEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return callData
        }

        return callData(code)
      }
      /** @type {State} */

      function end(code) {
        effects.enter('gfmFootnoteCallLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteCallLabelMarker');
        effects.exit('gfmFootnoteCall');
        return ok
      }
    }
    /** @type {Tokenizer} */

    function tokenizeDefinitionStart(effects, ok, nok) {
      const self = this;
      /** @type {Array<string>} */
      // @ts-expect-error Its fine!

      const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
      /** @type {string} */

      let identifier;
      let size = 0;
      /** @type {boolean|undefined} */

      let data;
      return start
      /** @type {State} */

      function start(code) {
        effects.enter('gfmFootnoteDefinition')._container = true;
        effects.enter('gfmFootnoteDefinitionLabel');
        effects.enter('gfmFootnoteDefinitionLabelMarker');
        effects.consume(code);
        effects.exit('gfmFootnoteDefinitionLabelMarker');
        return labelStart
      }
      /** @type {State} */

      function labelStart(code) {
        if (code === 94) {
          effects.enter('gfmFootnoteDefinitionMarker');
          effects.consume(code);
          effects.exit('gfmFootnoteDefinitionMarker');
          effects.enter('gfmFootnoteDefinitionLabelString');
          return atBreak
        }

        return nok(code)
      }
      /** @type {State} */

      function atBreak(code) {
        /** @type {Token} */
        let token;

        if (code === null || code === 91 || size > 999) {
          return nok(code)
        }

        if (code === 93) {
          if (!data) {
            return nok(code)
          }

          token = effects.exit('gfmFootnoteDefinitionLabelString');
          identifier = normalizeIdentifier(self.sliceSerialize(token));
          effects.enter('gfmFootnoteDefinitionLabelMarker');
          effects.consume(code);
          effects.exit('gfmFootnoteDefinitionLabelMarker');
          effects.exit('gfmFootnoteDefinitionLabel');
          return labelAfter
        }

        if (markdownLineEnding(code)) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          size++;
          return atBreak
        }

        effects.enter('chunkString').contentType = 'string';
        return label(code)
      }
      /** @type {State} */

      function label(code) {
        if (
          code === null ||
          markdownLineEnding(code) ||
          code === 91 ||
          code === 93 ||
          size > 999
        ) {
          effects.exit('chunkString');
          return atBreak(code)
        }

        if (!markdownLineEndingOrSpace(code)) {
          data = true;
        }

        size++;
        effects.consume(code);
        return code === 92 ? labelEscape : label
      }
      /** @type {State} */

      function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size++;
          return label
        }

        return label(code)
      }
      /** @type {State} */

      function labelAfter(code) {
        if (code === 58) {
          effects.enter('definitionMarker');
          effects.consume(code);
          effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code
          // is not possible.
          // No space is also fine, just like a block quote marker.

          return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')
        }

        return nok(code)
      }
      /** @type {State} */

      function done(code) {
        if (!defined.includes(identifier)) {
          defined.push(identifier);
        }

        return ok(code)
      }
    }
    /** @type {Tokenizer} */

    function tokenizeDefinitionContinuation(effects, ok, nok) {
      // Either a blank line, which is okay, or an indented thing.
      return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))
    }
    /** @type {Exiter} */

    function gfmFootnoteDefinitionEnd(effects) {
      effects.exit('gfmFootnoteDefinition');
    }
    /** @type {Tokenizer} */

    function tokenizeIndent(effects, ok, nok) {
      const self = this;
      return factorySpace(
        effects,
        afterPrefix,
        'gfmFootnoteDefinitionIndent',
        4 + 1
      )
      /** @type {State} */

      function afterPrefix(code) {
        const tail = self.events[self.events.length - 1];
        return tail &&
          tail[1].type === 'gfmFootnoteDefinitionIndent' &&
          tail[2].sliceSerialize(tail[1], true).length === 4
          ? ok(code)
          : nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Token} Token
     * @typedef {import('micromark-util-types').Event} Event
     */

    /**
     * @param {Options} [options]
     * @returns {Extension}
     */
    function gfmStrikethrough(options = {}) {
      let single = options.singleTilde;
      const tokenizer = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };

      if (single === null || single === undefined) {
        single = true;
      }

      return {
        text: {
          [126]: tokenizer
        },
        insideSpan: {
          null: [tokenizer]
        },
        attentionMarkers: {
          null: [126]
        }
      }
      /**
       * Take events and resolve strikethrough.
       *
       * @type {Resolver}
       */

      function resolveAllStrikethrough(events, context) {
        let index = -1; // Walk through all events.

        while (++index < events.length) {
          // Find a token that can close.
          if (
            events[index][0] === 'enter' &&
            events[index][1].type === 'strikethroughSequenceTemporary' &&
            events[index][1]._close
          ) {
            let open = index; // Now walk back to find an opener.

            while (open--) {
              // Find a token that can open the closer.
              if (
                events[open][0] === 'exit' &&
                events[open][1].type === 'strikethroughSequenceTemporary' &&
                events[open][1]._open && // If the sizes are the same:
                events[index][1].end.offset - events[index][1].start.offset ===
                  events[open][1].end.offset - events[open][1].start.offset
              ) {
                events[index][1].type = 'strikethroughSequence';
                events[open][1].type = 'strikethroughSequence';
                const strikethrough = {
                  type: 'strikethrough',
                  start: Object.assign({}, events[open][1].start),
                  end: Object.assign({}, events[index][1].end)
                };
                const text = {
                  type: 'strikethroughText',
                  start: Object.assign({}, events[open][1].end),
                  end: Object.assign({}, events[index][1].start)
                }; // Opening.

                const nextEvents = [
                  ['enter', strikethrough, context],
                  ['enter', events[open][1], context],
                  ['exit', events[open][1], context],
                  ['enter', text, context]
                ]; // Between.

                splice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll(
                    context.parser.constructs.insideSpan.null,
                    events.slice(open + 1, index),
                    context
                  )
                ); // Closing.

                splice(nextEvents, nextEvents.length, 0, [
                  ['exit', text, context],
                  ['enter', events[index][1], context],
                  ['exit', events[index][1], context],
                  ['exit', strikethrough, context]
                ]);
                splice(events, open - 1, index - open + 3, nextEvents);
                index = open + nextEvents.length - 2;
                break
              }
            }
          }
        }

        index = -1;

        while (++index < events.length) {
          if (events[index][1].type === 'strikethroughSequenceTemporary') {
            events[index][1].type = 'data';
          }
        }

        return events
      }
      /** @type {Tokenizer} */

      function tokenizeStrikethrough(effects, ok, nok) {
        const previous = this.previous;
        const events = this.events;
        let size = 0;
        return start
        /** @type {State} */

        function start(code) {
          if (
            previous === 126 &&
            events[events.length - 1][1].type !== 'characterEscape'
          ) {
            return nok(code)
          }

          effects.enter('strikethroughSequenceTemporary');
          return more(code)
        }
        /** @type {State} */

        function more(code) {
          const before = classifyCharacter(previous);

          if (code === 126) {
            // If this is the third marker, exit.
            if (size > 1) return nok(code)
            effects.consume(code);
            size++;
            return more
          }

          if (size < 2 && !single) return nok(code)
          const token = effects.exit('strikethroughSequenceTemporary');
          const after = classifyCharacter(code);
          token._open = !after || (after === 2 && Boolean(before));
          token._close = !before || (before === 2 && Boolean(after));
          return ok(code)
        }
      }
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').Resolver} Resolver
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Token} Token
     */

    /** @type {Extension} */
    const gfmTable = {
      flow: {
        null: {
          tokenize: tokenizeTable,
          resolve: resolveTable
        }
      }
    };
    const nextPrefixedOrBlank = {
      tokenize: tokenizeNextPrefixedOrBlank,
      partial: true
    };
    /** @type {Resolver} */

    function resolveTable(events, context) {
      let index = -1;
      /** @type {boolean|undefined} */

      let inHead;
      /** @type {boolean|undefined} */

      let inDelimiterRow;
      /** @type {boolean|undefined} */

      let inRow;
      /** @type {number|undefined} */

      let contentStart;
      /** @type {number|undefined} */

      let contentEnd;
      /** @type {number|undefined} */

      let cellStart;
      /** @type {boolean|undefined} */

      let seenCellInRow;

      while (++index < events.length) {
        const token = events[index][1];

        if (inRow) {
          if (token.type === 'temporaryTableCellContent') {
            contentStart = contentStart || index;
            contentEnd = index;
          }

          if (
            // Combine separate content parts into one.
            (token.type === 'tableCellDivider' || token.type === 'tableRow') &&
            contentEnd
          ) {
            const content = {
              type: 'tableContent',
              start: events[contentStart][1].start,
              end: events[contentEnd][1].end
            };
            /** @type {Token} */

            const text = {
              type: 'chunkText',
              start: content.start,
              end: content.end,
              // @ts-expect-error Its fine.
              contentType: 'text'
            };
            events.splice(
              contentStart,
              contentEnd - contentStart + 1,
              ['enter', content, context],
              ['enter', text, context],
              ['exit', text, context],
              ['exit', content, context]
            );
            index -= contentEnd - contentStart - 3;
            contentStart = undefined;
            contentEnd = undefined;
          }
        }

        if (
          events[index][0] === 'exit' &&
          cellStart !== undefined &&
          cellStart + (seenCellInRow ? 0 : 1) < index &&
          (token.type === 'tableCellDivider' ||
            (token.type === 'tableRow' &&
              (cellStart + 3 < index ||
                events[cellStart][1].type !== 'whitespace')))
        ) {
          const cell = {
            type: inDelimiterRow
              ? 'tableDelimiter'
              : inHead
              ? 'tableHeader'
              : 'tableData',
            start: events[cellStart][1].start,
            end: events[index][1].end
          };
          events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [
            'exit',
            cell,
            context
          ]);
          events.splice(cellStart, 0, ['enter', cell, context]);
          index += 2;
          cellStart = index + 1;
          seenCellInRow = true;
        }

        if (token.type === 'tableRow') {
          inRow = events[index][0] === 'enter';

          if (inRow) {
            cellStart = index + 1;
            seenCellInRow = false;
          }
        }

        if (token.type === 'tableDelimiterRow') {
          inDelimiterRow = events[index][0] === 'enter';

          if (inDelimiterRow) {
            cellStart = index + 1;
            seenCellInRow = false;
          }
        }

        if (token.type === 'tableHead') {
          inHead = events[index][0] === 'enter';
        }
      }

      return events
    }
    /** @type {Tokenizer} */

    function tokenizeTable(effects, ok, nok) {
      const self = this;
      /** @type {Array<Align>} */

      const align = [];
      let tableHeaderCount = 0;
      /** @type {boolean|undefined} */

      let seenDelimiter;
      /** @type {boolean|undefined} */

      let hasDash;
      return start
      /** @type {State} */

      function start(code) {
        // @ts-expect-error Custom.
        effects.enter('table')._align = align;
        effects.enter('tableHead');
        effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.

        if (code === 124) {
          return cellDividerHead(code)
        }

        tableHeaderCount++;
        effects.enter('temporaryTableCellContent'); // Cant be space or eols at the start of a construct, so were in a cell.

        return inCellContentHead(code)
      }
      /** @type {State} */

      function cellDividerHead(code) {
        effects.enter('tableCellDivider');
        effects.consume(code);
        effects.exit('tableCellDivider');
        seenDelimiter = true;
        return cellBreakHead
      }
      /** @type {State} */

      function cellBreakHead(code) {
        if (code === null || markdownLineEnding(code)) {
          return atRowEndHead(code)
        }

        if (markdownSpace(code)) {
          effects.enter('whitespace');
          effects.consume(code);
          return inWhitespaceHead
        }

        if (seenDelimiter) {
          seenDelimiter = undefined;
          tableHeaderCount++;
        }

        if (code === 124) {
          return cellDividerHead(code)
        } // Anything else is cell content.

        effects.enter('temporaryTableCellContent');
        return inCellContentHead(code)
      }
      /** @type {State} */

      function inWhitespaceHead(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return inWhitespaceHead
        }

        effects.exit('whitespace');
        return cellBreakHead(code)
      }
      /** @type {State} */

      function inCellContentHead(code) {
        // EOF, whitespace, pipe
        if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
          effects.exit('temporaryTableCellContent');
          return cellBreakHead(code)
        }

        effects.consume(code);
        return code === 92 ? inCellContentEscapeHead : inCellContentHead
      }
      /** @type {State} */

      function inCellContentEscapeHead(code) {
        if (code === 92 || code === 124) {
          effects.consume(code);
          return inCellContentHead
        } // Anything else.

        return inCellContentHead(code)
      }
      /** @type {State} */

      function atRowEndHead(code) {
        if (code === null) {
          return nok(code)
        }

        effects.exit('tableRow');
        effects.exit('tableHead');
        const originalInterrupt = self.interrupt;
        self.interrupt = true;
        return effects.attempt(
          {
            tokenize: tokenizeRowEnd,
            partial: true
          },
          function (code) {
            self.interrupt = originalInterrupt;
            effects.enter('tableDelimiterRow');
            return atDelimiterRowBreak(code)
          },
          function (code) {
            self.interrupt = originalInterrupt;
            return nok(code)
          }
        )(code)
      }
      /** @type {State} */

      function atDelimiterRowBreak(code) {
        if (code === null || markdownLineEnding(code)) {
          return rowEndDelimiter(code)
        }

        if (markdownSpace(code)) {
          effects.enter('whitespace');
          effects.consume(code);
          return inWhitespaceDelimiter
        }

        if (code === 45) {
          effects.enter('tableDelimiterFiller');
          effects.consume(code);
          hasDash = true;
          align.push('none');
          return inFillerDelimiter
        }

        if (code === 58) {
          effects.enter('tableDelimiterAlignment');
          effects.consume(code);
          effects.exit('tableDelimiterAlignment');
          align.push('left');
          return afterLeftAlignment
        } // If we start with a pipe, we open a cell marker.

        if (code === 124) {
          effects.enter('tableCellDivider');
          effects.consume(code);
          effects.exit('tableCellDivider');
          return atDelimiterRowBreak
        }

        return nok(code)
      }
      /** @type {State} */

      function inWhitespaceDelimiter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return inWhitespaceDelimiter
        }

        effects.exit('whitespace');
        return atDelimiterRowBreak(code)
      }
      /** @type {State} */

      function inFillerDelimiter(code) {
        if (code === 45) {
          effects.consume(code);
          return inFillerDelimiter
        }

        effects.exit('tableDelimiterFiller');

        if (code === 58) {
          effects.enter('tableDelimiterAlignment');
          effects.consume(code);
          effects.exit('tableDelimiterAlignment');
          align[align.length - 1] =
            align[align.length - 1] === 'left' ? 'center' : 'right';
          return afterRightAlignment
        }

        return atDelimiterRowBreak(code)
      }
      /** @type {State} */

      function afterLeftAlignment(code) {
        if (code === 45) {
          effects.enter('tableDelimiterFiller');
          effects.consume(code);
          hasDash = true;
          return inFillerDelimiter
        } // Anything else is not ok.

        return nok(code)
      }
      /** @type {State} */

      function afterRightAlignment(code) {
        if (code === null || markdownLineEnding(code)) {
          return rowEndDelimiter(code)
        }

        if (markdownSpace(code)) {
          effects.enter('whitespace');
          effects.consume(code);
          return inWhitespaceDelimiter
        } // `|`

        if (code === 124) {
          effects.enter('tableCellDivider');
          effects.consume(code);
          effects.exit('tableCellDivider');
          return atDelimiterRowBreak
        }

        return nok(code)
      }
      /** @type {State} */

      function rowEndDelimiter(code) {
        effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the
        // delimiter cell count.

        if (!hasDash || tableHeaderCount !== align.length) {
          return nok(code)
        }

        if (code === null) {
          return tableClose(code)
        }

        return effects.check(
          nextPrefixedOrBlank,
          tableClose,
          effects.attempt(
            {
              tokenize: tokenizeRowEnd,
              partial: true
            },
            factorySpace(effects, bodyStart, 'linePrefix', 4),
            tableClose
          )
        )(code)
      }
      /** @type {State} */

      function tableClose(code) {
        effects.exit('table');
        return ok(code)
      }
      /** @type {State} */

      function bodyStart(code) {
        effects.enter('tableBody');
        return rowStartBody(code)
      }
      /** @type {State} */

      function rowStartBody(code) {
        effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.

        if (code === 124) {
          return cellDividerBody(code)
        }

        effects.enter('temporaryTableCellContent'); // Cant be space or eols at the start of a construct, so were in a cell.

        return inCellContentBody(code)
      }
      /** @type {State} */

      function cellDividerBody(code) {
        effects.enter('tableCellDivider');
        effects.consume(code);
        effects.exit('tableCellDivider');
        return cellBreakBody
      }
      /** @type {State} */

      function cellBreakBody(code) {
        if (code === null || markdownLineEnding(code)) {
          return atRowEndBody(code)
        }

        if (markdownSpace(code)) {
          effects.enter('whitespace');
          effects.consume(code);
          return inWhitespaceBody
        } // `|`

        if (code === 124) {
          return cellDividerBody(code)
        } // Anything else is cell content.

        effects.enter('temporaryTableCellContent');
        return inCellContentBody(code)
      }
      /** @type {State} */

      function inWhitespaceBody(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return inWhitespaceBody
        }

        effects.exit('whitespace');
        return cellBreakBody(code)
      }
      /** @type {State} */

      function inCellContentBody(code) {
        // EOF, whitespace, pipe
        if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
          effects.exit('temporaryTableCellContent');
          return cellBreakBody(code)
        }

        effects.consume(code);
        return code === 92 ? inCellContentEscapeBody : inCellContentBody
      }
      /** @type {State} */

      function inCellContentEscapeBody(code) {
        if (code === 92 || code === 124) {
          effects.consume(code);
          return inCellContentBody
        } // Anything else.

        return inCellContentBody(code)
      }
      /** @type {State} */

      function atRowEndBody(code) {
        effects.exit('tableRow');

        if (code === null) {
          return tableBodyClose(code)
        }

        return effects.check(
          nextPrefixedOrBlank,
          tableBodyClose,
          effects.attempt(
            {
              tokenize: tokenizeRowEnd,
              partial: true
            },
            factorySpace(effects, rowStartBody, 'linePrefix', 4),
            tableBodyClose
          )
        )(code)
      }
      /** @type {State} */

      function tableBodyClose(code) {
        effects.exit('tableBody');
        return tableClose(code)
      }
      /** @type {Tokenizer} */

      function tokenizeRowEnd(effects, ok, nok) {
        return start
        /** @type {State} */

        function start(code) {
          effects.enter('lineEnding');
          effects.consume(code);
          effects.exit('lineEnding');
          return factorySpace(effects, prefixed, 'linePrefix')
        }
        /** @type {State} */

        function prefixed(code) {
          // Blank or interrupting line.
          if (
            self.parser.lazy[self.now().line] ||
            code === null ||
            markdownLineEnding(code)
          ) {
            return nok(code)
          }

          const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.

          if (
            !self.parser.constructs.disable.null.includes('codeIndented') &&
            tail &&
            tail[1].type === 'linePrefix' &&
            tail[2].sliceSerialize(tail[1], true).length >= 4
          ) {
            return nok(code)
          }

          self._gfmTableDynamicInterruptHack = true;
          return effects.check(
            self.parser.constructs.flow,
            function (code) {
              self._gfmTableDynamicInterruptHack = false;
              return nok(code)
            },
            function (code) {
              self._gfmTableDynamicInterruptHack = false;
              return ok(code)
            }
          )(code)
        }
      }
    }
    /** @type {Tokenizer} */

    function tokenizeNextPrefixedOrBlank(effects, ok, nok) {
      let size = 0;
      return start
      /** @type {State} */

      function start(code) {
        // This is a check, so we dont care about tokens, but we open a bogus one
        // so were valid.
        effects.enter('check'); // EOL.

        effects.consume(code);
        return whitespace
      }
      /** @type {State} */

      function whitespace(code) {
        if (code === -1 || code === 32) {
          effects.consume(code);
          size++;
          return size === 4 ? ok : whitespace
        } // EOF or whitespace

        if (code === null || markdownLineEndingOrSpace(code)) {
          return ok(code)
        } // Anything else.

        return nok(code)
      }
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
     * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
     * @typedef {import('micromark-util-types').Previous} Previous
     * @typedef {import('micromark-util-types').State} State
     * @typedef {import('micromark-util-types').Event} Event
     * @typedef {import('micromark-util-types').Code} Code
     */
    const tasklistCheck = {
      tokenize: tokenizeTasklistCheck
    };
    const gfmTaskListItem = {
      text: {
        [91]: tasklistCheck
      }
    };
    /** @type {Tokenizer} */

    function tokenizeTasklistCheck(effects, ok, nok) {
      const self = this;
      return open
      /** @type {State} */

      function open(code) {
        if (
          // Exit if theres stuff before.
          self.previous !== null || // Exit if not in the first content that is the first child of a list
          // item.
          !self._gfmTasklistFirstContentOfListItem
        ) {
          return nok(code)
        }

        effects.enter('taskListCheck');
        effects.enter('taskListCheckMarker');
        effects.consume(code);
        effects.exit('taskListCheckMarker');
        return inside
      }
      /** @type {State} */

      function inside(code) {
        // To match how GH works in comments, use `markdownSpace` (`[ \t]`) instead
        // of `markdownLineEndingOrSpace` (`[ \t\r\n]`).
        if (markdownLineEndingOrSpace(code)) {
          effects.enter('taskListCheckValueUnchecked');
          effects.consume(code);
          effects.exit('taskListCheckValueUnchecked');
          return close
        }

        if (code === 88 || code === 120) {
          effects.enter('taskListCheckValueChecked');
          effects.consume(code);
          effects.exit('taskListCheckValueChecked');
          return close
        }

        return nok(code)
      }
      /** @type {State} */

      function close(code) {
        if (code === 93) {
          effects.enter('taskListCheckMarker');
          effects.consume(code);
          effects.exit('taskListCheckMarker');
          effects.exit('taskListCheck');
          return effects.check(
            {
              tokenize: spaceThenNonSpace
            },
            ok,
            nok
          )
        }

        return nok(code)
      }
    }
    /** @type {Tokenizer} */

    function spaceThenNonSpace(effects, ok, nok) {
      const self = this;
      return factorySpace(effects, after, 'whitespace')
      /** @type {State} */

      function after(code) {
        const tail = self.events[self.events.length - 1];
        return (
          // We either found spaces
          ((tail && tail[1].type === 'whitespace') || // or it was followed by a line ending, in which case, there has to be
            // non-whitespace after that line ending, because otherwise wed get an
            // EOF as the content is closed with blank lines.
            markdownLineEnding(code)) &&
            code !== null
            ? ok(code)
            : nok(code)
        )
      }
    }

    /**
     * @typedef {import('micromark-util-types').Extension} Extension
     * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
     * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options
     * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions
     */

    /**
     * Support GFM or markdown on github.com.
     *
     * @param {Options} [options]
     * @returns {Extension}
     */
    function gfm(options) {
      return combineExtensions([
        gfmAutolinkLiteral,
        gfmFootnote(),
        gfmStrikethrough(options),
        gfmTable,
        gfmTaskListItem
      ])
    }

    /**
     * Count how often a character (or substring) is used in a string.
     *
     * @param {string} value
     *   Value to search in.
     * @param {string} character
     *   Character (or substring) to look for.
     * @return {number}
     *   Number of times `character` occurred in `value`.
     */
    function ccount(value, character) {
      const source = String(value);

      if (typeof character !== 'string') {
        throw new TypeError('Expected character')
      }

      let count = 0;
      let index = source.indexOf(character);

      while (index !== -1) {
        count++;
        index = source.indexOf(character, index + character.length);
      }

      return count
    }

    function escapeStringRegexp(string) {
    	if (typeof string !== 'string') {
    		throw new TypeError('Expected a string');
    	}

    	// Escape characters with special meaning either inside or outside character sets.
    	// Use a simple backslash escape when its always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    	return string
    		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
    		.replace(/-/g, '\\x2d');
    }

    /**
     * @typedef {import('mdast').Parent} MdastParent
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').PhrasingContent} PhrasingContent
     * @typedef {import('mdast').Text} Text
     * @typedef {import('unist-util-visit-parents').Test} Test
     * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
     */

    const own = {}.hasOwnProperty;

    /**
     * Find patterns in a tree and replace them.
     *
     * The algorithm searches the tree in *preorder* for complete values in `Text`
     * nodes.
     * Partial matches are not supported.
     *
     * @param tree
     *   Tree to change.
     * @param find
     *   Patterns to find.
     * @param replace
     *   Things to replace with (when `find` is `Find`) or configuration.
     * @param options
     *   Configuration (when `find` is not `Find`).
     * @returns
     *   Given, modified, tree.
     */
    // To do: next major: remove `find` & `replace` combo, remove schema.
    const findAndReplace =
      /**
       * @type {(
       *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &
       *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)
       * )}
       **/
      (
        /**
         * @template {Node} Tree
         * @param {Tree} tree
         * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
         * @param {Replace | Options | null | undefined} [replace]
         * @param {Options | null | undefined} [options]
         * @returns {Tree}
         */
        function (tree, find, replace, options) {
          /** @type {Options | null | undefined} */
          let settings;
          /** @type {FindAndReplaceSchema|FindAndReplaceList} */
          let schema;

          if (typeof find === 'string' || find instanceof RegExp) {
            // @ts-expect-error dont expect options twice.
            schema = [[find, replace]];
            settings = options;
          } else {
            schema = find;
            // @ts-expect-error dont expect replace twice.
            settings = replace;
          }

          if (!settings) {
            settings = {};
          }

          const ignored = convert(settings.ignore || []);
          const pairs = toPairs(schema);
          let pairIndex = -1;

          while (++pairIndex < pairs.length) {
            visitParents(tree, 'text', visitor);
          }

          // To do next major: dont return the given tree.
          return tree

          /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */
          function visitor(node, parents) {
            let index = -1;
            /** @type {Parent | undefined} */
            let grandparent;

            while (++index < parents.length) {
              const parent = parents[index];

              if (
                ignored(
                  parent,
                  // @ts-expect-error: TS doesnt understand but its perfect.
                  grandparent ? grandparent.children.indexOf(parent) : undefined,
                  grandparent
                )
              ) {
                return
              }

              grandparent = parent;
            }

            if (grandparent) {
              return handler(node, parents)
            }
          }

          /**
           * Handle a text node which is not in an ignored parent.
           *
           * @param {Text} node
           *   Text node.
           * @param {Array<Parent>} parents
           *   Parents.
           * @returns {VisitorResult}
           *   Result.
           */
          function handler(node, parents) {
            const parent = parents[parents.length - 1];
            const find = pairs[pairIndex][0];
            const replace = pairs[pairIndex][1];
            let start = 0;
            // @ts-expect-error: TS is wrong, some of these children can be text.
            const index = parent.children.indexOf(node);
            let change = false;
            /** @type {Array<PhrasingContent>} */
            let nodes = [];

            find.lastIndex = 0;

            let match = find.exec(node.value);

            while (match) {
              const position = match.index;
              /** @type {RegExpMatchObject} */
              const matchObject = {
                index: match.index,
                input: match.input,
                // @ts-expect-error: stack is fine.
                stack: [...parents, node]
              };
              let value = replace(...match, matchObject);

              if (typeof value === 'string') {
                value = value.length > 0 ? {type: 'text', value} : undefined;
              }

              // It wasnt a match after all.
              if (value !== false) {
                if (start !== position) {
                  nodes.push({
                    type: 'text',
                    value: node.value.slice(start, position)
                  });
                }

                if (Array.isArray(value)) {
                  nodes.push(...value);
                } else if (value) {
                  nodes.push(value);
                }

                start = position + match[0].length;
                change = true;
              }

              if (!find.global) {
                break
              }

              match = find.exec(node.value);
            }

            if (change) {
              if (start < node.value.length) {
                nodes.push({type: 'text', value: node.value.slice(start)});
              }

              parent.children.splice(index, 1, ...nodes);
            } else {
              nodes = [node];
            }

            return index + nodes.length
          }
        }
      );

    /**
     * Turn a schema into pairs.
     *
     * @param {FindAndReplaceSchema | FindAndReplaceList} schema
     *   Schema.
     * @returns {Pairs}
     *   Clean pairs.
     */
    function toPairs(schema) {
      /** @type {Pairs} */
      const result = [];

      if (typeof schema !== 'object') {
        throw new TypeError('Expected array or object as schema')
      }

      if (Array.isArray(schema)) {
        let index = -1;

        while (++index < schema.length) {
          result.push([
            toExpression(schema[index][0]),
            toFunction(schema[index][1])
          ]);
        }
      } else {
        /** @type {string} */
        let key;

        for (key in schema) {
          if (own.call(schema, key)) {
            result.push([toExpression(key), toFunction(schema[key])]);
          }
        }
      }

      return result
    }

    /**
     * Turn a find into an expression.
     *
     * @param {Find} find
     *   Find.
     * @returns {RegExp}
     *   Expression.
     */
    function toExpression(find) {
      return typeof find === 'string' ? new RegExp(escapeStringRegexp(find), 'g') : find
    }

    /**
     * Turn a replace into a function.
     *
     * @param {Replace} replace
     *   Replace.
     * @returns {ReplaceFunction}
     *   Function.
     */
    function toFunction(replace) {
      return typeof replace === 'function' ? replace : () => replace
    }

    /**
     * @typedef {import('mdast').Link} Link
     * @typedef {import('mdast').PhrasingContent} PhrasingContent
     *
     * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
     * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform
     *
     * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     *
     * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction
     * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject
     */

    /** @type {ConstructName} */
    const inConstruct = 'phrasing';
    /** @type {Array<ConstructName>} */
    const notInConstruct = ['autolink', 'link', 'image', 'label'];

    // To do: next major: expose functions instead of extensions.

    /**
     * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.
     *
     * @type {FromMarkdownExtension}
     */
    const gfmAutolinkLiteralFromMarkdown = {
      transforms: [transformGfmAutolinkLiterals],
      enter: {
        literalAutolink: enterLiteralAutolink,
        literalAutolinkEmail: enterLiteralAutolinkValue,
        literalAutolinkHttp: enterLiteralAutolinkValue,
        literalAutolinkWww: enterLiteralAutolinkValue
      },
      exit: {
        literalAutolink: exitLiteralAutolink,
        literalAutolinkEmail: exitLiteralAutolinkEmail,
        literalAutolinkHttp: exitLiteralAutolinkHttp,
        literalAutolinkWww: exitLiteralAutolinkWww
      }
    };

    /**
     * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
     *
     * @type {ToMarkdownExtension}
     */
    const gfmAutolinkLiteralToMarkdown = {
      unsafe: [
        {
          character: '@',
          before: '[+\\-.\\w]',
          after: '[\\-.\\w]',
          inConstruct,
          notInConstruct
        },
        {
          character: '.',
          before: '[Ww]',
          after: '[\\-.\\w]',
          inConstruct,
          notInConstruct
        },
        {character: ':', before: '[ps]', after: '\\/', inConstruct, notInConstruct}
      ]
    };

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterLiteralAutolink(token) {
      this.enter({type: 'link', title: null, url: '', children: []}, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterLiteralAutolinkValue(token) {
      this.config.enter.autolinkProtocol.call(this, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitLiteralAutolinkHttp(token) {
      this.config.exit.autolinkProtocol.call(this, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitLiteralAutolinkWww(token) {
      this.config.exit.data.call(this, token);
      const node = /** @type {Link} */ (this.stack[this.stack.length - 1]);
      node.url = 'http://' + this.sliceSerialize(token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitLiteralAutolinkEmail(token) {
      this.config.exit.autolinkEmail.call(this, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitLiteralAutolink(token) {
      this.exit(token);
    }

    /** @type {FromMarkdownTransform} */
    function transformGfmAutolinkLiterals(tree) {
      findAndReplace(
        tree,
        [
          [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
          [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
        ],
        {ignore: ['link', 'linkReference']}
      );
    }

    /**
     * @type {ReplaceFunction}
     * @param {string} _
     * @param {string} protocol
     * @param {string} domain
     * @param {string} path
     * @param {RegExpMatchObject} match
     * @returns {Link | Array<PhrasingContent> | false}
     */
    // eslint-disable-next-line max-params
    function findUrl(_, protocol, domain, path, match) {
      let prefix = '';

      // Not an expected previous character.
      if (!previous(match)) {
        return false
      }

      // Treat `www` as part of the domain.
      if (/^w/i.test(protocol)) {
        domain = protocol + domain;
        protocol = '';
        prefix = 'http://';
      }

      if (!isCorrectDomain(domain)) {
        return false
      }

      const parts = splitUrl(domain + path);

      if (!parts[0]) return false

      /** @type {Link} */
      const result = {
        type: 'link',
        title: null,
        url: prefix + protocol + parts[0],
        children: [{type: 'text', value: protocol + parts[0]}]
      };

      if (parts[1]) {
        return [result, {type: 'text', value: parts[1]}]
      }

      return result
    }

    /**
     * @type {ReplaceFunction}
     * @param {string} _
     * @param {string} atext
     * @param {string} label
     * @param {RegExpMatchObject} match
     * @returns {Link | false}
     */
    function findEmail(_, atext, label, match) {
      if (
        // Not an expected previous character.
        !previous(match, true) ||
        // Label ends in not allowed character.
        /[-\d_]$/.test(label)
      ) {
        return false
      }

      return {
        type: 'link',
        title: null,
        url: 'mailto:' + atext + '@' + label,
        children: [{type: 'text', value: atext + '@' + label}]
      }
    }

    /**
     * @param {string} domain
     * @returns {boolean}
     */
    function isCorrectDomain(domain) {
      const parts = domain.split('.');

      if (
        parts.length < 2 ||
        (parts[parts.length - 1] &&
          (/_/.test(parts[parts.length - 1]) ||
            !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
        (parts[parts.length - 2] &&
          (/_/.test(parts[parts.length - 2]) ||
            !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
      ) {
        return false
      }

      return true
    }

    /**
     * @param {string} url
     * @returns {[string, string | undefined]}
     */
    function splitUrl(url) {
      const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);

      if (!trailExec) {
        return [url, undefined]
      }

      url = url.slice(0, trailExec.index);

      let trail = trailExec[0];
      let closingParenIndex = trail.indexOf(')');
      const openingParens = ccount(url, '(');
      let closingParens = ccount(url, ')');

      while (closingParenIndex !== -1 && openingParens > closingParens) {
        url += trail.slice(0, closingParenIndex + 1);
        trail = trail.slice(closingParenIndex + 1);
        closingParenIndex = trail.indexOf(')');
        closingParens++;
      }

      return [url, trail]
    }

    /**
     * @param {RegExpMatchObject} match
     * @param {boolean | null | undefined} [email=false]
     * @returns {boolean}
     */
    function previous(match, email) {
      const code = match.input.charCodeAt(match.index - 1);

      return (
        (match.index === 0 ||
          unicodeWhitespace(code) ||
          unicodePunctuation(code)) &&
        (!email || code !== 47)
      )
    }

    /**
     * @typedef {import('../types.js').AssociationId} AssociationId
     */

    /**
     * Get an identifier from an association to match it to others.
     *
     * Associations are nodes that match to something else through an ID:
     * <https://github.com/syntax-tree/mdast#association>.
     *
     * The `label` of an association is the string value: character escapes and
     * references work, and casing is intact.
     * The `identifier` is used to match one association to another:
     * controversially, character escapes and references dont work in this
     * matching: `&copy;` does not match ``, and `\+` does not match `+`.
     *
     * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\nb`
     * matches `a b`.
     * So, we do prefer the label when figuring out how were going to serialize:
     * it has whitespace, casing, and we can ignore most useless character
     * escapes and all character references.
     *
     * @type {AssociationId}
     */
    function association(node) {
      if (node.label || !node.identifier) {
        return node.label || ''
      }

      return decodeString(node.identifier)
    }

    /**
     * @typedef {import('../types.js').FlowContent} FlowContent
     * @typedef {import('../types.js').Node} Node
     * @typedef {import('../types.js').Parent} Parent
     * @typedef {import('../types.js').State} State
     * @typedef {import('../types.js').TrackFields} TrackFields
     */

    /**
     * @param {Parent & {children: Array<FlowContent>}} parent
     *   Parent of flow nodes.
     * @param {State} state
     *   Info passed around about the current state.
     * @param {TrackFields} info
     *   Info on where we are in the document we are generating.
     * @returns {string}
     *   Serialized children, joined by (blank) lines.
     */
    function containerFlow(parent, state, info) {
      const indexStack = state.indexStack;
      const children = parent.children || [];
      const tracker = state.createTracker(info);
      /** @type {Array<string>} */
      const results = [];
      let index = -1;

      indexStack.push(-1);

      while (++index < children.length) {
        const child = children[index];

        indexStack[indexStack.length - 1] = index;

        results.push(
          tracker.move(
            state.handle(child, parent, state, {
              before: '\n',
              after: '\n',
              ...tracker.current()
            })
          )
        );

        if (child.type !== 'list') {
          state.bulletLastUsed = undefined;
        }

        if (index < children.length - 1) {
          results.push(
            tracker.move(between(child, children[index + 1], parent, state))
          );
        }
      }

      indexStack.pop();

      return results.join('')
    }

    /**
     * @param {Node} left
     * @param {Node} right
     * @param {Parent} parent
     * @param {State} state
     * @returns {string}
     */
    function between(left, right, parent, state) {
      let index = state.join.length;

      while (index--) {
        const result = state.join[index](left, right, parent, state);

        if (result === true || result === 1) {
          break
        }

        if (typeof result === 'number') {
          return '\n'.repeat(1 + result)
        }

        if (result === false) {
          return '\n\n<!---->\n\n'
        }
      }

      return '\n\n'
    }

    /**
     * @typedef {import('../types.js').IndentLines} IndentLines
     */

    const eol = /\r?\n|\r/g;

    /**
     * @type {IndentLines}
     */
    function indentLines(value, map) {
      /** @type {Array<string>} */
      const result = [];
      let start = 0;
      let line = 0;
      /** @type {RegExpExecArray | null} */
      let match;

      while ((match = eol.exec(value))) {
        one(value.slice(start, match.index));
        result.push(match[0]);
        start = match.index + match[0].length;
        line++;
      }

      one(value.slice(start));

      return result.join('')

      /**
       * @param {string} value
       */
      function one(value) {
        result.push(map(value, line, !value));
      }
    }

    /**
     * @typedef {import('../types.js').Unsafe} Unsafe
     */

    /**
     * @param {Unsafe} pattern
     * @returns {RegExp}
     */
    function patternCompile(pattern) {
      if (!pattern._compiled) {
        const before =
          (pattern.atBreak ? '[\\r\\n][\\t ]*' : '') +
          (pattern.before ? '(?:' + pattern.before + ')' : '');

        pattern._compiled = new RegExp(
          (before ? '(' + before + ')' : '') +
            (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') +
            pattern.character +
            (pattern.after ? '(?:' + pattern.after + ')' : ''),
          'g'
        );
      }

      return pattern._compiled
    }

    /**
     * @typedef {import('../types.js').Unsafe} Unsafe
     * @typedef {import('../types.js').ConstructName} ConstructName
     */

    /**
     * @param {Array<ConstructName>} stack
     * @param {Unsafe} pattern
     * @returns {boolean}
     */
    function patternInScope(stack, pattern) {
      return (
        listInScope(stack, pattern.inConstruct, true) &&
        !listInScope(stack, pattern.notInConstruct, false)
      )
    }

    /**
     * @param {Array<ConstructName>} stack
     * @param {Unsafe['inConstruct']} list
     * @param {boolean} none
     * @returns {boolean}
     */
    function listInScope(stack, list, none) {
      if (typeof list === 'string') {
        list = [list];
      }

      if (!list || list.length === 0) {
        return none
      }

      let index = -1;

      while (++index < list.length) {
        if (stack.includes(list[index])) {
          return true
        }
      }

      return false
    }

    /**
     * @typedef {import('../types.js').State} State
     * @typedef {import('../types.js').SafeConfig} SafeConfig
     */

    /**
     * Make a string safe for embedding in markdown constructs.
     *
     * In markdown, almost all punctuation characters can, in certain cases,
     * result in something.
     * Whether they do is highly subjective to where they happen and in what
     * they happen.
     *
     * To solve this, `mdast-util-to-markdown` tracks:
     *
     * * Characters before and after something;
     * * What constructs we are in.
     *
     * This information is then used by this function to escape or encode
     * special characters.
     *
     * @param {State} state
     *   Info passed around about the current state.
     * @param {string | null | undefined} input
     *   Raw value to make safe.
     * @param {SafeConfig} config
     *   Configuration.
     * @returns {string}
     *   Serialized markdown safe for embedding.
     */
    function safe(state, input, config) {
      const value = (config.before || '') + (input || '') + (config.after || '');
      /** @type {Array<number>} */
      const positions = [];
      /** @type {Array<string>} */
      const result = [];
      /** @type {Record<number, {before: boolean, after: boolean}>} */
      const infos = {};
      let index = -1;

      while (++index < state.unsafe.length) {
        const pattern = state.unsafe[index];

        if (!patternInScope(state.stack, pattern)) {
          continue
        }

        const expression = patternCompile(pattern);
        /** @type {RegExpExecArray | null} */
        let match;

        while ((match = expression.exec(value))) {
          const before = 'before' in pattern || Boolean(pattern.atBreak);
          const after = 'after' in pattern;
          const position = match.index + (before ? match[1].length : 0);

          if (positions.includes(position)) {
            if (infos[position].before && !before) {
              infos[position].before = false;
            }

            if (infos[position].after && !after) {
              infos[position].after = false;
            }
          } else {
            positions.push(position);
            infos[position] = {before, after};
          }
        }
      }

      positions.sort(numerical);

      let start = config.before ? config.before.length : 0;
      const end = value.length - (config.after ? config.after.length : 0);
      index = -1;

      while (++index < positions.length) {
        const position = positions[index];

        // Character before or after matched:
        if (position < start || position >= end) {
          continue
        }

        // If this character is supposed to be escaped because it has a condition on
        // the next character, and the next character is definitly being escaped,
        // then skip this escape.
        if (
          (position + 1 < end &&
            positions[index + 1] === position + 1 &&
            infos[position].after &&
            !infos[position + 1].before &&
            !infos[position + 1].after) ||
          (positions[index - 1] === position - 1 &&
            infos[position].before &&
            !infos[position - 1].before &&
            !infos[position - 1].after)
        ) {
          continue
        }

        if (start !== position) {
          // If we have to use a character reference, an ampersand would be more
          // correct, but as backslashes only care about punctuation, either will
          // do the trick
          result.push(escapeBackslashes(value.slice(start, position), '\\'));
        }

        start = position;

        if (
          /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&
          (!config.encode || !config.encode.includes(value.charAt(position)))
        ) {
          // Character escape.
          result.push('\\');
        } else {
          // Character reference.
          result.push(
            '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'
          );
          start++;
        }
      }

      result.push(escapeBackslashes(value.slice(start, end), config.after));

      return result.join('')
    }

    /**
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    function numerical(a, b) {
      return a - b
    }

    /**
     * @param {string} value
     * @param {string} after
     * @returns {string}
     */
    function escapeBackslashes(value, after) {
      const expression = /\\(?=[!-/:-@[-`{-~])/g;
      /** @type {Array<number>} */
      const positions = [];
      /** @type {Array<string>} */
      const results = [];
      const whole = value + after;
      let index = -1;
      let start = 0;
      /** @type {RegExpExecArray | null} */
      let match;

      while ((match = expression.exec(whole))) {
        positions.push(match.index);
      }

      while (++index < positions.length) {
        if (start !== positions[index]) {
          results.push(value.slice(start, positions[index]));
        }

        results.push('\\');
        start = positions[index];
      }

      results.push(value.slice(start));

      return results.join('')
    }

    /**
     * @typedef {import('../types.js').CreateTracker} CreateTracker
     * @typedef {import('../types.js').TrackCurrent} TrackCurrent
     * @typedef {import('../types.js').TrackMove} TrackMove
     * @typedef {import('../types.js').TrackShift} TrackShift
     */

    /**
     * Track positional info in the output.
     *
     * @type {CreateTracker}
     */
    function track(config) {
      // Defaults are used to prevent crashes when older utilities somehow activate
      // this code.
      /* c8 ignore next 5 */
      const options = config || {};
      const now = options.now || {};
      let lineShift = options.lineShift || 0;
      let line = now.line || 1;
      let column = now.column || 1;

      return {move, current, shift}

      /**
       * Get the current tracked info.
       *
       * @type {TrackCurrent}
       */
      function current() {
        return {now: {line, column}, lineShift}
      }

      /**
       * Define an increased line shift (the typical indent for lines).
       *
       * @type {TrackShift}
       */
      function shift(value) {
        lineShift += value;
      }

      /**
       * Move past some generated markdown.
       *
       * @type {TrackMove}
       */
      function move(input) {
        // eslint-disable-next-line unicorn/prefer-default-parameters
        const value = input || '';
        const chunks = value.split(/\r?\n|\r/g);
        const tail = chunks[chunks.length - 1];
        line += chunks.length - 1;
        column =
          chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
        return value
      }
    }

    /**
     * @typedef {import('mdast').FootnoteReference} FootnoteReference
     * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
     * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
     * @typedef {import('mdast-util-to-markdown').Map} Map
     */

    footnoteReference.peek = footnoteReferencePeek;

    // To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use
    // utilities on `state`.

    /**
     * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes
     * in markdown.
     *
     * @returns {FromMarkdownExtension}
     *   Extension for `mdast-util-from-markdown`.
     */
    function gfmFootnoteFromMarkdown() {
      return {
        enter: {
          gfmFootnoteDefinition: enterFootnoteDefinition,
          gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
          gfmFootnoteCall: enterFootnoteCall,
          gfmFootnoteCallString: enterFootnoteCallString
        },
        exit: {
          gfmFootnoteDefinition: exitFootnoteDefinition,
          gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
          gfmFootnoteCall: exitFootnoteCall,
          gfmFootnoteCallString: exitFootnoteCallString
        }
      }
    }

    /**
     * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes
     * in markdown.
     *
     * @returns {ToMarkdownExtension}
     *   Extension for `mdast-util-to-markdown`.
     */
    function gfmFootnoteToMarkdown() {
      return {
        // This is on by default already.
        unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],
        handlers: {footnoteDefinition, footnoteReference}
      }
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterFootnoteDefinition(token) {
      this.enter(
        {type: 'footnoteDefinition', identifier: '', label: '', children: []},
        token
      );
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterFootnoteDefinitionLabelString() {
      this.buffer();
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitFootnoteDefinitionLabelString(token) {
      const label = this.resume();
      const node = /** @type {FootnoteDefinition} */ (
        this.stack[this.stack.length - 1]
      );
      node.label = label;
      node.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitFootnoteDefinition(token) {
      this.exit(token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterFootnoteCall(token) {
      this.enter({type: 'footnoteReference', identifier: '', label: ''}, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterFootnoteCallString() {
      this.buffer();
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitFootnoteCallString(token) {
      const label = this.resume();
      const node = /** @type {FootnoteDefinition} */ (
        this.stack[this.stack.length - 1]
      );
      node.label = label;
      node.identifier = normalizeIdentifier(
        this.sliceSerialize(token)
      ).toLowerCase();
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitFootnoteCall(token) {
      this.exit(token);
    }

    /**
     * @type {ToMarkdownHandle}
     * @param {FootnoteReference} node
     */
    function footnoteReference(node, _, context, safeOptions) {
      const tracker = track(safeOptions);
      let value = tracker.move('[^');
      const exit = context.enter('footnoteReference');
      const subexit = context.enter('reference');
      value += tracker.move(
        safe(context, association(node), {
          ...tracker.current(),
          before: value,
          after: ']'
        })
      );
      subexit();
      exit();
      value += tracker.move(']');
      return value
    }

    /** @type {ToMarkdownHandle} */
    function footnoteReferencePeek() {
      return '['
    }

    /**
     * @type {ToMarkdownHandle}
     * @param {FootnoteDefinition} node
     */
    function footnoteDefinition(node, _, context, safeOptions) {
      const tracker = track(safeOptions);
      let value = tracker.move('[^');
      const exit = context.enter('footnoteDefinition');
      const subexit = context.enter('label');
      value += tracker.move(
        safe(context, association(node), {
          ...tracker.current(),
          before: value,
          after: ']'
        })
      );
      subexit();
      value += tracker.move(
        ']:' + (node.children && node.children.length > 0 ? ' ' : '')
      );
      tracker.shift(4);
      value += tracker.move(
        indentLines(containerFlow(node, context, tracker.current()), map)
      );
      exit();

      return value
    }

    /** @type {Map} */
    function map(line, index, blank) {
      if (index === 0) {
        return line
      }

      return (blank ? '' : '    ') + line
    }

    /**
     * @typedef {import('../types.js').Handle} Handle
     * @typedef {import('../types.js').Info} Info
     * @typedef {import('../types.js').Parent} Parent
     * @typedef {import('../types.js').PhrasingContent} PhrasingContent
     * @typedef {import('../types.js').State} State
     */

    /**
     * Serialize the children of a parent that contains phrasing children.
     *
     * These children will be joined flush together.
     *
     * @param {Parent & {children: Array<PhrasingContent>}} parent
     *   Parent of flow nodes.
     * @param {State} state
     *   Info passed around about the current state.
     * @param {Info} info
     *   Info on where we are in the document we are generating.
     * @returns {string}
     *   Serialized children, joined together.
     */
    function containerPhrasing(parent, state, info) {
      const indexStack = state.indexStack;
      const children = parent.children || [];
      /** @type {Array<string>} */
      const results = [];
      let index = -1;
      let before = info.before;

      indexStack.push(-1);
      let tracker = state.createTracker(info);

      while (++index < children.length) {
        const child = children[index];
        /** @type {string} */
        let after;

        indexStack[indexStack.length - 1] = index;

        if (index + 1 < children.length) {
          /** @type {Handle} */
          // @ts-expect-error: hush, its actually a `zwitch`.
          let handle = state.handle.handlers[children[index + 1].type];
          /** @type {Handle} */
          // @ts-expect-error: hush, its actually a `zwitch`.
          if (handle && handle.peek) handle = handle.peek;
          after = handle
            ? handle(children[index + 1], parent, state, {
                before: '',
                after: '',
                ...tracker.current()
              }).charAt(0)
            : '';
        } else {
          after = info.after;
        }

        // In some cases, html (text) can be found in phrasing right after an eol.
        // When wed serialize that, in most cases that would be seen as html
        // (flow).
        // As we cant escape or so to prevent it from happening, we take a somewhat
        // reasonable approach: replace that eol with a space.
        // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
        if (
          results.length > 0 &&
          (before === '\r' || before === '\n') &&
          child.type === 'html'
        ) {
          results[results.length - 1] = results[results.length - 1].replace(
            /(\r?\n|\r)$/,
            ' '
          );
          before = ' ';

          // To do: does this work to reset tracker?
          tracker = state.createTracker(info);
          tracker.move(results.join(''));
        }

        results.push(
          tracker.move(
            state.handle(child, parent, state, {
              ...tracker.current(),
              before,
              after
            })
          )
        );

        before = results[results.length - 1].slice(-1);
      }

      indexStack.pop();

      return results.join('')
    }

    /**
     * @typedef {import('mdast').Delete} Delete
     *
     * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
     *
     * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
     */

    // To do: next major: expose functions.
    // To do: next major: use `state`, state utilities.

    /**
     * List of constructs that occur in phrasing (paragraphs, headings), but cannot
     * contain strikethrough.
     * So they sort of cancel each other out.
     * Note: could use a better name.
     *
     * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>
     *
     * @type {Array<ConstructName>}
     */
    const constructsWithoutStrikethrough = [
      'autolink',
      'destinationLiteral',
      'destinationRaw',
      'reference',
      'titleQuote',
      'titleApostrophe'
    ];

    handleDelete.peek = peekDelete;

    /**
     * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.
     *
     * @type {FromMarkdownExtension}
     */
    const gfmStrikethroughFromMarkdown = {
      canContainEols: ['delete'],
      enter: {strikethrough: enterStrikethrough},
      exit: {strikethrough: exitStrikethrough}
    };

    /**
     * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.
     *
     * @type {ToMarkdownExtension}
     */
    const gfmStrikethroughToMarkdown = {
      unsafe: [
        {
          character: '~',
          inConstruct: 'phrasing',
          notInConstruct: constructsWithoutStrikethrough
        }
      ],
      handlers: {delete: handleDelete}
    };

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterStrikethrough(token) {
      this.enter({type: 'delete', children: []}, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitStrikethrough(token) {
      this.exit(token);
    }

    /**
     * @type {ToMarkdownHandle}
     * @param {Delete} node
     */
    function handleDelete(node, _, context, safeOptions) {
      const tracker = track(safeOptions);
      const exit = context.enter('strikethrough');
      let value = tracker.move('~~');
      value += containerPhrasing(node, context, {
        ...tracker.current(),
        before: value,
        after: '~'
      });
      value += tracker.move('~~');
      exit();
      return value
    }

    /** @type {ToMarkdownHandle} */
    function peekDelete() {
      return '~'
    }

    /**
     * @typedef {import('mdast').InlineCode} InlineCode
     * @typedef {import('../types.js').Parent} Parent
     * @typedef {import('../types.js').State} State
     */

    inlineCode.peek = inlineCodePeek;

    /**
     * @param {InlineCode} node
     * @param {Parent | undefined} _
     * @param {State} state
     * @returns {string}
     */
    function inlineCode(node, _, state) {
      let value = node.value || '';
      let sequence = '`';
      let index = -1;

      // If there is a single grave accent on its own in the code, use a fence of
      // two.
      // If there are two in a row, use one.
      while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
        sequence += '`';
      }

      // If this is not just spaces or eols (tabs dont count), and either the
      // first or last character are a space, eol, or tick, then pad with spaces.
      if (
        /[^ \r\n]/.test(value) &&
        ((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
      ) {
        value = ' ' + value + ' ';
      }

      // We have a potential problem: certain characters after eols could result in
      // blocks being seen.
      // For example, if someone injected the string `'\n# b'`, then that would
      // result in an ATX heading.
      // We cant escape characters in `inlineCode`, but because eols are
      // transformed to spaces when going from markdown to HTML anyway, we can swap
      // them out.
      while (++index < state.unsafe.length) {
        const pattern = state.unsafe[index];
        const expression = patternCompile(pattern);
        /** @type {RegExpExecArray | null} */
        let match;

        // Only look for `atBreak`s.
        // Btw: note that `atBreak` patterns will always start the regex at LF or
        // CR.
        if (!pattern.atBreak) continue

        while ((match = expression.exec(value))) {
          let position = match.index;

          // Support CRLF (patterns only look for one of the characters).
          if (
            value.charCodeAt(position) === 10 /* `\n` */ &&
            value.charCodeAt(position - 1) === 13 /* `\r` */
          ) {
            position--;
          }

          value = value.slice(0, position) + ' ' + value.slice(match.index + 1);
        }
      }

      return sequence + value + sequence
    }

    /**
     * @returns {string}
     */
    function inlineCodePeek() {
      return '`'
    }

    /**
     * @typedef Options
     *   Configuration (optional).
     * @property {string|null|ReadonlyArray<string|null|undefined>} [align]
     *   One style for all columns, or styles for their respective columns.
     *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).
     *   Other values are treated as `''`, which doesnt place the colon in the
     *   alignment row but does align left.
     *   *Only the lowercased first character is used, so `Right` is fine.*
     * @property {boolean} [padding=true]
     *   Whether to add a space of padding between delimiters and cells.
     *
     *   When `true`, there is padding:
     *
     *   ```markdown
     *   | Alpha | B     |
     *   | ----- | ----- |
     *   | C     | Delta |
     *   ```
     *
     *   When `false`, there is no padding:
     *
     *   ```markdown
     *   |Alpha|B    |
     *   |-----|-----|
     *   |C    |Delta|
     *   ```
     * @property {boolean} [delimiterStart=true]
     *   Whether to begin each row with the delimiter.
     *
     *   >  **Note**: please dont use this: it could create fragile structures
     *   > that arent understandable to some markdown parsers.
     *
     *   When `true`, there are starting delimiters:
     *
     *   ```markdown
     *   | Alpha | B     |
     *   | ----- | ----- |
     *   | C     | Delta |
     *   ```
     *
     *   When `false`, there are no starting delimiters:
     *
     *   ```markdown
     *   Alpha | B     |
     *   ----- | ----- |
     *   C     | Delta |
     *   ```
     * @property {boolean} [delimiterEnd=true]
     *   Whether to end each row with the delimiter.
     *
     *   >  **Note**: please dont use this: it could create fragile structures
     *   > that arent understandable to some markdown parsers.
     *
     *   When `true`, there are ending delimiters:
     *
     *   ```markdown
     *   | Alpha | B     |
     *   | ----- | ----- |
     *   | C     | Delta |
     *   ```
     *
     *   When `false`, there are no ending delimiters:
     *
     *   ```markdown
     *   | Alpha | B
     *   | ----- | -----
     *   | C     | Delta
     *   ```
     * @property {boolean} [alignDelimiters=true]
     *   Whether to align the delimiters.
     *   By default, they are aligned:
     *
     *   ```markdown
     *   | Alpha | B     |
     *   | ----- | ----- |
     *   | C     | Delta |
     *   ```
     *
     *   Pass `false` to make them staggered:
     *
     *   ```markdown
     *   | Alpha | B |
     *   | - | - |
     *   | C | Delta |
     *   ```
     * @property {(value: string) => number} [stringLength]
     *   Function to detect the length of table cell content.
     *   This is used when aligning the delimiters (`|`) between table cells.
     *   Full-width characters and emoji mess up delimiter alignment when viewing
     *   the markdown source.
     *   To fix this, you can pass this function, which receives the cell content
     *   and returns its visible size.
     *   Note that what is and isnt visible depends on where the text is displayed.
     *
     *   Without such a function, the following:
     *
     *   ```js
     *   markdownTable([
     *     ['Alpha', 'Bravo'],
     *     ['', 'Charlie'],
     *     ['', 'Delta']
     *   ])
     *   ```
     *
     *   Yields:
     *
     *   ```markdown
     *   | Alpha | Bravo |
     *   | - | - |
     *   |  | Charlie |
     *   |  | Delta |
     *   ```
     *
     *   With [`string-width`](https://github.com/sindresorhus/string-width):
     *
     *   ```js
     *   import stringWidth from 'string-width'
     *
     *   markdownTable(
     *     [
     *       ['Alpha', 'Bravo'],
     *       ['', 'Charlie'],
     *       ['', 'Delta']
     *     ],
     *     {stringLength: stringWidth}
     *   )
     *   ```
     *
     *   Yields:
     *
     *   ```markdown
     *   | Alpha | Bravo   |
     *   | ----- | ------- |
     *   |   | Charlie |
     *   |     | Delta   |
     *   ```
     */

    /**
     * @typedef {Options} MarkdownTableOptions
     * @todo
     *   Remove next major.
     */

    /**
     * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..
     *
     * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table
     *   Table data (matrix of strings).
     * @param {Options} [options]
     *   Configuration (optional).
     * @returns {string}
     */
    function markdownTable(table, options = {}) {
      const align = (options.align || []).concat();
      const stringLength = options.stringLength || defaultStringLength;
      /** @type {Array<number>} Character codes as symbols for alignment per column. */
      const alignments = [];
      /** @type {Array<Array<string>>} Cells per row. */
      const cellMatrix = [];
      /** @type {Array<Array<number>>} Sizes of each cell per row. */
      const sizeMatrix = [];
      /** @type {Array<number>} */
      const longestCellByColumn = [];
      let mostCellsPerRow = 0;
      let rowIndex = -1;

      // This is a superfluous loop if we dont align delimiters, but otherwise wed
      // do superfluous work when aligning, so optimize for aligning.
      while (++rowIndex < table.length) {
        /** @type {Array<string>} */
        const row = [];
        /** @type {Array<number>} */
        const sizes = [];
        let columnIndex = -1;

        if (table[rowIndex].length > mostCellsPerRow) {
          mostCellsPerRow = table[rowIndex].length;
        }

        while (++columnIndex < table[rowIndex].length) {
          const cell = serialize(table[rowIndex][columnIndex]);

          if (options.alignDelimiters !== false) {
            const size = stringLength(cell);
            sizes[columnIndex] = size;

            if (
              longestCellByColumn[columnIndex] === undefined ||
              size > longestCellByColumn[columnIndex]
            ) {
              longestCellByColumn[columnIndex] = size;
            }
          }

          row.push(cell);
        }

        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
      }

      // Figure out which alignments to use.
      let columnIndex = -1;

      if (typeof align === 'object' && 'length' in align) {
        while (++columnIndex < mostCellsPerRow) {
          alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
      } else {
        const code = toAlignment(align);

        while (++columnIndex < mostCellsPerRow) {
          alignments[columnIndex] = code;
        }
      }

      // Inject the alignment row.
      columnIndex = -1;
      /** @type {Array<string>} */
      const row = [];
      /** @type {Array<number>} */
      const sizes = [];

      while (++columnIndex < mostCellsPerRow) {
        const code = alignments[columnIndex];
        let before = '';
        let after = '';

        if (code === 99 /* `c` */) {
          before = ':';
          after = ':';
        } else if (code === 108 /* `l` */) {
          before = ':';
        } else if (code === 114 /* `r` */) {
          after = ':';
        }

        // There *must* be at least one hyphen-minus in each alignment cell.
        let size =
          options.alignDelimiters === false
            ? 1
            : Math.max(
                1,
                longestCellByColumn[columnIndex] - before.length - after.length
              );

        const cell = before + '-'.repeat(size) + after;

        if (options.alignDelimiters !== false) {
          size = before.length + size + after.length;

          if (size > longestCellByColumn[columnIndex]) {
            longestCellByColumn[columnIndex] = size;
          }

          sizes[columnIndex] = size;
        }

        row[columnIndex] = cell;
      }

      // Inject the alignment row.
      cellMatrix.splice(1, 0, row);
      sizeMatrix.splice(1, 0, sizes);

      rowIndex = -1;
      /** @type {Array<string>} */
      const lines = [];

      while (++rowIndex < cellMatrix.length) {
        const row = cellMatrix[rowIndex];
        const sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        /** @type {Array<string>} */
        const line = [];

        while (++columnIndex < mostCellsPerRow) {
          const cell = row[columnIndex] || '';
          let before = '';
          let after = '';

          if (options.alignDelimiters !== false) {
            const size =
              longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
            const code = alignments[columnIndex];

            if (code === 114 /* `r` */) {
              before = ' '.repeat(size);
            } else if (code === 99 /* `c` */) {
              if (size % 2) {
                before = ' '.repeat(size / 2 + 0.5);
                after = ' '.repeat(size / 2 - 0.5);
              } else {
                before = ' '.repeat(size / 2);
                after = before;
              }
            } else {
              after = ' '.repeat(size);
            }
          }

          if (options.delimiterStart !== false && !columnIndex) {
            line.push('|');
          }

          if (
            options.padding !== false &&
            // Dont add the opening space if were not aligning and the cell is
            // empty: there will be a closing space.
            !(options.alignDelimiters === false && cell === '') &&
            (options.delimiterStart !== false || columnIndex)
          ) {
            line.push(' ');
          }

          if (options.alignDelimiters !== false) {
            line.push(before);
          }

          line.push(cell);

          if (options.alignDelimiters !== false) {
            line.push(after);
          }

          if (options.padding !== false) {
            line.push(' ');
          }

          if (
            options.delimiterEnd !== false ||
            columnIndex !== mostCellsPerRow - 1
          ) {
            line.push('|');
          }
        }

        lines.push(
          options.delimiterEnd === false
            ? line.join('').replace(/ +$/, '')
            : line.join('')
        );
      }

      return lines.join('\n')
    }

    /**
     * @param {string|null|undefined} [value]
     * @returns {string}
     */
    function serialize(value) {
      return value === null || value === undefined ? '' : String(value)
    }

    /**
     * @param {string} value
     * @returns {number}
     */
    function defaultStringLength(value) {
      return value.length
    }

    /**
     * @param {string|null|undefined} value
     * @returns {number}
     */
    function toAlignment(value) {
      const code = typeof value === 'string' ? value.codePointAt(0) : 0;

      return code === 67 /* `C` */ || code === 99 /* `c` */
        ? 99 /* `c` */
        : code === 76 /* `L` */ || code === 108 /* `l` */
        ? 108 /* `l` */
        : code === 82 /* `R` */ || code === 114 /* `r` */
        ? 114 /* `r` */
        : 0
    }

    /**
     * @typedef {import('mdast').Table} Table
     * @typedef {import('mdast').TableRow} TableRow
     * @typedef {import('mdast').TableCell} TableCell
     * @typedef {import('mdast').InlineCode} InlineCode
     *
     * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions
     *
     * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
     *
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
     * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext
     * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions
     */

    // To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.
    // To do: next major: use `defaultHandlers.inlineCode`.
    // To do: next major: expose functions.

    /**
     * Extension for `mdast-util-from-markdown` to enable GFM tables.
     *
     * @type {FromMarkdownExtension}
     */
    const gfmTableFromMarkdown = {
      enter: {
        table: enterTable,
        tableData: enterCell,
        tableHeader: enterCell,
        tableRow: enterRow
      },
      exit: {
        codeText: exitCodeText,
        table: exitTable,
        tableData: exit,
        tableHeader: exit,
        tableRow: exit
      }
    };

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterTable(token) {
      /** @type {Array<'left' | 'right' | 'center' | 'none'>} */
      // @ts-expect-error: `align` is custom.
      const align = token._align;
      this.enter(
        {
          type: 'table',
          align: align.map((d) => (d === 'none' ? null : d)),
          children: []
        },
        token
      );
      this.setData('inTable', true);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitTable(token) {
      this.exit(token);
      this.setData('inTable');
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterRow(token) {
      this.enter({type: 'tableRow', children: []}, token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exit(token) {
      this.exit(token);
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function enterCell(token) {
      this.enter({type: 'tableCell', children: []}, token);
    }

    // Overwrite the default code text data handler to unescape escaped pipes when
    // they are in tables.
    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitCodeText(token) {
      let value = this.resume();

      if (this.getData('inTable')) {
        value = value.replace(/\\([\\|])/g, replace);
      }

      const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1]);
      node.value = value;
      this.exit(token);
    }

    /**
     * @param {string} $0
     * @param {string} $1
     * @returns {string}
     */
    function replace($0, $1) {
      // Pipes work, backslashes dont (but cant escape pipes).
      return $1 === '|' ? $1 : $0
    }

    /**
     * Create an extension for `mdast-util-to-markdown` to enable GFM tables in
     * markdown.
     *
     * @param {Options | null | undefined} [options]
     *   Configuration.
     * @returns {ToMarkdownExtension}
     *   Extension for `mdast-util-to-markdown` to enable GFM tables.
     */
    function gfmTableToMarkdown(options) {
      const settings = options || {};
      const padding = settings.tableCellPadding;
      const alignDelimiters = settings.tablePipeAlign;
      const stringLength = settings.stringLength;
      const around = padding ? ' ' : '|';

      return {
        unsafe: [
          {character: '\r', inConstruct: 'tableCell'},
          {character: '\n', inConstruct: 'tableCell'},
          // A pipe, when followed by a tab or space (padding), or a dash or colon
          // (unpadded delimiter row), could result in a table.
          {atBreak: true, character: '|', after: '[\t :-]'},
          // A pipe in a cell must be encoded.
          {character: '|', inConstruct: 'tableCell'},
          // A colon must be followed by a dash, in which case it could start a
          // delimiter row.
          {atBreak: true, character: ':', after: '-'},
          // A delimiter row can also start with a dash, when followed by more
          // dashes, a colon, or a pipe.
          // This is a stricter version than the built in check for lists, thematic
          // breaks, and setex heading underlines though:
          // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
          {atBreak: true, character: '-', after: '[:|-]'}
        ],
        handlers: {
          table: handleTable,
          tableRow: handleTableRow,
          tableCell: handleTableCell,
          inlineCode: inlineCodeWithTable
        }
      }

      /**
       * @type {ToMarkdownHandle}
       * @param {Table} node
       */
      function handleTable(node, _, context, safeOptions) {
        return serializeData(
          handleTableAsData(node, context, safeOptions),
          node.align
        )
      }

      /**
       * This function isnt really used normally, because we handle rows at the
       * table level.
       * But, if someone passes in a table row, this ensures we make somewhat sense.
       *
       * @type {ToMarkdownHandle}
       * @param {TableRow} node
       */
      function handleTableRow(node, _, context, safeOptions) {
        const row = handleTableRowAsData(node, context, safeOptions);
        const value = serializeData([row]);
        // `markdown-table` will always add an align row
        return value.slice(0, value.indexOf('\n'))
      }

      /**
       * @type {ToMarkdownHandle}
       * @param {TableCell} node
       */
      function handleTableCell(node, _, context, safeOptions) {
        const exit = context.enter('tableCell');
        const subexit = context.enter('phrasing');
        const value = containerPhrasing(node, context, {
          ...safeOptions,
          before: around,
          after: around
        });
        subexit();
        exit();
        return value
      }

      /**
       * @param {Array<Array<string>>} matrix
       * @param {Array<string | null | undefined> | null | undefined} [align]
       */
      function serializeData(matrix, align) {
        return markdownTable(matrix, {
          align,
          // @ts-expect-error: `markdown-table` types should support `null`.
          alignDelimiters,
          // @ts-expect-error: `markdown-table` types should support `null`.
          padding,
          // @ts-expect-error: `markdown-table` types should support `null`.
          stringLength
        })
      }

      /**
       * @param {Table} node
       * @param {ToMarkdownContext} context
       * @param {SafeOptions} safeOptions
       */
      function handleTableAsData(node, context, safeOptions) {
        const children = node.children;
        let index = -1;
        /** @type {Array<Array<string>>} */
        const result = [];
        const subexit = context.enter('table');

        while (++index < children.length) {
          result[index] = handleTableRowAsData(
            children[index],
            context,
            safeOptions
          );
        }

        subexit();

        return result
      }

      /**
       * @param {TableRow} node
       * @param {ToMarkdownContext} context
       * @param {SafeOptions} safeOptions
       */
      function handleTableRowAsData(node, context, safeOptions) {
        const children = node.children;
        let index = -1;
        /** @type {Array<string>} */
        const result = [];
        const subexit = context.enter('tableRow');

        while (++index < children.length) {
          // Note: the positional info as used here is incorrect.
          // Making it correct would be impossible due to aligning cells?
          // And it would need copy/pasting `markdown-table` into this project.
          result[index] = handleTableCell(
            children[index],
            node,
            context,
            safeOptions
          );
        }

        subexit();

        return result
      }

      /**
       * @type {ToMarkdownHandle}
       * @param {InlineCode} node
       */
      function inlineCodeWithTable(node, parent, context) {
        let value = inlineCode(node, parent, context);

        if (context.stack.includes('tableCell')) {
          value = value.replace(/\|/g, '\\$&');
        }

        return value
      }
    }

    /**
     * @typedef {import('../types.js').State} State
     * @typedef {import('../types.js').Options} Options
     */

    /**
     * @param {State} state
     * @returns {Exclude<Options['bullet'], null | undefined>}
     */
    function checkBullet(state) {
      const marker = state.options.bullet || '*';

      if (marker !== '*' && marker !== '+' && marker !== '-') {
        throw new Error(
          'Cannot serialize items with `' +
            marker +
            '` for `options.bullet`, expected `*`, `+`, or `-`'
        )
      }

      return marker
    }

    /**
     * @typedef {import('../types.js').State} State
     * @typedef {import('../types.js').Options} Options
     */

    /**
     * @param {State} state
     * @returns {Exclude<Options['listItemIndent'], null | undefined>}
     */
    function checkListItemIndent(state) {
      const style = state.options.listItemIndent || 'tab';

      // To do: remove in a major.
      // @ts-expect-error: deprecated.
      if (style === 1 || style === '1') {
        return 'one'
      }

      if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
        throw new Error(
          'Cannot serialize items with `' +
            style +
            '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
        )
      }

      return style
    }

    /**
     * @typedef {import('mdast').ListItem} ListItem
     * @typedef {import('../types.js').Map} Map
     * @typedef {import('../types.js').Parent} Parent
     * @typedef {import('../types.js').State} State
     * @typedef {import('../types.js').Info} Info
     */

    /**
     * @param {ListItem} node
     * @param {Parent | undefined} parent
     * @param {State} state
     * @param {Info} info
     * @returns {string}
     */
    function listItem(node, parent, state, info) {
      const listItemIndent = checkListItemIndent(state);
      let bullet = state.bulletCurrent || checkBullet(state);

      // Add the marker value for ordered lists.
      if (parent && parent.type === 'list' && parent.ordered) {
        bullet =
          (typeof parent.start === 'number' && parent.start > -1
            ? parent.start
            : 1) +
          (state.options.incrementListMarker === false
            ? 0
            : parent.children.indexOf(node)) +
          bullet;
      }

      let size = bullet.length + 1;

      if (
        listItemIndent === 'tab' ||
        (listItemIndent === 'mixed' &&
          ((parent && parent.type === 'list' && parent.spread) || node.spread))
      ) {
        size = Math.ceil(size / 4) * 4;
      }

      const tracker = state.createTracker(info);
      tracker.move(bullet + ' '.repeat(size - bullet.length));
      tracker.shift(size);
      const exit = state.enter('listItem');
      const value = state.indentLines(
        state.containerFlow(node, tracker.current()),
        map
      );
      exit();

      return value

      /** @type {Map} */
      function map(line, index, blank) {
        if (index) {
          return (blank ? '' : ' '.repeat(size)) + line
        }

        return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line
      }
    }

    /**
     * @typedef {import('mdast').Content} Content
     * @typedef {import('mdast').ListItem} ListItem
     * @typedef {import('mdast').Paragraph} Paragraph
     * @typedef {import('mdast').Parent} Parent
     * @typedef {import('mdast').Root} Root
     * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
     */

    // To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use
    // `track` from `state`.
    // To do: next major: replace exports with functions.
    // To do: next major: use `defaulthandlers.listItem`.

    /**
     * Extension for `mdast-util-from-markdown` to enable GFM task list items.
     *
     * @type {FromMarkdownExtension}
     */
    const gfmTaskListItemFromMarkdown = {
      exit: {
        taskListCheckValueChecked: exitCheck,
        taskListCheckValueUnchecked: exitCheck,
        paragraph: exitParagraphWithTaskListItem
      }
    };

    /**
     * Extension for `mdast-util-to-markdown` to enable GFM task list items.
     *
     * @type {ToMarkdownExtension}
     */
    const gfmTaskListItemToMarkdown = {
      unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
      handlers: {listItem: listItemWithTaskListItem}
    };

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitCheck(token) {
      const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2]);
      // Were always in a paragraph, in a list item.
      node.checked = token.type === 'taskListCheckValueChecked';
    }

    /**
     * @this {CompileContext}
     * @type {FromMarkdownHandle}
     */
    function exitParagraphWithTaskListItem(token) {
      const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2]);

      if (
        parent &&
        parent.type === 'listItem' &&
        typeof parent.checked === 'boolean'
      ) {
        const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1]);
        const head = node.children[0];

        if (head && head.type === 'text') {
          const siblings = parent.children;
          let index = -1;
          /** @type {Paragraph | undefined} */
          let firstParaghraph;

          while (++index < siblings.length) {
            const sibling = siblings[index];
            if (sibling.type === 'paragraph') {
              firstParaghraph = sibling;
              break
            }
          }

          if (firstParaghraph === node) {
            // Must start with a space or a tab.
            head.value = head.value.slice(1);

            if (head.value.length === 0) {
              node.children.shift();
            } else if (
              node.position &&
              head.position &&
              typeof head.position.start.offset === 'number'
            ) {
              head.position.start.column++;
              head.position.start.offset++;
              node.position.start = Object.assign({}, head.position.start);
            }
          }
        }
      }

      this.exit(token);
    }

    /**
     * @type {ToMarkdownHandle}
     * @param {ListItem} node
     */
    function listItemWithTaskListItem(node, parent, context, safeOptions) {
      const head = node.children[0];
      const checkable =
        typeof node.checked === 'boolean' && head && head.type === 'paragraph';
      const checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';
      const tracker = track(safeOptions);

      if (checkable) {
        tracker.move(checkbox);
      }

      let value = listItem(node, parent, context, {
        ...safeOptions,
        ...tracker.current()
      });

      if (checkable) {
        value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
      }

      return value

      /**
       * @param {string} $0
       * @returns {string}
       */
      function check($0) {
        return $0 + checkbox
      }
    }

    /**
     * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
     * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
     */

    /**
     * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink
     * literals, footnotes, strikethrough, tables, tasklists).
     *
     * @returns {Array<FromMarkdownExtension>}
     *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,
     *   footnotes, strikethrough, tables, tasklists).
     */
    function gfmFromMarkdown() {
      return [
        gfmAutolinkLiteralFromMarkdown,
        gfmFootnoteFromMarkdown(),
        gfmStrikethroughFromMarkdown,
        gfmTableFromMarkdown,
        gfmTaskListItemFromMarkdown
      ]
    }

    /**
     * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink
     * literals, footnotes, strikethrough, tables, tasklists).
     *
     * @param {Options | null | undefined} [options]
     *   Configuration.
     * @returns {ToMarkdownExtension}
     *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,
     *   footnotes, strikethrough, tables, tasklists).
     */
    function gfmToMarkdown(options) {
      return {
        extensions: [
          gfmAutolinkLiteralToMarkdown,
          gfmFootnoteToMarkdown(),
          gfmStrikethroughToMarkdown,
          gfmTableToMarkdown(options),
          gfmTaskListItemToMarkdown
        ]
      }
    }

    /**
     * @typedef {import('mdast').Root} Root
     * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options
     */

    /**
     * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).
     *
     * @type {import('unified').Plugin<[Options?]|void[], Root>}
     */
    function remarkGfm(options = {}) {
      const data = this.data();

      add('micromarkExtensions', gfm(options));
      add('fromMarkdownExtensions', gfmFromMarkdown());
      add('toMarkdownExtensions', gfmToMarkdown(options));

      /**
       * @param {string} field
       * @param {unknown} value
       */
      function add(field, value) {
        const list = /** @type {unknown[]} */ (
          // Other extensions
          /* c8 ignore next 2 */
          data[field] ? data[field] : (data[field] = [])
        );

        list.push(value);
      }
    }

    /* eslint-disable @typescript-eslint/no-unused-vars */
    const Markdown = ({ onLinkClick, focusableProps, children, ...props }) => {
        return (window.SP_REACT.createElement(Focusable, { ...focusableProps },
            window.SP_REACT.createElement(ReactMarkdown, { remarkPlugins: [remarkGfm], 
                // Match sanitazion from the new site ssr
                disallowedElements: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'img'], unwrapDisallowed: true, components: {
                    // Make links usable
                    a: ({ node, children, ...linkProps }) => (window.SP_REACT.createElement(Focusable, { onActivate: () => {
                            if (linkProps.href) {
                                Navigation.NavigateToExternalWeb(linkProps.href);
                                onLinkClick?.();
                            }
                        }, onSecondaryButton: () => showQrModal(linkProps.href ?? ''), onSecondaryActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), style: { display: 'inline-block' } },
                        window.SP_REACT.createElement("a", { style: { textDecoration: 'underline', color: '#1a9fff' }, ...linkProps }, children))),
                }, ...props }, children)));
    };

    const DetailsModal = ({ closeModal, asset, assetType, onAssetChange, assetProps }) => {
        const [downloading, setDownloading] = React.useState(false); // props don't update in modals, need to repeat this here
        const handleDownload = async (evt) => {
            evt.preventDefault();
            setDownloading(true);
            await onAssetChange?.();
            setDownloading(false);
        };
        return (window.SP_REACT.createElement(ModalRoot, { className: "sgdb-modal sgdb-modal-details", closeModal: closeModal, bDisableBackgroundDismiss: false, bHideCloseIcon: false },
            window.SP_REACT.createElement("div", { className: joinClassNames('sgdb-modal-details-wrapper', asset.width > asset.height ? 'wide' : '') },
                window.SP_REACT.createElement(Asset, { src: asset.url, width: asset.width, height: asset.height, assetType: assetType, isAnimated: false, isDownloading: downloading, ...assetProps }),
                window.SP_REACT.createElement("div", { className: "info" },
                    window.SP_REACT.createElement(DialogButtonPrimary, { onClick: handleDownload, onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]) }, trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
                    window.SP_REACT.createElement("span", { className: "meta" }, [
                        asset.style.replace(/_/g, ' '),
                        asset.width > 0 ? `${asset.width}${asset.height}` : undefined,
                    ].filter(Boolean).join('  ')),
                    window.SP_REACT.createElement(Focusable, { className: "author", onActivate: () => {
                            Navigation.NavigateToExternalWeb(`https://steamcommunity.com/profiles/${asset.author.steam64}`);
                            closeModal?.();
                        } },
                        window.SP_REACT.createElement("img", { src: asset.author.avatar, alt: "" }),
                        window.SP_REACT.createElement("span", null, asset.author.name)),
                    asset.notes && (window.SP_REACT.createElement(Markdown, { onLinkClick: closeModal, focusableProps: { className: 'notes' } }, asset.notes))))));
    };

    const appGridFilterHeaderClass = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (typeof m[prop] === 'string' && prop === 'AppGridFilterHeader') {
                return m[prop];
            }
        }
        return;
    });
    const appGridFilterTextClass = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (typeof m[prop] === 'string' && prop === 'AppGridFilterText') {
                return m[prop];
            }
        }
        return;
    });
    const AppGridFilterBar = ({ children, ...rest }) => (window.SP_REACT.createElement("div", { ...rest },
        window.SP_REACT.createElement("div", { className: appGridFilterHeaderClass },
            window.SP_REACT.createElement("span", { className: appGridFilterTextClass }, children))));

    const strGameSelected = trans_string('MSG_GAME_SELECTED', 'Selected {gameName}');
    const strFilterActive = trans_string('MSG_ASSETS_FILTERED', 'Some assets may be hidden due to filter');
    const strFilterAndGame = trans_string('MSG_GAME_SELECTED_AND_ASSETS_FILTERED', 'Selected {gameName} with filter');
    const ResultsStateBar = ({ loading, selectedGame, isFiltered, onClick }) => {
        if (loading)
            return null;
        if (selectedGame && !isFiltered) {
            return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
                reactStringReplace(strGameSelected, '{gameName}', (_, i) => (window.SP_REACT.createElement(Marquee, { key: i, fadeLength: 5, style: { maxWidth: '350px' } },
                    "\"",
                    selectedGame.name,
                    "\""))),
                window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
        }
        if (!selectedGame && isFiltered) {
            return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
                strFilterActive,
                " ",
                window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
        }
        if (selectedGame && isFiltered) {
            return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
                reactStringReplace(strFilterAndGame, '{gameName}', (_, i) => (window.SP_REACT.createElement(Marquee, { key: i, fadeLength: 5, style: { maxWidth: '350px' } },
                    "\"",
                    selectedGame.name,
                    "\""))),
                window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
        }
        return null;
    };

    const LibraryImage = findModuleChild((m) => {
        if (typeof m !== 'object')
            return;
        for (const prop in m) {
            if (m[prop]?.toString && m[prop].toString().includes('Either rgSources or app must be specified')) {
                return m[prop];
            }
        }
        return;
    });

    const getCustomLogoPosition = async (appId) => {
        try {
            const appoverview = await getAppOverview(appId);
            if (!appoverview)
                return null;
            return await l$1(() => {
                try {
                    return window.appDetailsStore.GetCustomLogoPosition(appoverview) ?? null;
                }
                catch (error) {
                    return null;
                }
            }, { timeout: 2000, intervalBetweenAttempts: 200 });
        }
        catch (err) {
            return null;
        }
    };

    var Dpad = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/dpad-daf9c40e.svg';

    const getStylePositions = (pos, widthPct, heightPct) => {
        const positions = {
            BottomLeft: {
                bottom: 0,
                top: 100 - heightPct,
                left: 0,
                right: 100 - widthPct,
            },
            UpperLeft: {
                bottom: 100 - heightPct,
                top: 0,
                left: 0,
                right: 100 - widthPct,
            },
            CenterCenter: {
                bottom: (100 - heightPct) / 2,
                top: (100 - heightPct) / 2,
                left: (100 - widthPct) / 2,
                right: (100 - widthPct) / 2,
            },
            UpperCenter: {
                bottom: 100 - heightPct,
                top: 0,
                left: (100 - widthPct) / 2,
                right: (100 - widthPct) / 2,
            },
            BottomCenter: {
                bottom: 0,
                top: 100 - heightPct,
                left: (100 - widthPct) / 2,
                right: (100 - widthPct) / 2,
            },
        };
        return positions[pos];
    };
    const LogoPositioner = ({ app, logoPos, border }) => {
        const positions = logoPos ? getStylePositions(logoPos.pinnedPosition, logoPos.nWidthPct, logoPos.nHeightPct) : null;
        if (!logoPos)
            return (window.SP_REACT.createElement("div", { className: "logo-positioner spinnyboi" },
                window.SP_REACT.createElement("img", { alt: "Loading...", src: "/images/steam_spinner.png" })));
        return (window.SP_REACT.createElement("div", { className: joinClassNames(appDetailsHeaderClasses.TopCapsule, app.BIsModOrShortcut() ? appDetailsHeaderClasses.FallbackArt : '', 'logo-positioner', border ? 'logo-border' : '', `pos-${logoPos.pinnedPosition}`), style: {
                ['--logo-width']: `${logoPos.nWidthPct}%`,
                ['--logo-height']: `${logoPos.nHeightPct}%`,
                ['--logo-left']: positions ? `${positions.left}%` : undefined,
                ['--logo-top']: positions ? `${positions.top}%` : undefined,
            } },
            window.SP_REACT.createElement("div", { className: "logo-outer-region" },
                window.SP_REACT.createElement("div", { className: "logo-wrap" },
                    window.SP_REACT.createElement("span", { className: "logo-anchor-guide-mid" }),
                    window.SP_REACT.createElement("div", { className: "logo-wrap-pos" },
                        window.SP_REACT.createElement(LibraryImage, { app: app, eAssetType: ASSET_TYPE.logo, allowCustomization: false, className: "logo-positioner-logo", imageClassName: "logo-positioner-logo-img", backgroundType: "transparent" })))),
            window.SP_REACT.createElement(LibraryImage, { app: app, eAssetType: ASSET_TYPE.hero, allowCustomization: false, neverShowTitle: true, backgroundType: "transparent", className: "logo-positioner-hero" })));
    };
    const LogoPositionerModal = ({ closeModal, appId }) => {
        const [overview, setOverview] = React.useState(null);
        const [logoPos, setLogoPos] = React.useState(null);
        const [showBorder, setShowBorder] = React.useState(true);
        const resizeAmount = React.useRef(.25);
        const handleCancel = () => {
            closeModal?.();
        };
        const handleSave = async () => {
            if (!overview || !logoPos)
                return;
            await window.appDetailsStore.SaveCustomLogoPosition(overview, logoPos);
            closeModal?.();
        };
        const handleReset = async () => {
            if (!overview || !logoPos)
                return;
            await window.appDetailsStore.ClearCustomLogoPosition(overview);
            closeModal?.();
        };
        const handleDirection = (evt) => {
            // Increase speed when held down
            if (evt.detail.is_repeat) {
                if (resizeAmount.current !== 2) {
                    resizeAmount.current = resizeAmount.current + .25;
                }
            }
            else {
                resizeAmount.current = .25;
            }
            setLogoPos((logoPos) => {
                const newLogoPos = { ...logoPos };
                switch (evt.detail.button) {
                    case 9: // up
                        newLogoPos.nHeightPct = newLogoPos.nHeightPct + resizeAmount.current;
                        break;
                    case 10: // down
                        newLogoPos.nHeightPct = newLogoPos.nHeightPct - resizeAmount.current;
                        break;
                    case 11: // left
                        newLogoPos.nWidthPct = newLogoPos.nWidthPct - resizeAmount.current;
                        break;
                    case 12: // right
                        newLogoPos.nWidthPct = newLogoPos.nWidthPct + resizeAmount.current;
                        break;
                }
                if (newLogoPos.nWidthPct > 100) {
                    newLogoPos.nWidthPct = newLogoPos.nWidthPct = 100;
                }
                if (newLogoPos.nWidthPct <= 0) {
                    newLogoPos.nWidthPct = newLogoPos.nWidthPct = 0.01;
                }
                if (newLogoPos.nHeightPct > 100) {
                    newLogoPos.nHeightPct = newLogoPos.nHeightPct = 100;
                }
                if (newLogoPos.nHeightPct <= 0) {
                    newLogoPos.nHeightPct = newLogoPos.nHeightPct = 0.01;
                }
                return newLogoPos;
            });
        };
        const handlePinPos = () => {
            const anchorPos = ['BottomLeft', 'UpperLeft', 'UpperCenter', 'CenterCenter', 'BottomCenter'];
            setLogoPos((logoPos) => {
                const newLogoPos = { ...logoPos };
                if (logoPos && anchorPos.indexOf(logoPos.pinnedPosition) === anchorPos.length - 1) {
                    newLogoPos.pinnedPosition = anchorPos[0];
                }
                else {
                    newLogoPos.pinnedPosition = anchorPos[anchorPos.indexOf(logoPos ? logoPos.pinnedPosition : 'BottomLeft') + 1];
                }
                return newLogoPos;
            });
        };
        React.useEffect(() => {
            if (appId) {
                (async () => {
                    setOverview(await getAppOverview(appId));
                })();
            }
        }, [appId]);
        React.useEffect(() => {
            if (overview) {
                (async () => {
                    const appdetails = await getAppDetails(overview.appid);
                    const logoPos = await getCustomLogoPosition(overview.appid) || // Loads from json
                        appdetails?.libraryAssets?.logoPosition || // Loads from default Steam app details
                        { pinnedPosition: 'BottomLeft', nWidthPct: 50, nHeightPct: 50 }; // Fallback when no data is available
                    if (logoPos) {
                        setLogoPos(logoPos);
                    }
                })();
            }
        }, [overview]);
        return (window.SP_REACT.createElement(Focusable, { noFocusRing: false, className: "sgdb-modal sgdb-modal-logo-position", onGamepadDirection: handleDirection, onCancel: handleCancel, onCancelButton: handleCancel, onCancelActionDescription: trans_string('Button_Cancel', 'Cancel', true), onActivate: handleSave, onOKActionDescription: trans_string('Button_Save', 'Save', true), onSecondaryButton: handlePinPos, onSecondaryActionDescription: trans_string('ACTION_CHANGE_POS_LOGO_ANCHOR_POINT', 'Change Anchor Point'), onOptionsButton: () => setShowBorder((x) => !x), onOptionsActionDescription: showBorder ? trans_string('ACTION_HIDE_POS_GUIDES', 'Hide Guides') : trans_string('ACTION_SHOW_OUTLINE', 'Show Guides'), onMenuButton: handleReset, onMenuActionDescription: trans_string('CustomArt_ResetLogoPosition', 'Reset Logo Position', true) },
            overview && window.SP_REACT.createElement(LogoPositioner, { app: overview, logoPos: logoPos, border: showBorder }),
            window.SP_REACT.createElement("ul", { className: "logo-positioner-instructions" },
                window.SP_REACT.createElement("li", null,
                    window.SP_REACT.createElement("img", { src: Dpad }),
                    " ",
                    trans_string('ACTION_ADJUST_POS_SIZE', 'Adjust Size')),
                window.SP_REACT.createElement("li", null,
                    window.SP_REACT.createElement(FooterGlyph, { button: 2, size: 1, type: 0 }),
                    " ",
                    trans_string('ACTION_CHANGE_POS_LOGO_ANCHOR_POINT', 'Change Anchor Point')))));
    };

    /**
     * Languages from official Steam docs
     * https://partner.steamgames.com/doc/store/localization/languages#supported_languages
    (() => {
      const langs = [];
      const table = document.evaluate("//th[contains(text(),'English Name')]", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.closest('table');
      for (const row of table.rows) {
        if (row.cells[0].innerText !== 'English Name') {
          langs.push(Array.from(row.cells).map((x) => x.innerText.replace('*', '').trim()));
        }
      }

      // Create SteamChina from Simplified Chinese
      const zhXC = [...langs.find((x) => x[3] === 'zh-CN')];
      zhXC[2] = 'sc_schinese';
      zhXC[3] = 'zh-XC';
      langs.push(zhXC)

      console.info(`const LANGS = ${JSON.stringify(langs, null, 2)};`);
    })();
     */
    const LANGS = [
        [
            'Arabic',
            '',
            'arabic',
            'ar',
        ],
        [
            'Bulgarian',
            ' ',
            'bulgarian',
            'bg',
        ],
        [
            'Chinese (Simplified)',
            '',
            'schinese',
            'zh-CN',
        ],
        [
            'Chinese (Traditional)',
            '',
            'tchinese',
            'zh-TW',
        ],
        [
            'Czech',
            'etina',
            'czech',
            'cs',
        ],
        [
            'Danish',
            'Dansk',
            'danish',
            'da',
        ],
        [
            'Dutch',
            'Nederlands',
            'dutch',
            'nl',
        ],
        [
            'English',
            'English',
            'english',
            'en',
        ],
        [
            'Finnish',
            'Suomi',
            'finnish',
            'fi',
        ],
        [
            'French',
            'Franais',
            'french',
            'fr',
        ],
        [
            'German',
            'Deutsch',
            'german',
            'de',
        ],
        [
            'Greek',
            '',
            'greek',
            'el',
        ],
        [
            'Hungarian',
            'Magyar',
            'hungarian',
            'hu',
        ],
        [
            'Italian',
            'Italiano',
            'italian',
            'it',
        ],
        [
            'Japanese',
            '',
            'japanese',
            'ja',
        ],
        [
            'Korean',
            '',
            'koreana',
            'ko',
        ],
        [
            'Norwegian',
            'Norsk',
            'norwegian',
            'no',
        ],
        [
            'Polish',
            'Polski',
            'polish',
            'pl',
        ],
        [
            'Portuguese',
            'Portugus',
            'portuguese',
            'pt',
        ],
        [
            'Portuguese-Brazil',
            'Portugus-Brasil',
            'brazilian',
            'pt-BR',
        ],
        [
            'Romanian',
            'Romn',
            'romanian',
            'ro',
        ],
        [
            'Russian',
            '',
            'russian',
            'ru',
        ],
        [
            'Spanish-Spain',
            'Espaol-Espaa',
            'spanish',
            'es',
        ],
        [
            'Spanish-Latin America',
            'Espaol-Latinoamrica',
            'latam',
            'es-419',
        ],
        [
            'Swedish',
            'Svenska',
            'swedish',
            'sv',
        ],
        [
            'Thai',
            '',
            'thai',
            'th',
        ],
        [
            'Turkish',
            'Trke',
            'turkish',
            'tr',
        ],
        [
            'Ukrainian',
            '',
            'ukrainian',
            'uk',
        ],
        [
            'Vietnamese',
            'Ting Vit',
            'vietnamese',
            'vn',
        ],
        [
            'Chinese (Simplified)',
            '',
            'sc_schinese',
            'zh-XC',
        ],
    ];
    /**
     * English Name, Native Name, API language code, Web API language code
     */
    const TYPES = {
        english: 0,
        native: 1,
        api: 2,
        webapi: 3,
    };
    var SteamLang = (input, inputType, output) => {
        if (Object.keys(TYPES).indexOf(output) === -1 || Object.keys(TYPES).indexOf(inputType) === -1) {
            return null;
        }
        for (let i = 0; i < LANGS.length; i++) {
            const lang = LANGS[i];
            if (lang[TYPES[inputType]].toLowerCase() == input.toLowerCase()) {
                return lang[TYPES[output]];
            }
        }
        return null;
    };

    const SteamModalImageSection = ({ closeModal, languages, langType, urlHandler, assetType, onAssetChange, assetProps }) => {
        const hasEng = React.useMemo(() => (languages.indexOf(SteamLang('en', 'webapi', langType)) > -1), [langType, languages]);
        const [selectedLang, setSelectedLang] = React.useState(hasEng ? SteamLang('en', 'webapi', langType) : languages[0]); // English as default
        const [selectedImg, setSelectedImg] = React.useState('');
        const [downloading, setDownloading] = React.useState(false);
        const handleDownload = async (evt) => {
            evt.preventDefault();
            setDownloading(true);
            await onAssetChange?.(selectedImg);
            setDownloading(false);
            closeModal?.();
        };
        React.useEffect(() => {
            setSelectedImg(urlHandler(selectedLang));
        }, [selectedLang, urlHandler]);
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            window.SP_REACT.createElement(DialogBody, null,
                (languages.length > 1) && (window.SP_REACT.createElement(Field, { label: trans_string('LanguageTitle', 'Language', true) },
                    window.SP_REACT.createElement(Dropdown, { rgOptions: languages.map((language) => ({
                            data: language,
                            label: SteamLang(language, langType, 'native'),
                        })), selectedOption: selectedLang, onChange: (newLang) => setSelectedLang(newLang.data) }))),
                window.SP_REACT.createElement(DialogControlsSection, null, selectedImg && (window.SP_REACT.createElement(Field, { padding: "none", childrenLayout: "below", childrenContainerWidth: "max", bottomSeparator: "none" },
                    window.SP_REACT.createElement("div", { className: joinClassNames('official-steam-asset', assetType) },
                        window.SP_REACT.createElement(Asset, { src: selectedImg, width: 0, height: 0, assetType: assetType, isAnimated: false, isDownloading: downloading, ...assetProps })))))),
            window.SP_REACT.createElement(DialogFooter, null,
                window.SP_REACT.createElement(DialogButtonPrimary, { onClick: handleDownload, onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]) }, trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])))));
    };
    const OfficialAssetsModal = ({ closeModal, assetType, data, onAssetChange }) => {
        const info = data[0].metadata;
        return (window.SP_REACT.createElement(ModalRoot, { className: "sgdb-modal sgdb-modal-official-assets", closeModal: closeModal, bDisableBackgroundDismiss: false, bHideCloseIcon: false },
            (assetType === 'grid_l' && info.header_image) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: info.header_image.split(','), urlHandler: (newLang) => {
                    if (newLang == 'english') {
                        return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/header.jpg?t=${info.store_asset_mtime}`;
                    }
                    return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/header_${newLang}.jpg?t=${info.store_asset_mtime}`;
                }, langType: "api", assetProps: {
                    width: 460,
                    height: 215,
                } })),
            (assetType === 'grid_p' && info.library_capsule) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: info.library_capsule.split(','), urlHandler: (newLang) => {
                    if (newLang == 'en') {
                        return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/library_600x900_2x.jpg?t=${info.store_asset_mtime}`;
                    }
                    return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/library_600x900_${SteamLang(newLang, 'webapi', 'api')}_2x.jpg?t=${info.store_asset_mtime}`;
                }, langType: "webapi", assetProps: {
                    width: 600,
                    height: 900,
                } })),
            (assetType === 'hero' && info.library_hero) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: info.library_hero.split(','), urlHandler: (newLang) => {
                    if (newLang == 'en') {
                        return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/library_hero.jpg?t=${info.store_asset_mtime}`;
                    }
                    return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/library_hero_${SteamLang(newLang, 'webapi', 'api')}.jpg?t=${info.store_asset_mtime}`;
                }, langType: "webapi", assetProps: {
                    width: 1920,
                    height: 620,
                } })),
            (assetType === 'logo' && info.library_logo) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: info.library_logo.split(','), urlHandler: (newLang) => {
                    if (newLang == 'en') {
                        return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/logo.png?t=${info.store_asset_mtime}`;
                    }
                    return `https://cdn.cloudflare.steamstatic.com/steam/apps/${data[0].id}/logo_${SteamLang(newLang, 'webapi', 'api')}.png?t=${info.store_asset_mtime}`;
                }, langType: "webapi" }))));
    };

    const AssetTab = ({ assetType }) => {
        const { get } = useSettings();
        const { loading: searchLoading, assets, searchAndSetAssets, loadMore, openFilters, isFilterActive, selectedGame, externalSgdbData, } = useAssetSearch();
        const { appOverview, changeAssetFromUrl, serverApi } = useSGDB();
        const [downloadingId, setDownloadingId] = React.useState(null);
        const [sizingStyles, setSizingStyles] = React.useState(undefined);
        const [tabLoading, setTabLoading] = React.useState(true);
        const [moreLoading, setMoreLoading] = React.useState(false);
        const loading = React.useMemo(() => !(!searchLoading && !tabLoading), [searchLoading, tabLoading]);
        const toolbarRef = React.useRef(null);
        const mainContentRef = React.useRef(null);
        const intersectRef = React.useRef(null);
        const handleFilterClick = () => openFilters(assetType);
        const handleLogoPosClick = () => showModal(window.SP_REACT.createElement(LogoPositionerModal, { appId: appOverview.appid }), window);
        const handleOfficialAssetsClick = () => {
            showModal((window.SP_REACT.createElement(OfficialAssetsModal, { onAssetChange: async (url) => {
                    try {
                        await changeAssetFromUrl(url, assetType);
                        serverApi.toaster.toast({
                            title: appOverview?.display_name,
                            body: trans_string('MSG_ASSET_APPLY_SUCCESS', '{assetType} has been successfully applied!').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]),
                            icon: window.SP_REACT.createElement(MenuIcon, null),
                            duration: 1500,
                        });
                    }
                    catch (err) {
                        serverApi.toaster.toast({
                            title: trans_string('MSG_ASSET_APPLY_ERROR', 'There was a problem applying this asset.'),
                            body: err.message,
                            icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                        });
                    }
                }, assetType: assetType, data: externalSgdbData })), window);
        };
        const setAsset = async (assetId, url) => {
            if (!downloadingId) {
                try {
                    setDownloadingId(assetId);
                    await changeAssetFromUrl(url, assetType);
                    serverApi.toaster.toast({
                        title: appOverview?.display_name,
                        body: trans_string('MSG_ASSET_APPLY_SUCCESS', '{assetType} has been successfully applied!').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]),
                        icon: window.SP_REACT.createElement(MenuIcon, null),
                        duration: 1500,
                    });
                }
                catch (err) {
                    serverApi.toaster.toast({
                        title: trans_string('MSG_ASSET_APPLY_ERROR', 'There was a problem applying this asset.'),
                        body: err.message,
                        icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                    });
                }
                finally {
                    setDownloadingId(null);
                }
            }
        };
        /* const focusSettings = () => {
          toolbarRef.current?.focus();
        }; */
        const openDetails = (asset) => {
            showModal((window.SP_REACT.createElement(DetailsModal, { asset: asset, assetType: assetType, onAssetChange: async () => await setAsset(asset.id, asset.url) })), window);
        };
        React.useEffect(() => {
            (async () => {
                setTabLoading(true);
                const filters = await get(`filters_${assetType}`, null);
                await searchAndSetAssets(assetType, filters, () => {
                    setTabLoading(false);
                });
            })();
        }, [searchAndSetAssets, assetType, get]);
        React.useEffect(() => {
            if (!intersectRef.current || loading)
                return;
            const observer = new IntersectionObserver(([entry], observer) => {
                if (!moreLoading && entry.isIntersecting) {
                    setMoreLoading(true);
                    loadMore(assetType, (res) => {
                        if (res.length === 0) {
                            observer.disconnect();
                        }
                        else {
                            setMoreLoading(false);
                        }
                    });
                }
            }, { threshold: 0, root: mainContentRef.current?.parentElement?.parentElement });
            observer.observe(intersectRef.current);
            return () => {
                observer.disconnect();
            };
        }, [assetType, loadMore, loading, moreLoading]);
        if (!appOverview)
            return null;
        return (window.SP_REACT.createElement("div", { className: "tabcontents-wrap" },
            window.SP_REACT.createElement("div", { className: joinClassNames('spinnyboi', !loading ? 'loaded' : '') },
                window.SP_REACT.createElement("img", { alt: "Loading...", src: "/images/steam_spinner.png" })),
            window.SP_REACT.createElement(Toolbar, { ref: toolbarRef, assetType: assetType, onFilterClick: handleFilterClick, onLogoPosClick: handleLogoPosClick, onOfficialAssetsClick: handleOfficialAssetsClick, onSizeChange: (size) => setSizingStyles(size), disabled: tabLoading, noFocusRing: searchLoading || tabLoading }),
            window.SP_REACT.createElement(ResultsStateBar, { loading: loading, selectedGame: selectedGame, isFiltered: isFilterActive, onClick: handleFilterClick }),
            window.SP_REACT.createElement(Focusable, { ref: mainContentRef, id: "images-container", style: sizingStyles }, !tabLoading && (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
                assets.map((asset) => (window.SP_REACT.createElement(Asset, { key: asset.id, scrollContainer: mainContentRef.current?.parentElement?.parentElement, author: asset.author, notes: asset.notes, src: asset.thumb, width: asset.width, height: asset.height, humor: asset.humor, epilepsy: asset.epilepsy, nsfw: asset.nsfw, assetType: assetType, isAnimated: asset.thumb.includes('.webm'), isDownloading: downloadingId === asset.id, onActivate: () => setAsset(asset.id, asset.url), onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]), onSecondaryActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onSecondaryButton: handleFilterClick, onMenuActionDescription: trans_string('ACTION_OPEN_DETAILS', 'Details'), onMenuButton: () => openDetails(asset) }))),
                window.SP_REACT.createElement("div", { ref: intersectRef, style: { gridColumn: '1 / -1', height: '5px' } }))))));
    };

    const AssetBlock = ({ app, browseStartPath, assetType, editable = true }) => {
        const { clearAsset, changeAsset, serverApi, changeAssetFromUrl } = useSGDB();
        const [overview, setOverview] = React.useState(app);
        const innerFocusRef = React.useRef(null);
        const refreshing = React.useRef(false);
        // god is dead
        const refreshOverview = async () => {
            if (refreshing.current)
                return;
            refreshing.current = true;
            setOverview(null);
            await new Promise((resolve) => setTimeout(resolve, 500));
            const appoverview = await getAppOverview(app.appid);
            if (assetType === 'icon' && appoverview?.icon_hash) {
                // Today i choose violence
                const hash = appoverview.icon_hash;
                // fuck up the hash to force render the icon file from the cache
                appoverview.icon_hash = String(new Date().getTime());
                setOverview(appoverview);
                // vibe for a bit
                await new Promise((resolve) => setTimeout(resolve, 300));
                // now put that shit back
                appoverview.icon_hash = hash;
            }
            setOverview(appoverview);
            refreshing.current = false;
        };
        const handleBrowse = async () => {
            const path = await openFilePicker(browseStartPath, true, undefined, {
                validFileExtensions: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'apng', 'tiff', 'tga'],
            }, serverApi);
            await changeAssetFromUrl(path.path, assetType, true);
            await refreshOverview();
        };
        const handleBlank = async () => {
            await changeAsset('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=', assetType);
            await refreshOverview();
        };
        const handleClear = async () => {
            await clearAsset(assetType);
            await refreshOverview();
        };
        return (window.SP_REACT.createElement("div", { className: joinClassNames('asset-wrap', `asset-wrap-${assetType}`) },
            window.SP_REACT.createElement("div", { className: "asset-label" }, trans_string('LABEL_ASSET_CURRENT', 'Current {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
            window.SP_REACT.createElement(Focusable, { onActivate: editable ? () => innerFocusRef.current?.focus() : undefined, onClick: (evt) => evt.preventDefault(), focusWithinClassName: "is-focused", focusClassName: "is-focused" },
                editable && (window.SP_REACT.createElement(Focusable, { "flow-children": "right", className: "action-overlay" },
                    window.SP_REACT.createElement(Focusable, { ref: innerFocusRef, noFocusRing: true, className: "action-button", onActivate: handleClear, onOKActionDescription: trans_string('ACTION_ASSET_CUSTOM_CLEAR', 'Clear Custom Asset') },
                        window.SP_REACT.createElement(HiTrash, null)),
                    window.SP_REACT.createElement(Focusable, { noFocusRing: true, className: "action-button", onActivate: handleBrowse, onOKActionDescription: trans_string('ACTION_ASSET_BROWSE_LOCAL', 'Browse for Local Files') },
                        window.SP_REACT.createElement(HiFolder, null)),
                    assetType !== 'icon' && (window.SP_REACT.createElement(Focusable, { noFocusRing: true, className: "action-button", onActivate: handleBlank, onOKActionDescription: trans_string('ACTION_ASSET_APPLY_TRANSPARENT', 'Use Invisible Asset') },
                        window.SP_REACT.createElement(HiEyeSlash, null))))),
                overview ? (window.SP_REACT.createElement(LibraryImage, { app: overview, eAssetType: ASSET_TYPE[assetType], allowCustomization: false, className: "asset", imageClassName: "asset-img" })) : (window.SP_REACT.createElement("div", { className: "asset" })))));
    };
    const LocalTab = () => {
        const { appId, serverApi, appOverview } = useSGDB();
        const [startPath, setStartPath] = React.useState('/');
        const [overview, setOverview] = React.useState();
        React.useEffect(() => {
            if (!appId)
                return;
            (async () => {
                const appoverview = await getAppOverview(appId);
                if (!appoverview)
                    return;
                // Today i choose violence
                if (appoverview.icon_hash) {
                    const hash = appoverview.icon_hash;
                    // fuck up the hash to force render the icon file from the cache
                    appoverview.icon_hash = String(new Date().getTime());
                    setOverview(appoverview);
                    // vibe for a bit
                    await new Promise((resolve) => setTimeout(resolve, 300));
                    // now put that shit back
                    appoverview.icon_hash = hash;
                }
                setOverview(appoverview);
                const path = (await serverApi.callPluginMethod('get_local_start', {})).result;
                setStartPath(path);
            })();
        }, [appId, appOverview, serverApi]);
        if (!overview || !appId)
            return null;
        return (window.SP_REACT.createElement(Focusable, { id: "local-images-container" },
            window.SP_REACT.createElement(Focusable, { "flow-children": "right", style: { display: 'flex', flexDirection: 'column', gap: '1em' } },
                window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "grid_p", browseStartPath: startPath }),
                window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "icon", browseStartPath: startPath, editable: !(overview.third_party_mod || (overview.BIsShortcut() && overview.selected_clientid != '0')) })),
            window.SP_REACT.createElement(Focusable, { "flow-children": "right", style: { display: 'flex', flexDirection: 'column', gap: '1em' } },
                window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "grid_l", browseStartPath: startPath }),
                window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "logo", browseStartPath: startPath })),
            window.SP_REACT.createElement("div", { style: { gridColumn: 'span 2' } },
                window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "hero", browseStartPath: startPath })),
            window.SP_REACT.createElement(Focusable, { "flow-children": "right", style: { gridColumn: 'span 2', display: 'flex', gap: '.5em' } },
                window.SP_REACT.createElement(DialogButton, { onClick: () => {
                        showModal(window.SP_REACT.createElement(LogoPositionerModal, { appId: appId }), window);
                    } }, trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true)),
                window.SP_REACT.createElement(DialogButton, { onClick: async () => {
                        await window.appDetailsStore.ClearCustomLogoPosition(overview);
                    } }, trans_string('CustomArt_ResetLogoPosition', 'Reset Logo Position', true)))));
    };

    const AssetTabs = ({ currentTab, onShowTab }) => {
        const { get, set } = useSettings();
        const { appOverview } = useSGDB();
        const { openFilters } = useAssetSearch();
        const [tabPositions, setTabPositions] = React.useState(null);
        const [hiddenTabs, setHiddenTabs] = React.useState(null);
        React.useEffect(() => {
            (async () => {
                setTabPositions(await get('tabs_order', DEFAULT_TABS));
                setHiddenTabs(await get('tabs_hidden', []));
                // Amount of times tabs page opened, used to hide tutorial after a while
                const useCount = await get('plugin_use_count', 0);
                set('plugin_use_count', useCount + 1, true);
            })();
        }, [get, set]);
        if (!tabPositions || !hiddenTabs)
            return null;
        let tabs = [
            ...tabPositions
                /*
                  Filter out icons if:
                    - App is a mod, editing edit liblist.gam/gameinfo.txt is destructive and out of scope for this plugin
                    - Shortcut is not locally installed, can't edit shortcuts.vdf remotely.
                */
                .filter((type) => !(type === 'icon' && (appOverview.third_party_mod ||
                (appOverview.BIsShortcut() && appOverview.selected_clientid != '0'))))
                // Filter hidden tabs
                .filter((x) => !hiddenTabs.includes(x)),
        ];
        /*
          If no tabs are left, force show manage tab. Useful for when only icons are selected and trying to view a mod.
        */
        if (tabs.length === 0) {
            tabs = ['manage'];
        }
        return (window.SP_REACT.createElement(Tabs, { title: "SteamGridDB", autoFocusContents: true, activeTab: currentTab, onShowTab: onShowTab, tabs: tabs.map((type) => {
                if (type === 'manage') {
                    return {
                        title: tabStrs[type],
                        content: window.SP_REACT.createElement(LocalTab, null),
                        id: 'manage',
                    };
                }
                return {
                    id: type,
                    title: tabStrs[type],
                    content: window.SP_REACT.createElement(AssetTab, { assetType: type }),
                    footer: {
                        onSecondaryActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'),
                        onSecondaryButton: () => openFilters(type),
                    },
                };
            }) }));
    };
    var AssetTabs$1 = React.memo(AssetTabs);

    var style = ".sgdb-modal-details-wrapper {\n  display: flex;\n  gap: 1em;\n}\n.sgdb-modal-details-wrapper.wide {\n  flex-direction: column;\n}\n.sgdb-modal-details-wrapper.wide > .asset-box-wrap {\n  max-width: 100%;\n  margin: 0 auto;\n}\n.sgdb-modal-details-wrapper.wide > .asset-box-wrap .image-wrap {\n  margin-top: 0;\n}\n.sgdb-modal-details-wrapper.wide .notes {\n  max-width: 100%;\n}\n.sgdb-modal-details .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus {\n  z-index: 10005;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb, .sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb video, .sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n.sgdb-modal-details .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n}\n.sgdb-modal-details .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.sgdb-modal-details .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n.sgdb-modal-details .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n.sgdb-modal-details .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-details .asset-box-wrap {\n  width: 100%;\n  max-width: 46%;\n}\n.sgdb-modal-details .info {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n.sgdb-modal-details .meta {\n  text-transform: capitalize;\n  opacity: 0.5;\n  font-size: 0.8em;\n  text-align: right;\n}\n.sgdb-modal-details .author {\n  display: flex;\n  align-items: center;\n  margin-top: 1em;\n  gap: 0.5em;\n  font-weight: bold;\n}\n.sgdb-modal-details .author > img {\n  width: 32px;\n  height: 32px;\n}\n.sgdb-modal-details .notes {\n  max-width: 300px;\n  word-break: break-word;\n}\n\n.sgdb-modal-filters .game-filter-content {\n  display: flex;\n  flex-direction: row;\n  gap: 10px;\n}\n.sgdb-modal-filters .game-filter-content > .custom-game-value {\n  width: 280px;\n  max-width: 100%;\n}\n.sgdb-modal-filters .game-filter-content > .clear-custom-game {\n  padding: 10px;\n  max-width: 40px;\n  line-height: 10px !important;\n  min-width: auto;\n}\n\n.sgdb-modal-gameselect .gamelabel {\n  display: flex;\n  width: 100%;\n  gap: 0.2em;\n  font-weight: bold;\n}\n.sgdb-modal-gameselect .gamelabel .release-date {\n  font-weight: normal;\n  opacity: 0.5;\n}\n.sgdb-modal-gameselect .gamelabel .platform-types {\n  display: flex;\n  align-items: center;\n  gap: 0.2em;\n  margin-left: auto;\n}\n.sgdb-modal-gameselect .spinner {\n  width: 2em;\n  margin: 0 auto;\n  margin-top: 2em;\n}\n\n.sgdb-modal-logo-position .logo-positioner {\n  display: flex;\n  position: relative;\n  margin-top: calc(var(--basicui-header-height, 40px) + 1em);\n  width: 100%;\n  overflow: hidden;\n  align-items: center;\n}\n.sgdb-modal-logo-position .logo-positioner.spinnyboi {\n  height: var(--header-height, calc(80px + 20vw));\n}\n.sgdb-modal-logo-position .logo-positioner.spinnyboi > img {\n  margin: 0 auto;\n  width: 5em;\n  opacity: 0;\n  animation: 150ms linear 400ms 1 sgdb-fadeIn forwards;\n}\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-positioner-logo {\n  outline: 3px #008ada solid;\n}\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap::before,\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap::after,\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap > .logo-anchor-guide-mid {\n  display: block;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperLeft .logo-positioner-logo-img {\n  object-position: top left;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperLeft .logo-wrap::before {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomLeft .logo-positioner-logo-img {\n  object-position: bottom left;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomLeft .logo-wrap::after {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperCenter .logo-positioner-logo-img {\n  object-position: top center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperCenter .logo-wrap > .logo-anchor-guide-mid {\n  border-top-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperCenter .logo-wrap > .logo-anchor-guide-mid::before {\n  border-color: #008ada;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-CenterCenter .logo-positioner-logo-img {\n  object-position: center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-CenterCenter .logo-wrap > .logo-anchor-guide-mid::before {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomCenter .logo-positioner-logo-img {\n  object-position: bottom center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomCenter .logo-wrap > .logo-anchor-guide-mid {\n  border-bottom-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomCenter .logo-wrap > .logo-anchor-guide-mid::before {\n  border-color: #008ada;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-outer-region {\n  position: absolute;\n  width: auto;\n  height: auto;\n  top: 16px;\n  bottom: 16px;\n  left: 26px;\n  right: 26px;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap {\n  position: absolute;\n  height: 85%;\n  top: 0;\n  width: 100%;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap::before, .sgdb-modal-logo-position .logo-positioner .logo-wrap::after,\n.sgdb-modal-logo-position .logo-positioner .logo-wrap > .logo-anchor-guide-mid {\n  display: none;\n  position: absolute;\n  content: \"\";\n  border-color: #008ada;\n  border-width: 3px;\n  width: 12px;\n  height: 12px;\n  z-index: 1;\n  border-radius: 3px;\n  box-sizing: border-box;\n  transition: border-color linear 200ms;\n  opacity: 0.65;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap::before {\n  border-left-style: solid;\n  border-top-style: solid;\n  top: 0;\n  left: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap::after {\n  border-left-style: solid;\n  border-bottom-style: solid;\n  bottom: 0;\n  left: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap > .logo-anchor-guide-mid {\n  width: 15px;\n  height: 100%;\n  left: 50%;\n  top: 0;\n  transform: translateX(-50%);\n  border-top-style: solid;\n  border-bottom-style: solid;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap > .logo-anchor-guide-mid::before {\n  content: \"\";\n  position: inherit;\n  border-color: inherit;\n  z-index: inherit;\n  border-radius: inherit;\n  box-sizing: inherit;\n  border-width: 3px;\n  width: 15px;\n  height: 15px;\n  top: 50%;\n  border-style: solid;\n  transform: translateY(-50%);\n  transition: inherit;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap-pos {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transform: translate(var(--logo-left), var(--logo-top));\n  transition: transform ease 250ms;\n  z-index: 2;\n}\n.sgdb-modal-logo-position .logo-positioner-logo {\n  display: flex;\n  align-items: flex-start;\n  position: relative;\n  z-index: 1;\n  width: var(--logo-width);\n  height: var(--logo-height);\n  transition: width ease 100ms, height ease 100ms;\n}\n.sgdb-modal-logo-position .logo-positioner-logo-img {\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n  transition: object-position ease 250ms;\n}\n.sgdb-modal-logo-position .logo-positioner-hero {\n  width: 100%;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions {\n  display: flex;\n  justify-content: center;\n  flex-wrap: wrap;\n  list-style: none;\n  gap: 2em;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions li {\n  display: flex;\n  align-items: center;\n  gap: 0.75em;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions svg {\n  width: 32px;\n  height: 32px;\n}\n\n.sgdb-modal-official-assets .official-steam-asset {\n  margin: 0 auto;\n}\n.sgdb-modal-official-assets .official-steam-asset.grid_l {\n  max-width: 60%;\n}\n.MediumWindow .sgdb-modal-official-assets .official-steam-asset.grid_p {\n  max-width: 39%;\n}\n\n.WideWindow .sgdb-modal-official-assets .official-steam-asset.grid_p {\n  max-width: 55%;\n}\n\n.sgdb-modal-official-assets .official-steam-asset.hero, .sgdb-modal-official-assets .official-steam-asset.logo {\n  max-width: 100%;\n}\n.sgdb-modal-official-assets .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus {\n  z-index: 10005;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb, .sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb video, .sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n\n#sgdb-wrap {\n  --asset-size: 120px;\n  margin-top: var(--basicui-header-height, 40px);\n  height: calc(100% - var(--basicui-header-height, 40px));\n}\n#sgdb-wrap .tabcontents-wrap {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  flex-direction: column;\n}\n#sgdb-wrap .spinnyboi {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  position: fixed;\n  height: 100%;\n  flex: 1;\n  left: 0;\n  right: 0;\n  z-index: 10008;\n  background: #0E141B;\n  transition: opacity ease-out 250ms, z-index 0s;\n  will-change: opacity;\n}\n#sgdb-wrap .spinnyboi > img {\n  transform: scale(0.75);\n  transition: transform ease-out 300ms;\n  will-change: transform;\n  margin-top: -50px;\n}\n#sgdb-wrap .spinnyboi.loaded {\n  z-index: -1;\n  opacity: 0;\n  transition-delay: 0ms, 300ms;\n}\n#sgdb-wrap .spinnyboi.loaded > img {\n  transform: scale(0.6);\n}\n#sgdb-wrap .settings-container {\n  z-index: 10002;\n  padding: 0.5em 2.8vw;\n  margin: 0 -2.8vw;\n  background-color: var(--gpSystemDarkestGrey, #0E141B);\n}\n#sgdb-wrap .settings-container.force-show {\n  position: sticky;\n  top: 0;\n}\n#sgdb-wrap .settings-container > .sgdb-asset-toolbar {\n  display: flex;\n  width: 100%;\n  gap: var(--gpSpace-Gap, 0.6em);\n}\n#sgdb-wrap .settings-container > .sgdb-asset-toolbar .filter-buttons {\n  align-items: center;\n  display: flex;\n  gap: 0.5em;\n}\n#sgdb-wrap .settings-container > .sgdb-asset-toolbar .filter-buttons > button {\n  min-width: auto;\n  flex: 1;\n  white-space: nowrap;\n}\n#sgdb-wrap .settings-container > .sgdb-asset-toolbar .size-slider {\n  flex: 1;\n  padding: 0.5em 1em;\n  justify-content: center;\n}\n#sgdb-wrap #images-container {\n  display: grid;\n  padding-top: 1em;\n  margin-bottom: 1em;\n  justify-content: space-evenly;\n  grid-auto-flow: dense;\n  row-gap: 1em;\n  column-gap: 0.65em;\n  grid-template-columns: repeat(auto-fill, minmax(min(var(--asset-size), 100%), var(--asset-size)));\n}\n#sgdb-wrap #images-container .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus {\n  z-index: 10005;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb, #sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb video, #sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n#sgdb-wrap #local-images-container {\n  display: grid;\n  grid-template-columns: 30% 1fr;\n  gap: 1em;\n  margin-bottom: 2em;\n}\n#sgdb-wrap #local-images-container .asset-label {\n  text-align: left;\n  color: #fff;\n  font-weight: 500;\n  letter-spacing: 1px;\n  text-transform: uppercase;\n  line-height: 20px;\n  margin-bottom: 0.5em;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable {\n  position: relative;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable .action-overlay {\n  display: none;\n  position: absolute;\n  gap: 0.25em;\n  bottom: 0;\n  right: 0;\n  padding: 0.5em;\n  z-index: 2;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable .action-overlay .action-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  box-sizing: border-box;\n  width: 2.5em;\n  height: 2.5em;\n  border-radius: 2px;\n  background-color: rgba(14, 20, 27, 0.75);\n  padding: 0.65em;\n  transition: background-color 120ms ease;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable .action-overlay .action-button > svg {\n  fill: #fff;\n  width: 100%;\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable .action-overlay .action-button.gpfocus {\n  background-color: rgba(255, 255, 255, 0.75);\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable .action-overlay .action-button.gpfocus > svg {\n  fill: #0e141b;\n}\n#sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable.is-focused .action-overlay, #sgdb-wrap #local-images-container .asset-wrap .Panel.Focusable:hover .action-overlay {\n  display: flex;\n}\n#sgdb-wrap #local-images-container .asset-wrap-grid_p .asset {\n  padding-top: 150%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-hero .asset {\n  padding-top: 32.2916666667%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-hero .asset-img {\n  object-fit: cover;\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo > .Panel.Focusable {\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo .asset {\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo .asset .asset-img {\n  padding: 0.25em;\n  margin: -0.25em auto;\n  width: auto;\n  max-width: 100%;\n  top: 50%;\n  transform: translateY(-50%);\n}\n#sgdb-wrap #local-images-container .asset-wrap-grid_l .asset {\n  padding-top: 46.7391304348%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .asset {\n  max-width: 32px;\n  max-height: 32px;\n  padding-top: 32px;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .action-overlay {\n  padding: 0 !important;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .action-overlay .action-button {\n  width: 32px !important;\n  height: 32px !important;\n  padding: 0.45em !important;\n}\n#sgdb-wrap #local-images-container .asset {\n  display: flex;\n  overflow: hidden;\n}\n#sgdb-wrap #local-images-container .asset .asset-img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: -webkit-fill-available;\n  max-height: 100%;\n}\n\n@keyframes sgdb-fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}";

    const SGDBPage = () => {
        const { get } = useSettings();
        const { setAppId, appOverview } = useSGDB();
        const { appid, assetType = 'grid_p' } = useParams();
        const [currentTab, setCurrentTab] = React.useState();
        const onShowTab = React.useCallback((tabID) => {
            setCurrentTab(tabID);
        }, []);
        React.useEffect(() => {
            setAppId(parseInt(appid, 10));
        }, [appid, setAppId]);
        React.useEffect(() => {
            (async () => {
                const positions = await get('tabs_order', DEFAULT_TABS);
                const hidden = await get('tabs_hidden', []);
                let tabDefault = await get('tab_default', assetType);
                const filtered = positions.filter((x) => !hidden.includes(x));
                // Set first tab as default if default is hidden
                if (!filtered.includes(tabDefault)) {
                    tabDefault = filtered[0];
                }
                setCurrentTab(tabDefault);
            })();
        }, [get, assetType]);
        if (!appOverview || !currentTab)
            return null;
        return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            window.SP_REACT.createElement("style", null, style),
            window.SP_REACT.createElement("div", { id: "sgdb-wrap" },
                window.SP_REACT.createElement(AssetSearchContext, null,
                    window.SP_REACT.createElement(AssetTabs$1, { currentTab: currentTab, onShowTab: onShowTab })))));
    };

    const libraryAssetImageClasses = findModule((mod) => typeof mod === 'object' && mod?.Container?.includes('libraryassetimage'));
    const gamepadLibraryClasses = findModule((mod) => typeof mod === 'object' && mod?.GamepadLibrary?.includes('gamepadlibrary'));
    const homeCarouselClasses = findModule((mod) => typeof mod === 'object' && mod?.Featured && mod?.LabelHeight);
    const appportraitClasses = findModule((mod) => typeof mod === 'object' && mod?.InRecentGames?.includes('appportrait'));

    const patchGridProps = (props) => {
        const gridProps = findInTree(props, (x) => x?.childWidth, { walkable: ['props', 'children', 'childSections'] });
        if (gridProps) {
            gridProps.childHeight = gridProps.childWidth;
        }
    };
    const squareLibraryPatch = (serverApi) => {
        return serverApi.routerHook.addPatch('/library', (props) => {
            // inject css if it isn't there already
            if (!findSP().window.document.getElementById('sgdb-square-capsules-library')) {
                const styleEl = findSP().window.document.createElement('style');
                styleEl.id = 'sgdb-square-capsules-library';
                styleEl.textContent = `
        /* only select covers within library page, otherwise it breaks covers on other pages */
        .${gamepadLibraryClasses.GamepadLibrary} .${libraryAssetImageClasses.Container}.${libraryAssetImageClasses.PortraitImage} {
          padding-top: 100% !important;
        }
      `;
                findSP().window.document.head.append(styleEl);
            }
            // lmao fuck is this
            afterPatch(props.children, 'type', (_, ret) => {
                // console.info('ret', ret);
                let cache = null;
                afterPatch(ret, 'type', (_, ret2) => {
                    if (cache) {
                        ret2.type = cache;
                        return ret2;
                    }
                    wrapReactType(ret2);
                    afterPatch(ret2.type, 'type', (_, ret3) => {
                        cache = ret2.type;
                        // console.info('ret3', ret3);
                        const { tabs, activeTab } = findInReactTree(ret3, (x) => x?.tabs && x?.activeTab);
                        const tab = tabs.find((x) => x.id == activeTab);
                        const collection = tab.content.props.collection;
                        // console.info('collection', collection);
                        afterPatch(tab.content, 'type', (_, ret4) => {
                            // console.info('ret4', ret4);
                            if (!ret4)
                                return ret4;
                            const p1 = findInReactTree(ret4, (x) => x?.type && x.props?.appOverviews);
                            if (p1 && collection) {
                                afterPatch(p1, 'type', (_, ret5) => {
                                    // console.info('ret5', ret5);
                                    patchGridProps(ret5);
                                    return ret5;
                                });
                            }
                            else if (findInReactTree(ret4.props.children, (x) => x?.type && x.type.toString().includes('coverSize'))) {
                                // ignore collections page
                                return ret4;
                            }
                            else {
                                // console.info('ret4 sc', ret4);
                                if (ret4.props.children[0].props?.collectionid) {
                                    // collections
                                    afterPatch(ret4.props.children[0], 'type', (_, ret5) => {
                                        // console.info('ret5 c', ret5);
                                        afterPatch(findInReactTree(ret5, (x) => x?.type && x.props?.collection?.id), 'type', (_, ret6) => {
                                            // console.info('ret6 c', ret6);
                                            afterPatch(findInReactTree(ret6, (x) => x?.type && x.props?.appOverviews), 'type', (_, ret7) => {
                                                // console.info('ret7 c', ret7);
                                                patchGridProps(ret7);
                                                return ret7;
                                            });
                                            return ret6;
                                        });
                                        return ret5;
                                    });
                                }
                                else {
                                    // non-steam shortcuts
                                    const p2 = findInReactTree(ret4, (x) => x?.type && x.props?.collection?.id === 'deck-desktop-apps');
                                    afterPatch(p2, 'type', (_, ret5) => {
                                        // console.info('ret5 s', ret5);
                                        afterPatch(findInReactTree(ret5, (x) => x?.type && x.props?.appOverviews), 'type', (_, ret6) => {
                                            // console.info('ret6 s', ret6);
                                            patchGridProps(ret6);
                                            return ret6;
                                        });
                                        return ret5;
                                    });
                                }
                            }
                            return ret4;
                        });
                        return ret3;
                    });
                    return ret2;
                });
                return ret;
            });
            return props;
        });
    };

    // Add button second to last
    const spliceArtworkItem = (children, appid) => {
        children.splice(-1, 0, (window.SP_REACT.createElement(MenuItem, { key: "sgdb-change-artwork", onSelected: () => {
                Navigation.Navigate(`/steamgriddb/${appid}`);
            } }, trans_string('ACTION_CHANGE_ARTWORK', 'Change artwork...'))));
    };
    const contextMenuPatch = (LibraryContextMenu) => {
        return afterPatch(LibraryContextMenu.prototype, 'render', (_, component) => {
            const appid = component._owner.pendingProps.overview.appid;
            afterPatch(component.type.prototype, 'shouldComponentUpdate', ([nextProps], shouldUpdate) => {
                if (shouldUpdate === true && !nextProps.children.find((x) => x?.key === 'sgdb-change-artwork')) {
                    let updatedAppid = appid;
                    // find the first menu component that has the correct appid assigned to _owner
                    const parentOverview = nextProps.children.find((x) => x?._owner?.pendingProps?.overview?.appid &&
                        x._owner.pendingProps.overview.appid !== appid);
                    // if found then use that appid
                    if (parentOverview) {
                        updatedAppid = parentOverview._owner.pendingProps.overview.appid;
                    }
                    spliceArtworkItem(nextProps.children, updatedAppid);
                }
                return shouldUpdate;
            }, { singleShot: true });
            spliceArtworkItem(component.props.children, appid);
            return component;
        });
    };
    const getMenu = async () => {
        // @ts-ignore: decky global is not typed
        while (!window.DeckyPluginLoader?.routerHook?.routes) {
            await new Promise((resolve) => setTimeout(resolve, 500));
        }
        let LibraryContextMenu = findInReactTree(fakeRenderComponent(findInTree(fakeRenderComponent(
        // @ts-ignore: decky global is not typed
        window.DeckyPluginLoader.routerHook.routes.find((x) => x?.props?.path == '/zoo').props.children.type), (x) => x?.route === '/zoo/modals', {
            walkable: ['props', 'children', 'child', 'pages'],
        }).content.type), (x) => x?.title?.includes('AppActionsMenu')).children.type;
        if (!LibraryContextMenu?.prototype?.AddToHidden) {
            LibraryContextMenu = fakeRenderComponent(LibraryContextMenu).type;
        }
        return LibraryContextMenu;
    };

    const squareHomePatch = (serverApi) => {
        // inject css if it isn't there already
        if (!findSP().window.document.getElementById('sgdb-square-capsules-home')) {
            const styleEl = findSP().window.document.createElement('style');
            styleEl.id = 'sgdb-square-capsules-home';
            styleEl.textContent = `
      /* only select home page */
      .${appportraitClasses.InRecentGames} .${libraryAssetImageClasses.Container}.${libraryAssetImageClasses.PortraitImage} {
        padding-top: 100% !important;
      }
    `;
            findSP().window.document.head.append(styleEl);
        }
        return serverApi.routerHook.addPatch('/library/home', (props) => {
            afterPatch(props.children, 'type', (_, ret) => {
                // console.info('ret', ret);
                afterPatch(ret.type, 'type', (_, ret2) => {
                    let cache3 = null;
                    // console.info('ret2', ret2);
                    const recents = findInReactTree(ret2, (x) => x?.props && ('autoFocus' in x.props) && ('showBackground' in x.props));
                    afterPatch(recents.type, 'type', (_, ret3) => {
                        // console.info('ret3', ret3);
                        if (cache3) {
                            ret3 = cache3;
                            return ret3;
                        }
                        const p = findInReactTree(ret3, (x) => x?.props?.games && x?.props.onItemFocus);
                        afterPatch(p, 'type', (_, ret4) => {
                            cache3 = ret3;
                            // console.info('ret4', ret4);
                            afterPatch(ret4.type, 'type', (_, ret5) => {
                                // console.info('ret5', ret5);
                                const size = ret5.props.children.props.children.props.nItemHeight;
                                ret5.props.children.props.children.props.nItemHeight = size;
                                replacePatch(ret5.props.children.props.children.props, 'fnGetColumnWidth', ([index]) => {
                                    // Leave horizontal grid as wide
                                    if (index === 0) {
                                        return callOriginal;
                                    }
                                    return size - parseInt(homeCarouselClasses.LabelHeight); // this is how valve does it -.-
                                });
                                return ret5;
                            });
                            return ret4;
                        });
                        return ret3;
                    });
                    return ret2;
                });
                return ret;
            });
            return props;
        });
    };

    var index = definePlugin((serverApi) => {
        const getSetting = async (key, fallback) => {
            return (await serverApi.callPluginMethod('get_setting', { key, default: fallback })).result;
        };
        serverApi.routerHook.addRoute('/steamgriddb/:appid/:assetType?', () => (window.SP_REACT.createElement(SettingsProvider, { serverApi: serverApi },
            window.SP_REACT.createElement(SGDBProvider, { serverApi: serverApi },
                window.SP_REACT.createElement(SGDBPage, null)))), {
            exact: true,
        });
        let patchedMenu;
        getMenu().then((LibraryContextMenu) => {
            patchedMenu = contextMenuPatch(LibraryContextMenu);
        });
        let squarePatch;
        let squarePatchHome;
        getSetting('experiment_squares', false).then((enabled) => {
            if (enabled) {
                squarePatch = squareLibraryPatch(serverApi);
                squarePatchHome = squareHomePatch(serverApi);
            }
        });
        return {
            title: window.SP_REACT.createElement("div", { className: quickAccessMenuClasses.Title }, "SteamGridDB"),
            content: window.SP_REACT.createElement(SettingsProvider, { serverApi: serverApi },
                window.SP_REACT.createElement(QuickAccessSettings, { serverApi: serverApi })),
            icon: window.SP_REACT.createElement(MenuIcon, null),
            onDismount() {
                serverApi.routerHook.removeRoute('/steamgriddb/:appid/:assetType?');
                patchedMenu?.unpatch();
                if (squarePatch) {
                    serverApi.routerHook.removePatch('/library', squarePatch);
                }
                if (squarePatchHome) {
                    serverApi.routerHook.removePatch('/library/home', squarePatchHome);
                }
                findSP().window.document.getElementById('sgdb-square-capsules-library')?.remove();
                findSP().window.document.getElementById('sgdb-square-capsules-home')?.remove();
            },
        };
    });

    return index;

})(SP_REACT);
